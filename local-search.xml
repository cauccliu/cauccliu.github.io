<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pytorch实现单目标检测网络</title>
    <link href="/2024/04/17/YelloPersonDetect/"/>
    <url>/2024/04/17/YelloPersonDetect/</url>
    
    <content type="html"><![CDATA[<h1 id="单目标检测"><a href="#单目标检测" class="headerlink" title="单目标检测"></a>单目标检测</h1><h2 id="单目标检测流程"><a href="#单目标检测流程" class="headerlink" title="单目标检测流程"></a>单目标检测流程</h2><p>单目标检测：判断一张图片上是否有对应目标</p><ul><li>人脸检测</li><li>小黄人检测</li></ul><p><img src="https://pic.imgdb.cn/item/661e44830ea9cb14034aebf7.jpg" alt="小黄人检测图片"></p><p>小黄人目标检测：需要考虑的东西</p><ul><li>数据：正负样本。</li><li>二分类：判断是否包含小黄人，输出层sigmoid（数据归一化为0-1，设置一个阈值来判断是否包含小黄人）</li><li>回归：画出框，输出层不需要激活(输出四个坐标值)</li><li>小黄人种类：多分类问题，输出层使用softmax（每类概率和为1），小黄人也是有种类的</li></ul><p>pytorch-Single-target-detection</p><p>数据集：包含正样本和负样本。<br>数据集命名：1.0.0.0.0.0.0.jpg</p><ul><li>第一个数字为序号</li><li>第二个数字代表是否有小黄人，1有，0无</li><li>第三到第六个数字，代表位置。</li><li>第七位为种类数</li></ul><p>实现一个单目标检测模型的流程：</p><ul><li>处理数据</li><li>构建模型</li><li>train</li><li>test</li><li>模型评估</li><li>部署</li></ul><h2 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h2><p>init初始化过程：</p><ul><li>初始化的时候，导入数据，如果是图片，一般保存图片的路径。</li><li>判断是train还是test，来获取具体哪个文件夹下的。</li><li>拼接文件名，获取文件。</li></ul><p>__getitem__函数：获取某个index的图片</p><ul><li>读取self数组中的index索引图片。</li><li>OpenCV或者numpy读取图片，将图片进行缩放,w和h都设置为300，并对图片进行归一化。</li><li>对图片进行换轴，读取到图片维度顺序为HWC，卷积操作中的tensor数据的维度是NCHW，N为Batch Size。</li><li>根据图片名字，按照点，获取图片的二分类标签label，回归点位position，以及类别sort，负样本不进行后续反向传播训练。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,root,is_train=<span class="hljs-literal">True</span></span>):<br>        self.dataset = []<br>        <span class="hljs-built_in">dir</span> = <span class="hljs-string">&#x27;train&#x27;</span> <span class="hljs-keyword">if</span> is_train <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;test&#x27;</span><br>        sub_dir = os.path.join(root,<span class="hljs-built_in">dir</span>)<br>        img_list = os.listdir(sub_dir) <span class="hljs-comment"># 获取文件夹下所有文件</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> img_list:<br>            img_dir = os.path.join(sub_dir,i)<br>            <span class="hljs-comment"># print(img_dir)</span><br>            self.dataset.append(img_dir)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.dataset)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self,index</span>): <span class="hljs-comment"># 当数据被调用时就会触发该函数</span><br>        data = self.dataset[index]<br>        <span class="hljs-comment"># img = cv2.imread(data) # 读到的图片是HWC ，卷积用到的是 NCHW，需要换轴 ，没有OpenCV用底下的两行代码操作代替</span><br><br>        <span class="hljs-comment"># Load the image</span><br>        img = Image.<span class="hljs-built_in">open</span>(data)<br>        img = img.resize((<span class="hljs-number">300</span>,<span class="hljs-number">300</span>))<br>        img = np.array(img)/<span class="hljs-number">255</span> <span class="hljs-comment"># 读入图片并进行归一化</span><br>        <br>        <span class="hljs-comment">#print(img.shape)</span><br>        <span class="hljs-comment"># new_img = np.transpose(img,(2,0,1)) # HWC -&gt; CHW (2,0,1) # Numpy做法 (3, 180, 298)</span><br>        new_img = torch.tensor(img).permute(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-comment"># torch做法 torch.tensor([3, 180, 298])</span><br>        <span class="hljs-comment">#print(new_img.shape)</span><br><br>        <span class="hljs-comment"># 用点分割去取数据</span><br><br>        data_list = data.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>        label = <span class="hljs-built_in">int</span>(data_list[<span class="hljs-number">1</span>])<br>        position = data_list[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>]<br>        position = [<span class="hljs-built_in">int</span>(i)/<span class="hljs-number">300</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> position]<br>        sort = <span class="hljs-built_in">int</span>(data_list[<span class="hljs-number">6</span>])-<span class="hljs-number">1</span> <span class="hljs-comment"># 0就变成-1了</span><br><br>        <span class="hljs-keyword">return</span> np.float32(new_img),np.float32(label),np.float32(position),sort<br></code></pre></td></tr></table></figure><h2 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h2><p>init 构建：</p><ul><li>具体网络设计包含：卷积，LeakyReLU，池化。卷积网络最后一层输出通道为128个通道，最后输出的卷积图像宽高为19*19</li><li>label的预测值：卷积128-&gt;1，对应是否包含目标</li><li>position的预测值：卷积128-&gt;4，对应左上角和右下角的x，y值</li><li>sort的预测值：卷积128-&gt;20，数据集有20类，得到最后在哪一类</li></ul><p>forward(self,x)：</p><ul><li>实施构建网络</li><li>对label，position，sort分别输出得到，并降维。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyNet,self).__init__()<br>        self.layers = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">3</span>),<br>            nn.LeakyReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">3</span>),<br>            nn.Conv2d(<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">3</span>),<br>            nn.LeakyReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Conv2d(<span class="hljs-number">22</span>,<span class="hljs-number">32</span>,<span class="hljs-number">3</span>),<br>            nn.LeakyReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Conv2d(<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">3</span>),<br>            nn.LeakyReLU(),<br>            nn.Conv2d(<span class="hljs-number">64</span>,<span class="hljs-number">128</span>,<span class="hljs-number">3</span>),<br>            nn.LeakyReLU(),<br>        )<br><br>        <span class="hljs-comment"># label的预测值</span><br>        self.label_layers = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">128</span>,<span class="hljs-number">1</span>,<span class="hljs-number">19</span>),<br>            nn.LeakyReLU()<br>        )<br><br>        <span class="hljs-comment"># position的预测值</span><br>        self.position_layer = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">128</span>,<span class="hljs-number">4</span>,<span class="hljs-number">19</span>),<br>            nn.LeakyReLU()<br>        )<br><br>        <span class="hljs-comment"># sort的预测值：真实的数据集有20类。</span><br>        self.sort_layer = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">128</span>,<span class="hljs-number">20</span>,<span class="hljs-number">19</span>),<br>            nn.LeakyReLU()<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        out = self.layers(x)<br><br>        label = self.label_layers(out)<br>        <span class="hljs-comment"># 降维，从四维降为二维</span><br>        label = torch.squeeze(label,dim=<span class="hljs-number">2</span>)<br>        label = torch.squeeze(label,dim=<span class="hljs-number">2</span>)<br>        label = torch.squeeze(label,dim=<span class="hljs-number">1</span>)<br><br>        position = self.position_layer(out)<br>        position = torch.squeeze(position,dim=<span class="hljs-number">2</span>)<br>        position = torch.squeeze(position,dim=<span class="hljs-number">2</span>)<br><br>        sort = self.sort_layer(out)<br>        sort = torch.squeeze(sort,dim=<span class="hljs-number">2</span>)<br>        sort = torch.squeeze(sort,dim=<span class="hljs-number">2</span>)<br><br>        <span class="hljs-keyword">return</span> label,position,sort<br><br></code></pre></td></tr></table></figure><h2 id="训练逻辑"><a href="#训练逻辑" class="headerlink" title="训练逻辑"></a>训练逻辑</h2><p>init:</p><ul><li>初始化一个summaryWriter，可视化数据的初始化。</li><li>loader数据集，包含train和test的，批次大小为50，打乱shuffle。</li><li>self设计好的网络，网络放置在GPU上，后续在GPU上训练。</li><li>确定优化器为Adam</li><li>二分类用BCELOGIST，里面自带着sigmod激活，网络最后输出标签不带激活函数，这里刚好可以用上。</li><li>回归，MSE LOSS</li><li>多分类：cross LOSS，多指交叉熵，自带softmax激活，网络最后输出类别不带激活函数，这里刚好可以用上。</li></ul><p>call函数：</p><ul><li>设定训练epoch，默认是1000</li><li>读取数据集和标签img, label, position, sort，将读取到的数据放到GPU上，后续在GPU上训练。</li><li>将图片放入卷积网络中得到out_label,out_position,out_sort，预测值。</li><li>将三个值分别和标签进行对比，计算各个的loss，相加得到总loss，这里各个loss的权重一样，可以独立设置参数。</li><li>清空梯度，反向传播，更新权重</li><li>每隔十次打印一下训练损失。</li><li>每个epoch，保存一个训练权重。</li><li>test逻辑和训练逻辑差不多，不过不需要进行梯度更新。将图片放入网络，得到结果后和标签进行损失计算，计算标签准确率和平均值。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,root,weight_path</span>):<br>        self.summaryWriter = SummaryWriter(<span class="hljs-string">&#x27;logs&#x27;</span>)<br>        self.train_dataset = MyDataset(root=root,is_train= <span class="hljs-literal">True</span>)<br>        self.test_dataset = MyDataset(root=root,is_train= <span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 挺好，现在知道这玩意是在干嘛了</span><br>        self.train_dataLoader = DataLoader(self.train_dataset,batch_size=<span class="hljs-number">50</span>,shuffle=<span class="hljs-literal">True</span>)<br>        self.test_dataLoader = DataLoader(self.test_dataset,batch_size=<span class="hljs-number">50</span>,shuffle=<span class="hljs-literal">True</span>)<br><br>        self.net = MyNet().to(DEVICE) <span class="hljs-comment"># 放到gpu上</span><br><br>        <span class="hljs-keyword">if</span> os.path.exists(weight_path):<br>            self.net.load_state_dict(torch.load(weight_path))<br><br>        self.opt = optim.Adam(self.net.parameters())<br><br>        <span class="hljs-comment"># 分类，回归，都有损失，怎么计算？</span><br>        <br>        self.label_loss_fun = nn.BCEWithLogitsLoss()  <span class="hljs-comment"># 二分类用BCELOGIST，里面自带着sigmod激活</span><br>        self.position_loss_fun = nn.MSELoss() <span class="hljs-comment"># 回归，MSE LOSS</span><br>        self.sort_loss_fun = nn.CrossEntropyLoss() <span class="hljs-comment"># 多分类：cross LOSS，多指交叉熵，自带softmax激活</span><br><br>        self.train = <span class="hljs-literal">True</span><br>        self.test = <span class="hljs-literal">True</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self</span>):<br>        index1,index2 = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>): <span class="hljs-comment"># 训练1000个epoch</span><br>            <span class="hljs-keyword">if</span> self.train:<br>                <span class="hljs-keyword">for</span> i, (img,label,position,sort) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.train_dataLoader):<br>                    self.net.train()<br>                    <br>                    img, label, position, sort = img.to(DEVICE), label.to(DEVICE), position.to(DEVICE), sort.to(DEVICE) <span class="hljs-comment"># 数据放到GPU上</span><br>                    <span class="hljs-comment"># print(img.shape)</span><br>                    <span class="hljs-comment"># print(label.shape)</span><br>                    out_label,out_position,out_sort = self.net(img)<br>                    <span class="hljs-comment"># print(out_label,out_position,out_sort) </span><br>                    <span class="hljs-comment"># print(out_label.shape)</span><br>                    <br>                    label_loss = self.label_loss_fun(out_label,label)<br>                    <span class="hljs-comment"># print(label_loss)</span><br><br>                    position_loss=self.position_loss_fun(out_position,position)<br>                    <span class="hljs-comment"># print(position.shape)</span><br>                    <span class="hljs-comment"># print(out_position.shape)</span><br>                    <span class="hljs-comment"># print(position_loss)</span><br>                    <br>                    sort = sort[torch.where(sort &gt;= <span class="hljs-number">0</span>)]<br>                    out_sort = out_sort[torch.where(sort &gt;= <span class="hljs-number">0</span>)]<br>                    sort_loss = self.sort_loss_fun(out_sort,sort)<br>                    <span class="hljs-comment"># print(sort_loss)</span><br><br>                    train_loss = label_loss + position_loss + sort_loss<br>                    <br>                    self.opt.zero_grad()<br>                    train_loss.backward()<br>                    self.opt.step()<br><br>                    <span class="hljs-keyword">if</span> i%<span class="hljs-number">10</span> ==<span class="hljs-number">0</span> :<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;train_loss<span class="hljs-subst">&#123;i&#125;</span>===&gt;&#x27;</span>,train_loss.item())<br>                        self.summaryWriter.add_scalar(<span class="hljs-string">&#x27;train_loss&#x27;</span>,train_loss,index1)<br>                        index1 +=<span class="hljs-number">1</span><br>                    <br>                data_time = <span class="hljs-built_in">str</span>(datetime.datetime.now()).replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>).replace(<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>).replace(<span class="hljs-string">&#x27;·&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>)<br>                save_dir = <span class="hljs-string">&#x27;param&#x27;</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(save_dir):<br>                    os.makedirs(save_dir)<br><br>                <span class="hljs-comment"># 保存权重文件</span><br>                torch.save(self.net.state_dict(), <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;save_dir&#125;</span>/<span class="hljs-subst">&#123;data_time&#125;</span>-<span class="hljs-subst">&#123;epoch&#125;</span>.pt&#x27;</span>)<br>            <br>            <span class="hljs-keyword">if</span> self.test:<br>                sum_sort_acc,sum_label_acc = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> i, (img,label,position,sort) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.test_dataLoader):<br>                    self.net.train()<br>                    <br>                    img, label, position, sort = img.to(DEVICE), label.to(DEVICE), position.to(DEVICE), sort.to(DEVICE) <span class="hljs-comment"># 数据放到GPU上</span><br>                    <br>                    out_label,out_position,out_sort = self.net(img)<br>                    <br>                    label_loss = self.label_loss_fun(out_label,label)<br><br>                    position_loss=self.position_loss_fun(out_position,position)<br>                    <br>                    <span class="hljs-comment"># print(position_loss)</span><br>                    <br>                    sort = sort[torch.where(sort&gt;=<span class="hljs-number">0</span>)]<br>                    out_sort = out_sort[torch.where(sort &gt;= <span class="hljs-number">0</span>)]<br>                    sort_loss = self.sort_loss_fun(out_sort,sort)<br>                    <span class="hljs-comment"># print(sort_loss)</span><br><br>                    test_loss = label_loss + position_loss + sort_loss<br><br>                    out_label = torch.tensor(torch.sigmoid(out_label))<br>                    out_label[torch.where(out_label&gt;=<span class="hljs-number">0.5</span>)] = <span class="hljs-number">1</span><br>                    out_label[torch.where(out_label&lt;<span class="hljs-number">0.5</span>)] = <span class="hljs-number">0</span><br><br>                    label_acc = torch.mean(torch.eq(out_label,label).<span class="hljs-built_in">float</span>())<br>                    sum_label_acc += label_acc <br><br>                    <span class="hljs-comment"># 求准确率</span><br>                    <span class="hljs-comment"># out_sort = torch.argmax(torch.softmax(out_sort,dim=1))</span><br>                    <span class="hljs-keyword">if</span> out_sort.numel() &gt; <span class="hljs-number">0</span>:<br>                        out_sort = torch.argmax(torch.softmax(out_sort, dim=<span class="hljs-number">1</span>))<br>                        out_sort = out_sort.to(sort.device)  <span class="hljs-comment"># Move out_sort to the same device as sort</span><br>                    <span class="hljs-keyword">else</span>:<br>                        out_sort = torch.tensor([], device=sort.device)  <span class="hljs-comment"># Or handle the empty case </span><br><br>                    sort_acc = torch.mean(torch.eq(sort,out_sort).<span class="hljs-built_in">float</span>())<br>                    sum_sort_acc += sort_acc<br>                    <br>                    <span class="hljs-keyword">if</span> i%<span class="hljs-number">10</span> ==<span class="hljs-number">0</span> :<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;test_loss<span class="hljs-subst">&#123;i&#125;</span>===&gt;&#x27;</span>,test_loss.item())<br>                        self.summaryWriter.add_scalar(<span class="hljs-string">&#x27;test_loss&#x27;</span>,test_loss,index2)<br>                        index2 +=<span class="hljs-number">1</span><br>                    <br>                avg_sort_acc = sum_sort_acc/i<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;avg_sort_acc <span class="hljs-subst">&#123;epoch&#125;</span>====&gt;&#x27;</span>,avg_sort_acc)<br>                self.summaryWriter.add_scalar(<span class="hljs-string">&#x27;avg_sort_acc&#x27;</span>,avg_sort_acc,epoch)<br><br>                avg_label_acc = sum_label_acc/i<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;avg_label_acc <span class="hljs-subst">&#123;epoch&#125;</span>====&gt;&#x27;</span>,avg_label_acc)<br>                self.summaryWriter.add_scalar(<span class="hljs-string">&#x27;avg_label_acc&#x27;</span>,avg_label_acc,epoch) <br><br></code></pre></td></tr></table></figure><h2 id="利用训练好的权重进行预测"><a href="#利用训练好的权重进行预测" class="headerlink" title="利用训练好的权重进行预测"></a>利用训练好的权重进行预测</h2><p>预测流程：</p><ul><li>读取test文件夹，依次读取img</li><li>读取标签值和坐标值，输出在图片上。</li><li>网络预测标签和坐标值，也输出在图片上，可以直观的对比网络预测值和标签值的差异。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    img_name = os.listdir(<span class="hljs-string">&#x27;/home/liuchang/codetest/PythonCode/YellowPersonDetect/yellow_data/test&#x27;</span>) <span class="hljs-comment"># 获取文件路径</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> img_name:<br>        img_dir = os.path.join(<span class="hljs-string">&#x27;/home/liuchang/codetest/PythonCode/YellowPersonDetect/yellow_data/test&#x27;</span>,i) <span class="hljs-comment"># 获取img</span><br><br>        img = cv2.imread(img_dir)<br><br>        position = i.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>] <span class="hljs-comment"># 读取位置坐标</span><br>        position = [<span class="hljs-built_in">int</span>(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> position]<br>        sort =  i.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">6</span>]<br>        cv2.rectangle(img,(position[<span class="hljs-number">0</span>],position[<span class="hljs-number">1</span>]),(position[<span class="hljs-number">3</span>],position[<span class="hljs-number">4</span>]),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),thickness=<span class="hljs-number">2</span>) <span class="hljs-comment"># 画label框</span><br>        cv2.putText(img,sort,(position[<span class="hljs-number">0</span>],position[<span class="hljs-number">1</span>]-<span class="hljs-number">3</span>),cv2.FONT_HERSHEY_SIMPLEX,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),thickness=<span class="hljs-number">2</span>) <span class="hljs-comment">#左上角的点上写出类型</span><br><br>        model = MyNet()<br>        model.load_state_dict(torch.load(<span class="hljs-string">&#x27;param/2024-04-10-14_37_43.382495-50.pt&#x27;</span>))<br>        new_img = torch.tensor(img).permute(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        torch.unsqueeze(new_img,dim=<span class="hljs-number">0</span>)/<span class="hljs-number">255</span> <span class="hljs-comment"># 传递一个维度，归一化</span><br><br>        label_out,out_position,out_sort = model(new_img)<br>        label_out = torch.sigmoid(label_out) <span class="hljs-comment"># 网络模型没有做归一化，这里就要做归一化</span><br>        out_sort = torch.argmax(torch.softmax(out_sort,dim=<span class="hljs-number">1</span>))<br><br>        out_position = out_position[<span class="hljs-number">0</span>]*<span class="hljs-number">300</span><br>        out_position = [<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> out_position]<br>        <span class="hljs-keyword">if</span> label_out.item()&gt;<span class="hljs-number">0.5</span> :<br>            cv2.rectangle(img,(out_position[<span class="hljs-number">0</span>],out_position[<span class="hljs-number">1</span>]),(out_position[<span class="hljs-number">3</span>],out_position[<span class="hljs-number">4</span>]),(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),thickness=<span class="hljs-number">2</span>) <span class="hljs-comment"># 画label框</span><br>            cv2.putText(img,<span class="hljs-built_in">str</span>(out_sort.item()),(out_position[<span class="hljs-number">0</span>],out_position[<span class="hljs-number">1</span>]-<span class="hljs-number">3</span>),cv2.FONT_HERSHEY_SIMPLEX,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),thickness=<span class="hljs-number">2</span>) <span class="hljs-comment">#左上角的点上写出类型</span><br>        <br>        cv2.imshow(<span class="hljs-string">&#x27;img&#x27;</span>,img)<br>        cv2.waitKey(<span class="hljs-number">500</span>)<br>        cv2.destroyAllWindows() <span class="hljs-comment"># 展示图片后关闭图片</span><br></code></pre></td></tr></table></figure><p>完整代码：<a href="https://github.com/cauccliu/SingleObjectDetect">https://github.com/cauccliu/SingleObjectDetect</a></p><p>参考列表：</p><ul><li><a href="https://www.bilibili.com/video/BV1eq4y1H75J/?spm_id_from=333.999.0.0&amp;vd_source=a4ddf2ef7da26e74ca075b2059607bd6">https://www.bilibili.com/video/BV1eq4y1H75J/?spm_id_from=333.999.0.0&amp;vd_source=a4ddf2ef7da26e74ca075b2059607bd6</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch实现手写数字识别</title>
    <link href="/2024/04/09/Pytorch%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <url>/2024/04/09/Pytorch%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h1><p>Pytorch 实现手写数字识别，加深对网络模型理解和Pytorch代码理解</p><h2 id="全连接网络模型构建"><a href="#全连接网络模型构建" class="headerlink" title="全连接网络模型构建"></a>全连接网络模型构建</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net_v1</span>(nn.Module):<br>    <span class="hljs-comment"># 初始化模型</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Net_v1,self).__init__()<br>        <span class="hljs-comment"># 全连接网络</span><br>        self.fc_layers=nn.Sequential(<br>            nn.Linear(<span class="hljs-number">1</span>*<span class="hljs-number">28</span>*<span class="hljs-number">28</span>,<span class="hljs-number">100</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">50</span>,<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">32</span>,<span class="hljs-number">16</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">16</span>,<span class="hljs-number">10</span>),<br>            nn.Softmax(dim=<span class="hljs-number">1</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-keyword">return</span> self.fc_layers(x)<br></code></pre></td></tr></table></figure><h2 id="卷积网络模型构建"><a href="#卷积网络模型构建" class="headerlink" title="卷积网络模型构建"></a>卷积网络模型构建</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net_v2</span>(nn.Module):<br>    <span class="hljs-comment"># 初始化模型</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Net_v2,self).__init__()<br>        <span class="hljs-comment"># 全连接网络</span><br>        self.layers=nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">1</span>,<span class="hljs-number">16</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Conv2d(<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">32</span>,<span class="hljs-number">44</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">44</span>,<span class="hljs-number">64</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)),<br>            nn.ReLU(),<br>        )<br><br>        self.outlayers = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">64</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>, <span class="hljs-number">10</span>),<br>            nn.Softmax(dim=<span class="hljs-number">1</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        out = self.layers(x).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">64</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>)<br>        out = self.outlayers(out)<br>        <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure><h2 id="模型训练代码"><a href="#模型训练代码" class="headerlink" title="模型训练代码"></a>模型训练代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train_v1</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,weight_path</span>):<br>        self.summaryWriter = SummaryWriter(<span class="hljs-string">&#x27;./logs&#x27;</span>) <span class="hljs-comment"># 创建文件夹存放日志</span><br><br>        self.net = Net_v1()  <span class="hljs-comment"># 实例化Net_v1对象</span><br>        self.net = self.net.to(DEVICE)  <span class="hljs-comment"># 将Net_v1对象移动到设备上</span><br>        <span class="hljs-comment"># self.net = Net_v1.to(DEVICE) # cuda上训练</span><br><br>        <span class="hljs-keyword">if</span> os.path.exists(weight_path):<br>            self.net.load_state_dict(torch.load(weight_path))<br>        <br>        self.opt = optim.Adam(self.net.parameters())<br>        self.fc_loss = nn.MSELoss()<br>        self.train = <span class="hljs-literal">True</span><br>        self.test = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self</span>):<br>        index1,index2 = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>            <span class="hljs-keyword">if</span> self.train:<br>                <span class="hljs-keyword">for</span> i,(img,label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_dataloader): <span class="hljs-comment"># 自动会生成一个索引</span><br>                    <span class="hljs-comment">#print(img.shape) # 64 1 28 28</span><br>                    <span class="hljs-comment">#print(label.shape) # 64 </span><br>                    label = one_hot(label,<span class="hljs-number">10</span>).<span class="hljs-built_in">float</span>().to(DEVICE) <span class="hljs-comment"># one-hot 编码，只有一个类别会显示为1，其他的为0 # to(DEVICE)放到cuda上</span><br>                    <span class="hljs-comment"># print(label) # [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.]</span><br>                    img = img.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>*<span class="hljs-number">28</span>*<span class="hljs-number">28</span>).to(DEVICE)<br>                    <span class="hljs-comment"># print(img.shape) # torch.Size([64, 784])</span><br>                    <span class="hljs-comment"># print(label.shape) # torch.Size([64, 10])</span><br>                    train_y = self.net(img) <span class="hljs-comment"># 将图片输入网络，train_y就是预测值</span><br>                    <span class="hljs-comment"># print(train_y.shape) # torch.Size([64, 10])</span><br>                    train_loss = self.fc_loss(train_y,label)<br>                <br>                    <span class="hljs-comment"># 清空梯度</span><br>                    self.opt.zero_grad()<br><br>                    <span class="hljs-comment"># 梯度计算</span><br>                    train_loss.backward()<br><br>                    <span class="hljs-comment"># 梯度更新</span><br>                    self.opt.step()<br><br>                    <span class="hljs-keyword">if</span> i%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> :<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;train_loss <span class="hljs-subst">&#123;i&#125;</span> ===&gt;&quot;</span>, train_loss.item())<br>                        self.summaryWriter.add_scalar(<span class="hljs-string">&#x27;train_loss&#x27;</span>,train_loss,index1)<br>                        index1 +=<span class="hljs-number">1</span><br><br>                data_time = <span class="hljs-built_in">str</span>(datetime.datetime.now()).replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>).replace(<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>).replace(<span class="hljs-string">&#x27;·&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>)<br>                save_dir = <span class="hljs-string">&#x27;param&#x27;</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(save_dir):<br>                    os.makedirs(save_dir)<br><br>                <span class="hljs-comment"># 保存权重文件</span><br>                torch.save(self.net.state_dict(), <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;save_dir&#125;</span>/<span class="hljs-subst">&#123;data_time&#125;</span>-<span class="hljs-subst">&#123;epoch&#125;</span>.pt&#x27;</span>)<br>                <span class="hljs-comment"># torch.save(self.net.state_dict(),f&#x27;param/&#123;data_time&#125;-&#123;epoch&#125;.pt&#x27;)# 保存权重</span><br><br>            <span class="hljs-keyword">if</span> self.test:<br>                <span class="hljs-comment"># 测试</span><br>                <span class="hljs-keyword">for</span> i,(img,label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_dataloader): <span class="hljs-comment"># 自动会生成一个索引</span><br>                 <br>                    label = one_hot(label,<span class="hljs-number">10</span>).<span class="hljs-built_in">float</span>().to(DEVICE) <br>                    img = img.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>*<span class="hljs-number">28</span>*<span class="hljs-number">28</span>).to(DEVICE)<br>                <br>                    test_y = self.net(img) <br>                    test_loss = self.fc_loss(test_y,label)<br>                <br>                    <span class="hljs-comment"># 测试不需要梯度计算了</span><br><br>                    <span class="hljs-comment"># 查看准确率</span><br>                    test_y = torch.argmax(test_y,dim=<span class="hljs-number">1</span>)<br>                    label = torch.argmax(label,dim=<span class="hljs-number">1</span>)<br>                    acc = torch.mean(torch.eq(test_y,label).<span class="hljs-built_in">float</span>()) <span class="hljs-comment"># torch.mean 均值</span><br><br>                    <span class="hljs-keyword">if</span> i%<span class="hljs-number">10</span> ==<span class="hljs-number">0</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;train_loss <span class="hljs-subst">&#123;i&#125;</span> ===&gt;&quot;</span>, test_loss.item())<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;acc <span class="hljs-subst">&#123;i&#125;</span>====&gt;&#x27;</span>,acc.item())<br>                        self.summaryWriter.add_scalar(<span class="hljs-string">&#x27;test_loss&#x27;</span>,test_loss,index2)<br>                        index2 +=<span class="hljs-number">1</span><br>                <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train_v2</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,weight_path</span>):<br>        self.summaryWriter = SummaryWriter(<span class="hljs-string">&#x27;./logs&#x27;</span>) <span class="hljs-comment"># 创建文件夹存放日志</span><br><br>        self.net = Net_v2()  <span class="hljs-comment"># 实例化Net_v1对象</span><br>        self.net = self.net.to(DEVICE)  <span class="hljs-comment"># 将Net_v1对象移动到设备上</span><br>        <span class="hljs-comment"># self.net = Net_v1.to(DEVICE) # cuda上训练</span><br><br>        <span class="hljs-keyword">if</span> os.path.exists(weight_path):<br>            self.net.load_state_dict(torch.load(weight_path))<br>        <br>        self.opt = optim.Adam(self.net.parameters())<br>        self.fc_loss = nn.MSELoss()<br>        self.train = <span class="hljs-literal">True</span><br>        self.test = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self</span>):<br>        index1,index2 = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>            <span class="hljs-keyword">if</span> self.train:<br>                <span class="hljs-keyword">for</span> i,(img,label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_dataloader): <span class="hljs-comment"># 自动会生成一个索引</span><br>                    label = one_hot(label,<span class="hljs-number">10</span>).<span class="hljs-built_in">float</span>().to(DEVICE) <span class="hljs-comment"># one-hot 编码，只有一个类别会显示为1，其他的为0 # to(DEVICE)放到cuda上</span><br>                    <span class="hljs-comment"># img = img.reshape(-1,1*28*28).to(DEVICE) # 图像本身就是3维的，不需要再reshape</span><br>                    <span class="hljs-comment"># print(img.shape) # torch.Size([64, 1, 28, 28])</span><br>                    img = img.to(DEVICE)<br>                    train_y = self.net(img) <br>                    train_loss = self.fc_loss(train_y,label)<br>                <br>                    <span class="hljs-comment"># 清空梯度</span><br>                    self.opt.zero_grad()<br>                    <span class="hljs-comment"># 梯度计算</span><br>                    train_loss.backward()<br>                    <span class="hljs-comment"># 梯度更新</span><br>                    self.opt.step()<br><br>                    <span class="hljs-keyword">if</span> i%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> :<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;train_loss <span class="hljs-subst">&#123;i&#125;</span> ===&gt;&quot;</span>, train_loss.item())<br>                        self.summaryWriter.add_scalar(<span class="hljs-string">&#x27;train_loss&#x27;</span>,train_loss,index1)<br>                        index1 +=<span class="hljs-number">1</span><br><br>                data_time = <span class="hljs-built_in">str</span>(datetime.datetime.now()).replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>).replace(<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>).replace(<span class="hljs-string">&#x27;·&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>)<br>                save_dir = <span class="hljs-string">&#x27;param&#x27;</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(save_dir):<br>                    os.makedirs(save_dir)<br><br>                <span class="hljs-comment"># 保存权重文件</span><br>                torch.save(self.net.state_dict(), <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;save_dir&#125;</span>/<span class="hljs-subst">&#123;data_time&#125;</span>-<span class="hljs-subst">&#123;epoch&#125;</span>.pt&#x27;</span>)<br>                <span class="hljs-comment"># torch.save(self.net.state_dict(),f&#x27;param/&#123;data_time&#125;-&#123;epoch&#125;.pt&#x27;)# 保存权重</span><br><br>            <span class="hljs-keyword">if</span> self.test:<br>                <span class="hljs-comment"># 测试</span><br>                <span class="hljs-keyword">for</span> i,(img,label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_dataloader): <span class="hljs-comment"># 自动会生成一个索引</span><br>                 <br>                    label = one_hot(label,<span class="hljs-number">10</span>).<span class="hljs-built_in">float</span>().to(DEVICE) <br>                    <span class="hljs-comment"># img = img.reshape(-1,1*28*28).to(DEVICE)</span><br>                    img = img.to(DEVICE)<br>                    test_y = self.net(img) <br>                    test_loss = self.fc_loss(test_y,label)<br>                <br>                    <span class="hljs-comment"># 测试不需要梯度计算了</span><br><br>                    <span class="hljs-comment"># 查看准确率</span><br>                    test_y = torch.argmax(test_y,dim=<span class="hljs-number">1</span>)<br>                    label = torch.argmax(label,dim=<span class="hljs-number">1</span>)<br>                    acc = torch.mean(torch.eq(test_y,label).<span class="hljs-built_in">float</span>()) <span class="hljs-comment"># torch.mean 均值</span><br><br>                    <span class="hljs-keyword">if</span> i%<span class="hljs-number">10</span> ==<span class="hljs-number">0</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;train_loss <span class="hljs-subst">&#123;i&#125;</span> ===&gt;&quot;</span>, test_loss.item())<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;acc <span class="hljs-subst">&#123;i&#125;</span>====&gt;&#x27;</span>,acc.item())<br>                        self.summaryWriter.add_scalar(<span class="hljs-string">&#x27;test_loss&#x27;</span>,test_loss,index2)<br>                        index2 +=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>github:<a href="https://github.com/cauccliu/HandNumer">https://github.com/cauccliu/HandNumer</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ asio学习五</title>
    <link href="/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E4%BA%94/"/>
    <url>/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="C-asio学习五"><a href="#C-asio学习五" class="headerlink" title="C++ asio学习五"></a>C++ asio学习五</h1><h2 id="网络结构的更新"><a href="#网络结构的更新" class="headerlink" title="网络结构的更新"></a>网络结构的更新</h2><ol><li>asio网络层，会使用io_context进行数据封装，底层的话，<code>在linux中就是epoll模型，在windows就是iocp模型。</code><br><img src="https://img-blog.csdnimg.cn/direct/d41785b62065439faf9c6faa5befbd08.png" alt="在这里插入图片描述"></li><li>当服务器的接受数据较多时，又要处理接收到的信息的逻辑处理，逻辑处理一般会放到一个<code>逻辑处理队列中进行处理。</code>因为有时候逻辑比较复杂。</li><li>通过一个队列，单独线程从队列中取出逻辑函数。从而实现网络线程和逻辑线程分开，由一个队列进行连接。极大地提升网络线程的收发能力，并且可以用多线程的方式管理网络层。</li><li>asio的多线程模式：<ul><li>启动n个线程，每个线程都有一个iocontext，每个线程负责一部分的socket。</li><li>一个ioconext由多个线程共享。也可以一定程度上减轻readhandler的负担。</li></ul></li><li>逻辑处理一般都是单线程的，因为大量的用户同时处理一个逻辑过程的时候，频繁地加锁取消锁，还不如就单线程的来做。</li></ol><p>完善消息结构：<br>消息 &#x3D; 消息id + 消息长度 + 消息内容。 <strong>前两部分统一封装到消息头里</strong>，tlv格式。消息id占2个字节，消息长度占2个字节，消息头共4个字节。</p><p>更新消息节点：<code>将收取消息的类和发送消息的类，继承自消息基类。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//HEAD_TOTAL_LEN = 4 包含id 和 消息长度。</span><br>SendNode::<span class="hljs-built_in">SendNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id):<span class="hljs-built_in">MsgNode</span>(max_len + HEAD_TOTAL_LEN)<br>, _msg_id(msg_id)&#123;<br>    <span class="hljs-comment">//先发送id, 本机字节序转为网络字节序</span><br>    <span class="hljs-type">short</span> msg_id_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(msg_id);<br>    <span class="hljs-built_in">memcpy</span>(_data, &amp;msg_id_host, HEAD_ID_LEN); <span class="hljs-comment">// 变量按照字节流的方式，写到_data的前两个字节。</span><br>    <span class="hljs-comment">//消息长度和消息体本身  转为网络字节序</span><br>    <span class="hljs-type">short</span> max_len_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(max_len);<br>    <span class="hljs-comment">// 消息体长度信息的拷贝。</span><br>    <span class="hljs-built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;max_len_host, HEAD_DATA_LEN);<br>    <span class="hljs-comment">// 消息体本身的拷贝。</span><br>    <span class="hljs-built_in">memcpy</span>(_data + HEAD_ID_LEN + HEAD_DATA_LEN, msg, max_len);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h3><ol><li>通过静态成员变量实现单例。<code>存在隐患，对于多线程方式生成的实例可能是多个。</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Single2</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Single2</span>() &#123;&#125;<br><span class="hljs-built_in">Single2</span>(<span class="hljs-type">const</span> Single2&amp;) = <span class="hljs-keyword">delete</span>;<br>Single2&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Single2&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 静态局部变量实现单例</span><br><span class="hljs-function"><span class="hljs-type">static</span> Single2&amp; <span class="hljs-title">GetInst</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">static</span> Single2 single; <span class="hljs-comment">// 生命周期和进程一样，函数的局部静态变量生命周期随着进程结束而结束。</span><br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Single2Hungry</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Single2Hungry</span>()<br>    &#123;<br>    &#125;<br>    <span class="hljs-built_in">Single2Hungry</span>(<span class="hljs-type">const</span> Single2Hungry &amp;) = <span class="hljs-keyword">delete</span>;<br>    Single2Hungry &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Single2Hungry &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Single2Hungry *<span class="hljs-title">GetInst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (single == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Single2Hungry</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Single2Hungry *single;<br>&#125;;<br><span class="hljs-comment">// 初始化</span><br>Single2Hungry *Single2Hungry::single = Single2Hungry::<span class="hljs-built_in">GetInst</span>();<br><br></code></pre></td></tr></table></figure><p>饿汉式是在程序启动时就进行单例的初始化，这种方式也可以通过懒汉式调用，无论饿汉式还是懒汉式都存在一个问题，就是什么时候释放内存？多线程情况下，释放内存就很难了，还有二次释放内存的风险。</p><h3 id="懒汉式指针"><a href="#懒汉式指针" class="headerlink" title="懒汉式指针"></a>懒汉式指针</h3><p>单例模式的单例由指针存在，创建单例的时候，用加锁的方式进行判断。防止在加锁的过程中，出现单例类被创建的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglePointer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SinglePointer</span>()<br>    &#123;<br>    &#125;<br>    <span class="hljs-built_in">SinglePointer</span>(<span class="hljs-type">const</span> SinglePointer &amp;) = <span class="hljs-keyword">delete</span>;<br>    SinglePointer &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SinglePointer &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SinglePointer *<span class="hljs-title">GetInst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (single != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        s_mutex.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (single != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s_mutex.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SinglePointer</span>();<br>        s_mutex.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> SinglePointer *single;<br>    <span class="hljs-type">static</span> mutex s_mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="智能指针设计单例类"><a href="#智能指针设计单例类" class="headerlink" title="智能指针设计单例类"></a>智能指针设计单例类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleAuto</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">SingleAuto</span>()<br>&#123;<br>&#125;<br><span class="hljs-built_in">SingleAuto</span>(<span class="hljs-type">const</span> SingleAuto&amp;) = <span class="hljs-keyword">delete</span>;<br>SingleAuto&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SingleAuto&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>~<span class="hljs-built_in">SingleAuto</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;single auto delete success &quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="hljs-title">GetInst</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (single != <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>s_mutex.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (single != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>s_mutex.<span class="hljs-built_in">unlock</span>();<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>single = std::<span class="hljs-built_in">shared_ptr</span>&lt;SingleAuto&gt;(<span class="hljs-keyword">new</span> SingleAuto);<br>s_mutex.<span class="hljs-built_in">unlock</span>();<br><span class="hljs-keyword">return</span> single;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;<br><span class="hljs-type">static</span> mutex s_mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="服务器优雅退出"><a href="#服务器优雅退出" class="headerlink" title="服务器优雅退出"></a>服务器优雅退出</h2><ul><li>服务器退出之前，要把服务器逻辑队列中的服务执行完成。</li><li>asio提供的信号建立的方式，<code>利用signal_set 定义了一系列信号合集，并且绑定了一个匿名函数，匿名函数捕获了io_context的引用</code>，并且函数中设置了停止操作，也就是说当<code>捕获到SIGINT,SIGTERM等信号时，会调用io_context.stop</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        boost::asio::io_context  io_context;<br>        <span class="hljs-comment">// 绑定信号 想捕获的信号，都加进去就行了 捕获io_context的收到的信号</span><br>        boost::<span class="hljs-function">asio::signal_set <span class="hljs-title">signals</span><span class="hljs-params">(io_context, SIGINT, SIGTERM)</span></span>;<br>        <span class="hljs-comment">// 异步等待方式，等待停止信号</span><br>        <span class="hljs-comment">// 绑定了一个匿名函数，匿名函数捕获了io_context的引用，并且函数中设置了停止操作，也就是说当捕获到SIGINT,SIGTERM等信号时，会调用io_context.stop</span><br>        signals.<span class="hljs-built_in">async_wait</span>([&amp;io_context](<span class="hljs-keyword">auto</span>, <span class="hljs-keyword">auto</span>) &#123;<br>            io_context.<span class="hljs-built_in">stop</span>();<br>            &#125;);<br>        <span class="hljs-function">CServer <span class="hljs-title">s</span><span class="hljs-params">(io_context, <span class="hljs-number">10086</span>)</span></span>;<br>        io_context.<span class="hljs-built_in">run</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="asio的多线程模型IOService"><a href="#asio的多线程模型IOService" class="headerlink" title="asio的多线程模型IOService"></a>asio的多线程模型IOService</h2><ol><li><p>第一个是启动多个线程，每个线程管理一个iocontext。第二种是只启动一个iocontext，被多个线程共享。<br><img src="https://pic.imgdb.cn/item/66040bdb9f345e8d03a477cb.png" alt="在这里插入图片描述"></p></li><li><p>启动线程的个数，不要超过核数。</p></li><li><p><code>每个线程独立调用io_context，一个socket会被注册在同一个io_context里</code>，它的回调函数也会被单独的一个线程回调:</p><ul><li>那么对于同一个socket，他的回调函数每次触发都是在同一个线程里，<code>就不会有线程安全问题，网络io层面上的并发是线程安全的。</code></li><li>如果两个socket对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。可以通过<code>加锁</code>或者<code>逻辑队列</code>的方式解决安全问题。</li></ul></li><li><p><strong>多线程的优势：提升了并发能力</strong>， 单线程仅有一个io_context服务用来监听读写事件，就绪后回调函数在一个线程里串行调用。如果一个回调函数的调用时间较长肯定会影响后续的函数调用。</p></li><li><p><code>通过逻辑队列的方式将网络线程和逻辑线程解耦合，不会出现前一个调用时间影响下一个回调触发的问题。</code></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsioIOServicePool</span> :<span class="hljs-keyword">public</span> Singleton&lt;AsioIOServicePool&gt;<br>&#123;<br>    <span class="hljs-keyword">friend</span> Singleton&lt;AsioIOServicePool&gt;; <span class="hljs-comment">//声明友元，用这个类访问构造函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> IOService = boost::asio::io_context; <span class="hljs-comment">// 定义别名</span><br>    <span class="hljs-comment">// 通常会将一些异步操作提交给io_context进行处理，然后该操作会被异步执行，而不会立即返回结果。</span><br>    <span class="hljs-comment">// 如果没有其他任务需要执行，那么io_context就会停止工作，导致所有正在进行的异步操作都被取消。</span><br>    <span class="hljs-comment">// 这时，我们需要使用boost::asio::io_context::work对象来防止io_context停止工作。</span><br>    <span class="hljs-keyword">using</span> Work = boost::asio::io_context::work; <span class="hljs-comment">// work，防止io_context在没有被注册事件的时候退出。</span><br>    <span class="hljs-keyword">using</span> WorkPtr = std::unique_ptr&lt;Work&gt;; <span class="hljs-comment">//work不被改变。</span><br><br>    ~<span class="hljs-built_in">AsioIOServicePool</span>();<br>    <span class="hljs-built_in">AsioIOServicePool</span>(<span class="hljs-type">const</span> AsioIOServicePool&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//不加引用的话，会造成一个递归构造的危险，不允许拷贝构造</span><br>    AsioIOServicePool&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> AsioIOServicePool&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">// 使用 round-robin 的方式返回一个 io_service</span><br>    boost::<span class="hljs-function">asio::io_context&amp; <span class="hljs-title">GetIOService</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 轮询的方式</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 停止ioservice</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 不让外界直接调用</span><br>    <span class="hljs-built_in">AsioIOServicePool</span>(std::<span class="hljs-type">size_t</span> size = std::thread::<span class="hljs-built_in">hardware_concurrency</span>()); <span class="hljs-comment">//根据CPU核数去创建线程数量</span><br>    std::vector&lt;IOService&gt; _ioServices; <span class="hljs-comment">//IOService的vector变量，用来存储初始化的多个IOService。</span><br>    std::vector&lt;WorkPtr&gt; _works;<br>    std::vector&lt;std::thread&gt; _threads;<br>    std::<span class="hljs-type">size_t</span>   _nextIOService;<span class="hljs-comment">//下标</span><br>&#125;;<br><br><span class="hljs-comment">// 构造函数，初始化size个ioservice，size个_works, _ioServices绑定到works</span><br><span class="hljs-comment">// _ioServices放到不同的线程中。</span><br>AsioIOServicePool::<span class="hljs-built_in">AsioIOServicePool</span>(std::<span class="hljs-type">size_t</span> size) :_ioServices(size),<br>_works(size), _nextIOService(<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        _works[i] = std::<span class="hljs-built_in">unique_ptr</span>&lt;Work&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Work</span>(_ioServices[i]));<br>    &#125;<br>    <span class="hljs-comment">//遍历多个ioservice，创建多个线程，每个线程内部启动ioservice</span><br>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _ioServices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        _threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>, i]() &#123;<br>            _ioServices[i].<span class="hljs-built_in">run</span>();<span class="hljs-comment">// 如果不绑定work，run()就会直接返回了</span><br>            &#125;);<br>    &#125;<br>&#125;<br><br>AsioIOServicePool::~<span class="hljs-built_in">AsioIOServicePool</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;destruct&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 轮询的方式，每次取出来的ioservice都不同。</span><br>boost::<span class="hljs-function">asio::io_context&amp; <span class="hljs-title">AsioIOServicePool::GetIOService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span>&amp; service = _ioServices[_nextIOService++]; <span class="hljs-comment">//取出service</span><br>    <span class="hljs-keyword">if</span> (_nextIOService == _ioServices.<span class="hljs-built_in">size</span>()) &#123;<br>        _nextIOService = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> service;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AsioIOServicePool::Stop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; work : _works) &#123;<br>        work.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// 想要Service停掉，要先work.reset();</span><br>        <span class="hljs-comment">// work.reset()是让unique指针置空并释放，那么work的析构函数就会被调用，work被析构，其管理的io_service在没有事件监听时就会被释放。</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : _threads) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="asio多线程IOThreadPool"><a href="#asio多线程IOThreadPool" class="headerlink" title="asio多线程IOThreadPool"></a>asio多线程IOThreadPool</h2><ol><li><code>一个IOServicePool开启n个线程和n个iocontext，每个线程内独立运行iocontext, 各个iocontext监听各自绑定的socket是否就绪，如果就绪就在各自线程里触发回调函数。</code></li><li>IOThreadPool：<code>初始化一个iocontext用来监听服务器的读写事件，包括新连接到来的监听也用这个iocontext。只是我们让iocontext.run在多个线程中调用</code>，这样回调函数就会被不同的线程触发，从这个角度看回调函数被并发调用了。</li><li>线程池统一管理一个io_context，每个线程调用一个io_context，会话session都注册到一个，哪个线程调用了io_context.run，哪个线程去就绪队列取出回调函数。</li><li>回调函数对同一个session来说就是不安全的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsioThreadPool</span> :<span class="hljs-keyword">public</span> Singleton&lt;AsioThreadPool&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;AsioThreadPool&gt;;<br>    ~<span class="hljs-built_in">AsioThreadPool</span>() &#123;&#125;<br>    AsioThreadPool&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> AsioThreadPool&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">AsioThreadPool</span>(<span class="hljs-type">const</span> AsioThreadPool&amp;) = <span class="hljs-keyword">delete</span>;<br>    boost::<span class="hljs-function">asio::io_context&amp; <span class="hljs-title">GetIOService</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">AsioThreadPool</span>(<span class="hljs-type">int</span> threadNum = std::thread::<span class="hljs-built_in">hardware_concurrency</span>());<br>    boost::asio::io_context _service;<br>    std::unique_ptr&lt;boost::asio::io_context::work&gt; _work; <span class="hljs-comment">//没有客人来，我也不会让饭店关门</span><br>    std::vector&lt;std::thread&gt; _threads;<br>&#125;;<br><br><span class="hljs-comment">// 初始化列表进行初始化</span><br>AsioThreadPool::<span class="hljs-built_in">AsioThreadPool</span>(<span class="hljs-type">int</span> threadNum) :_work(<span class="hljs-keyword">new</span> boost::asio::io_context::<span class="hljs-built_in">work</span>(_service)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threadNum; ++i) &#123;<br>        _threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>]() &#123;<br>            _service.<span class="hljs-built_in">run</span>();<br>            &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>线程池里每个线程都会运行_service.run函数</code>，这就是多线程调用一个io_context的逻辑。</li><li>因为回调函数是在不同的线程里调用的，所以会存在不同的线程调用同一个socket的回调函数的情况。</li><li><code>_service.run 内部在Linux环境下调用的是epoll_wait返回所有就绪的描述符列表</code>，<code>在windows上会循环调用GetQueuedCompletionStatus函数返回就绪的描述符</code>，二者原理类似，进而通过描述符找到对应的注册的回调函数，然后调用回调函数。</li></ul><h3 id="epoll-和-iocp的一些知识点"><a href="#epoll-和-iocp的一些知识点" class="headerlink" title="epoll 和 iocp的一些知识点"></a>epoll 和 iocp的一些知识点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">IOCP的使用主要分为以下几步：<br>1 创建完成端口(iocp)对象。<br>2 创建一个或多个工作线程，在完成端口上执行并处理投递到完成端口上的I/O请求。<br>3 Socket关联iocp对象，在Socket上投递网络事件。<br>4 工作线程调用GetQueuedCompletionStatus函数获取完成通知封包，取得事件信息并进行处理。<br><br>epoll_wait的工作方式：<br>1 调用epoll_creat在内核中创建一张epoll表。<br>2 开辟一片包含n个epoll_event大小的连续空间。<br>3 将要监听的socket注册到epoll表里。<br>4 调用epoll_wait，传入之前我们开辟的连续空间，epoll_wait返回就绪的epoll_event列表，<br>epoll会将就绪的socket信息写入我们之前开辟的连续空间。<br></code></pre></td></tr></table></figure><ul><li>使用这种方式，有可能会存在隐患，不同的线程有可能处理同一块Read回调处理函数，存在网络上的并行。<br><code>改进方法：再添加一个strand管理的队列，asio的strand是一个安全队列，里面进行独立的单线程访问。</code></li><li>回调处理放在_strand中进行执行。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span></span>&#123;<br>    ::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>        boost::asio::<span class="hljs-built_in">bind_executor</span>(_strand, std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">SharedSelf</span>())));<br>&#125;<br></code></pre></td></tr></table></figure></li><li>IOThreadPool相比于IOServicePool，速度慢一些。</li></ul><p>参考列表<br><a href="https://www.bilibili.com/video/BV1FV4y1U7oo/">https://www.bilibili.com/video/BV1FV4y1U7oo/</a><br><a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2Qld2hoFIu8ycYBJXQdxwyWEBfy">https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2Qld2hoFIu8ycYBJXQdxwyWEBfy</a></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ asio学习四</title>
    <link href="/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E5%9B%9B/"/>
    <url>/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="C-asio学习四"><a href="#C-asio学习四" class="headerlink" title="C++ asio学习四"></a>C++ asio学习四</h1><h2 id="大小端字节序"><a href="#大小端字节序" class="headerlink" title="大小端字节序"></a>大小端字节序</h2><ul><li><code>网络字节序为大端序</code>，计算机内部存储有可能是大端，有可能是小端。<br><img src="https://pic.imgdb.cn/item/66040ae09f345e8d039bc6ff.png" alt="在这里插入图片描述"></li><li>网络传输时，需要将本地数据转换为大端序，实现字节序的转换。</li></ul><p><code>判断是大端还是小端：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断当前系统的字节序是大端序还是小端序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_big_endian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">char</span>*)&amp;num == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 当前系统为小端序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 当前系统为大端序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>在 boost::asio 库中，可以使用<code>boost::asio::detail::socket_ops::host_to_network_long()</code>和 <code>boost::asio::detail::socket_ops::host_to_network_short()</code> 函数将主机字节序转换为网络字节序。</p></li><li><p>network_to_host_short从网络字节序转成本地字节序。</p></li><li><p>在服务器的发送数据时会构造消息节点，构造消息节点时，将发送长度由本地字节序转化为网络字节序.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span> * msg, <span class="hljs-type">short</span> max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(<span class="hljs-number">0</span>)&#123;<br>        _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len+<span class="hljs-number">1</span>]();<br>        <span class="hljs-comment">//转为网络字节序</span><br>        <span class="hljs-type">int</span> max_len_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(max_len);<br>        <span class="hljs-built_in">memcpy</span>(_data, &amp;max_len_host, HEAD_LENGTH);<br>        <span class="hljs-built_in">memcpy</span>(_data+ HEAD_LENGTH, msg, max_len);<br>        _data[_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="消息队列控制"><a href="#消息队列控制" class="headerlink" title="消息队列控制"></a>消息队列控制</h2><ul><li>发送的数据放到消息队列中，异步发送数据时，要用队列来保证发送的时序性，有的时候发送的频率过高会导致队列增大，所以要对队列的大小做限制，当队列大于指定数量的长度时，就丢弃要发送的数据包，以保证消息的快速收发。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SENDQUE 1024</span><br><span class="hljs-comment">// 实现发送接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-type">bool</span> pending = <span class="hljs-literal">false</span>; <span class="hljs-comment">// pending为true表示上一次数据没有发完。</span><br><span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">// 队列里有数据，就不发送了，让队列里面的回调函数发送就行了。</span><br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br>    <span class="hljs-keyword">if</span> (send_que_size&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite,<span class="hljs-keyword">this</span>,std::placeholders::_1,<span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><ol><li>protobuf是谷歌设计一种轻便高效的序列化数据结构的协议，独立于语言和平台。<strong>是一种二进制的格式，比使用 xml 、json进行数据交换快许多</strong>。</li><li><code>http信息交互中有的信息类是抽象数据构成的，而tcp是面向字节流的，需要将类结构序列化为字符串来进行传输。</code></li><li>下载protobuf的源码之后，用cmake构建C++代码，生成适用于各种构建系统的构建文件（如makefile，visual studio解决方案等）</li><li>使用 protobuf 能够多（数据结构支持复杂结构、语言支持程度覆盖主流编程语言）、快（编解码效率）、好（数据保存方式为二进制，保存更节省空间、读取转换时间）、省（数据保存大小）。</li></ol><h3 id="windows下编译protobuf"><a href="#windows下编译protobuf" class="headerlink" title="windows下编译protobuf"></a>windows下编译protobuf</h3><ol><li>下载Cmake桌面程序，<strong>点击source code选择protobuf源码路径下的cmake目录</strong>。</li><li>build binaries目录选择<strong>自己创建的visualstudio目录</strong>。</li><li>点击<strong>config，再点击generate</strong>就可以生成了。</li><li>就可以看到<strong>visualstudio目录内生成了.sln文件</strong>。</li><li>点击.sln文件打开项目<br><img src="https://pic.imgdb.cn/item/66040b019f345e8d039cda6c.png" alt="在这里插入图片描述"></li><li>单独选择libprotobuf编译。</li><li>编译时可以选择debug和release，建议每一个都编译一遍，这样就有debug和release两个版本的库了。</li><li>debug版本的库，编译之后，会在visualstudio目录下的Debug文件夹里。</li><li>生成了<strong>protobuf相关的lib库和dll库</strong>，一个是静态类型的，一个是动态类型的。</li><li>在该文件夹内创建一个<strong>bin文件夹</strong>(用来存储刚才protobuf生成的库)和<strong>include文件夹</strong>(用来存储protobuf的头文件)。有了库，需要给用户头文件，让用户去使用。</li><li>将<strong>libprotobufd.lib和libprotocd.lib， 以及protoc.exe拷贝到bin目录</strong>下，将<strong>protobuf文件夹下src文件夹里的google文件夹及其内容拷贝到protoc的include文件夹</strong>。</li><li>添加环境变量，将protoc命令配置到环境变量，在<strong>系统环境变量里添加一个环境变量PROTOBUF_HOME,设置它的值为D:\cppsoft\protoc\bin</strong>。这个环境变量的值要根据自己创建的bin目录去设置。</li><li>可以直接使用protoc.exe了。</li><li>在visual studio中使用protobuf，需要进行一下配置，和boost的配置是一样的</li><li>配置选择Debug，平台选择X64，选择VC++目录</li><li>在包含目录中添加 D:\cppsoft\protoc\include</li><li>在库目录中添加 D:\cppsoft\protoc\bin</li><li>在链接器里的输入选项中添加protobuf用到的lib库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">libprotobufd.lib<br>libprotocd.lib<br></code></pre></td></tr></table></figure><h3 id="Linux下编译protobuf"><a href="#Linux下编译protobuf" class="headerlink" title="Linux下编译protobuf"></a>Linux下编译protobuf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># clone code</span><br>https://github.com/protocolbuffers/protobuf/releases<br><br><span class="hljs-comment"># 解压缩</span><br>tar zxvf protobuf-cpp-3.21.12.tar.gz<br><br><span class="hljs-comment"># 进入到解压目录</span><br><span class="hljs-built_in">cd</span> protobuf-3.21.12/<br><br><span class="hljs-comment"># 构建并安装</span><br>./configure         <span class="hljs-comment"># 检查安装环境, 生成 makefile</span><br>make                <span class="hljs-comment"># 编译</span><br>sudo make install   <span class="hljs-comment"># 安装</span><br><br><span class="hljs-comment"># 测试</span><br>protoc --version<br><br><span class="hljs-comment"># 动态库位于/usr/local/lib目录，接下来需要需要将这目录添加到/etc/ld.so.conf这个配置文件</span><br>sudo vim /etc/ld.so.conf<br><span class="hljs-comment"># 打开文件后，把目录添加到第二行</span><br>/usr/local/lib<br><br><span class="hljs-comment"># 重新load配置文件</span><br>sudo ldconfig<br><br><span class="hljs-comment"># 测试</span><br>protoc --version<br>libprotoc 3.21.12<br></code></pre></td></tr></table></figure><h3 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h3><ol><li>protobuf可以序列化单一数据类型和复合数据类型。</li><li>创建一个新的文件, 文件名随意指定, 文件后缀为 .proto</li><li>根据protobuf的语法, 编辑.proto文件</li><li>使用 protoc 命令将 .proto 文件转化为相应的 C++ 文件</li><li>源文件: xxx.pb.cc –&gt; xxx对应的名字和 .proto文件名相同。</li><li>头文件: xxx.pb.h –&gt; xxx对应的名字和 .proto文件名相同。</li><li>需要将生成的c++文件添加到项目中, 通过文件中提供的类 API 实现数据的序列化&#x2F;反序列化</li></ol><p><code>生成pb文件</code><br>8. <strong>使用protobuf的序列化功能，需要生成pb文件，pb文件包含了我们要序列化的类信息</strong>。我们先创建一个msg.proto，该文件用来定义我们要发送的类信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment"># 指定Protobuf的版本号</span><br>message Book<br>&#123;<br>   string name = 1; <span class="hljs-comment"># 数字标识符，用于标识该字段在二进制流中的位置。</span><br>   int32 pages = 2;<br>   <span class="hljs-built_in">float</span> price = 3;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>用protoc.exe 基于msg.proto生成我们要用的C++类</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">protoc --cpp_out=. ./msg.proto<br></code></pre></td></tr></table></figure><p><strong>目录生成了msg.pb.h和msg.pb.cc两个文件，这两个文件就是我们要用到的头文件和cpp文件</strong>。</p><p>将这两个文件添加到项目里，然后在主函数中包含msg.pb.h，做如下测试：<code>将book对象先序列化为字符串，再将字符串反序列化为book2对象。代码中调用的函数都是自动生成的</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;msg.pb.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Book book;<br>    book.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;CPP programing&quot;</span>); <br>    book.<span class="hljs-built_in">set_pages</span>(<span class="hljs-number">100</span>); <br>    book.<span class="hljs-built_in">set_price</span>(<span class="hljs-number">200</span>); <br>    std::string bookstr;<br>    book.<span class="hljs-built_in">SerializeToString</span>(&amp;bookstr); <span class="hljs-comment">//将book对象先序列化为字符串</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;serialize str is &quot;</span> &lt;&lt; bookstr &lt;&lt; std::endl;<br>    Book book2;<br>    book2.<span class="hljs-built_in">ParseFromString</span>(bookstr); <span class="hljs-comment">// 字符串反序列化为book2对象。</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;book2 name is &quot;</span> &lt;&lt; book2.<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; price is &quot;</span> <br>        &lt;&lt; book2.<span class="hljs-built_in">price</span>() &lt;&lt; <span class="hljs-string">&quot; pages is &quot;</span> &lt;&lt; book2.<span class="hljs-built_in">pages</span>() &lt;&lt; std::endl;<br>    <span class="hljs-built_in">getchar</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>网络消息服务中使用protobuf</code></p><ol><li>先为服务器定义一个用来通信的proto</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>message MsgData<br>&#123;<br>   int32  id = <span class="hljs-number">1</span>;<br>   string data = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>用proto生成对应的pb.h和pb.cc文件，将proto,pb.cc,pb.h三个文件复制服务器项目里并且配置。</li><li>修改服务器接收数据和发送数据的逻辑。</li><li><strong>当服务器收到数据后，完成切包处理后，将信息反序列化为具体要使用的结构,打印相关的信息，然后再发送给客户端</strong>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MsgData msgdata;<br>   std::string receive_data;<br>   msgdata.<span class="hljs-built_in">ParseFromString</span>(std::<span class="hljs-built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len));<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;recevie msg id  is &quot;</span> &lt;&lt; msgdata.<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; msg data is &quot;</span> &lt;&lt; msgdata.<span class="hljs-built_in">data</span>() &lt;&lt; endl;<br>   std::string return_str = <span class="hljs-string">&quot;server has received msg, msg data is &quot;</span> + msgdata.<span class="hljs-built_in">data</span>();<br>   MsgData msgreturn;<br>   msgreturn.<span class="hljs-built_in">set_id</span>(msgdata.<span class="hljs-built_in">id</span>());<br>   msgreturn.<span class="hljs-built_in">set_data</span>(return_str);<br>   msgreturn.<span class="hljs-built_in">SerializeToString</span>(&amp;return_str);<br>   <span class="hljs-built_in">Send</span>(return_str);<br></code></pre></td></tr></table></figure><ol start="6"><li>客户端在发送的时候也利用<strong>protobuf进行消息的序列化</strong>，然后发给服务器。</li></ol><h2 id="JSONCPP"><a href="#JSONCPP" class="headerlink" title="JSONCPP"></a>JSONCPP</h2><p>JSONCPP源码链接：<a href="https://github.com/open-source-parsers/jsoncpp">https://github.com/open-source-parsers/jsoncpp</a></p><ol><li>JSOCPP源码下载以后，首先复制一份include文件夹下的json文件夹，头文件留着后续备用。<br><img src="https://pic.imgdb.cn/item/66040b2b9f345e8d039e4bd4.png" alt="在这里插入图片描述"></li><li>使用Cmake生成项目。在IDE中编译jsoncpp_lib，可以在项目的lib&#x2F;Debug文件夹下找到jsoncpp.lib，在bin&#x2F;Debug&#x2F;文件夹下找到jsoncpp.dll。将头文件和动态链接库文件，放入项目中即可使用。<br><img src="https://pic.imgdb.cn/item/66040ba49f345e8d03a26b7d.png" alt="在这里插入图片描述"><br><img src="https://pic.imgdb.cn/item/66040bb99f345e8d03a331f6.png" alt="在这里插入图片描述"><br>jsoncpp库中的类被定义到了一个Json命名空间中，使用时最好先声明这个命名空间。</li></ol><p>配置Jsoncpp：</p><ul><li><p>项目属性中，VC++包含目录设置为 D:\JSONCPP\include</p></li><li><p>库目录选择为 VC++库目录设置为 D:\JSONCPP\lib</p></li><li><p>使用jsoncpp库解析json格式的数据，三个类：</p></li><li><p>Value 类：将json支持的数据类型进行了包装，最终得到一个Value类型。</p></li><li><p>FastWriter类：将Value对象中的数据序列化为字符串。</p></li><li><p>Reader类：反序列化，将json字符串解析成Value类型。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/json.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/value.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/reader.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Json::Value root;<br>    root[<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-number">1001</span>;<br>    root[<span class="hljs-string">&quot;data&quot;</span>] = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    std::string request = root.<span class="hljs-built_in">toStyledString</span>(); <span class="hljs-comment">//序列化为字符串</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;request is &quot;</span> &lt;&lt; request &lt;&lt; std::endl;<br>    Json::Value root2;<br>    Json::Reader reader;<br>    reader.<span class="hljs-built_in">parse</span>(request, root2); <span class="hljs-comment">// 反序列化为value类型。</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;msg id is &quot;</span> &lt;&lt; root2[<span class="hljs-string">&quot;id&quot;</span>] &lt;&lt; <span class="hljs-string">&quot; msg is &quot;</span> &lt;&lt; root2[<span class="hljs-string">&quot;data&quot;</span>] &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>在网络通信中的JSONCPP</code></p><ul><li>客户端发送数据时，将发送的数据进行序列化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Json::Value root;<br>   root[<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-number">1001</span>;<br>   root[<span class="hljs-string">&quot;data&quot;</span>] = <span class="hljs-string">&quot;hello world&quot;</span>;<br>   std::string request = root.<span class="hljs-built_in">toStyledString</span>(); <span class="hljs-comment">// 序列化为字符串</span><br>   <span class="hljs-type">size_t</span> request_length = request.<span class="hljs-built_in">length</span>();<br>   <span class="hljs-type">char</span> send_data[MAX_LENGTH] = &#123; <span class="hljs-number">0</span> &#125;;<br>   <span class="hljs-comment">//转为网络字节序</span><br>   <span class="hljs-type">int</span> request_host_length = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(request_length);<br>   <span class="hljs-built_in">memcpy</span>(send_data, &amp;request_host_length, <span class="hljs-number">2</span>); <span class="hljs-comment">//先拷贝2字节的数据长度信息</span><br>   <span class="hljs-built_in">memcpy</span>(send_data + <span class="hljs-number">2</span>, request.<span class="hljs-built_in">c_str</span>(), request_length); <span class="hljs-comment">// 再拷贝数据本身</span><br>   boost::asio::<span class="hljs-built_in">write</span>(sock, boost::asio::<span class="hljs-built_in">buffer</span>(send_data, request_length + <span class="hljs-number">2</span>)); <span class="hljs-comment">// 封装到buffer中进行发送</span><br></code></pre></td></tr></table></figure><ul><li>服务器进行反序列化，注意要转换成本地字节序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Json::Reader reader;<br>   Json::Value root;<br>   reader.<span class="hljs-built_in">parse</span>(std::<span class="hljs-built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>() &lt;&lt; <span class="hljs-string">&quot; msg data is &quot;</span><br>   &lt;&lt; root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>参考列表：<br><a href="https://subingwen.cn/cpp/protobuf/?highlight=proto">https://subingwen.cn/cpp/protobuf/?highlight=proto</a></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ asio学习三</title>
    <link href="/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E4%B8%89/"/>
    <url>/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C-asio学习三"><a href="#C-asio学习三" class="headerlink" title="C++ asio学习三"></a>C++ asio学习三</h1><h2 id="用智能指针延长session的生命周期"><a href="#用智能指针延长session的生命周期" class="headerlink" title="用智能指针延长session的生命周期"></a>用智能指针延长session的生命周期</h2><p>问题：</p><blockquote><ul><li><code>客户端断开后：会触发服务器对应session的写或读事件，由于是异步编程，需要在回调中对读写事件进行处理。</code></li><li><code>客户端断开， 则应该析构掉该session。但是此时该session在asio底层回调队列中可能还有很多读写函数对象在排队等着执行 。 如果在某个读写回调对象把这个session析构掉了，那之后执行的读写回调函数可能会再次析构这个session。 </code></li><li><code>所以我们需要保证， 在该session对应asio底层回调队列中，还存在将要执行的读写回调函数时，该session不被析构。通过智能指针来实现伪闭包，延长session的生命周期。</code></li></ul></blockquote><ul><li><p>智能指针传给函数对象，函数对象不释放，智能指针也就不会被释放掉。</p></li><li><p>把智能指针传递给session用的回调函数，函数内部再使用智能指针，这个时候智能指针就不被释放。</p></li><li><p>假如包含智能指针的函数没有调用怎么办？用lambda表达式和bind强制将智能指针中的shared_ptr加1。</p></li><li><p>构造一个伪闭包：</p><ul><li>利用智能指针被复制或使用引用计数加一的原理保证内存不被回收</li><li><code>bind操作可以将值绑定在一个函数对象上生成新的函数对象</code>，如果将智能指针作为参数绑定给函数对象，<code>那么智能指针就以值的方式被新函数对象使用，那么智能指针的生命周期将和新生成的函数对象一致</code>，从而达到延长生命的效果。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 包含智能指针的Server类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearSession</span><span class="hljs-params">(std::string uuid)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleAccept</span><span class="hljs-params">(std::shared_ptr&lt;CSession&gt;, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartAccept</span><span class="hljs-params">()</span></span>;<br>    boost::asio::io_context&amp; _io_context;<span class="hljs-comment">// 上下文</span><br>    <span class="hljs-type">short</span> _port;<span class="hljs-comment">// 端口</span><br>    tcp::acceptor _acceptor;<br>    <span class="hljs-comment">// 通过智能指针方式管理Session类，将acceptor接收的连接保存在Session类型的智能指针里。</span><br>    <span class="hljs-comment">// 在Server类中添加成员变量，该变量为一个map类型，key为Session的uid，value为该Session的智能指针。</span><br>    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;<br>    <span class="hljs-comment">// 通过Server中的_sessions这个map管理链接，可以增加Session智能指针的引用计数，只有当Session从这个map中移除后，Session才会被释放。</span><br>    <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> :<span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 上下文初始化CSession，socket绑定上下文</span><br>    <span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _socket; &#125;<br>    <span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _uuid; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123; MAX_LENGTH = <span class="hljs-number">1024</span> &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;<br>    tcp::socket _socket;<br>    std::string _uuid;<br>    <span class="hljs-type">char</span> _data[MAX_LENGTH];<br>    CServer* _server;<br>    std::queue&lt;std::shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br>    std::mutex _send_lock;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CServer类</span><br>CServer::<span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port): _io_context(io_context), _acceptor(io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port)) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; endl;<br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::StartAccept</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// new_session虽然是一个局部变量，但是通过智能指针和bind操作，将new_session作为数值传递给bind函数。</span><br><span class="hljs-comment">// bind函数返回的函数对象内部引用了该new_session，所以引用计数加1，这样保证了new_session不会被释放。</span><br>std::shared_ptr&lt;CSession&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// placeholders::_1 占位符的作用是给HandleAccept函数一个错误码关键字。</span><br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">GetSocket</span>(), std::<span class="hljs-built_in">bind</span>(&amp;CServer::HandleAccept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::HandleAccept</span><span class="hljs-params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>new_session-&gt;<span class="hljs-built_in">Start</span>();<br><span class="hljs-comment">// 在接收连接的逻辑里将Session放入map</span><br>_sessions.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_session-&gt;<span class="hljs-built_in">GetUuid</span>(), new_session));<span class="hljs-comment">// make_pair是圆括号，不是尖括号</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">StartAccept</span>();<span class="hljs-comment">// 继续接收连接就是了</span><br>&#125;<br><br><span class="hljs-comment">// 将session从map中移除，当其引用计数为0时，自动释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::ClearSession</span><span class="hljs-params">(std::string uuid)</span> </span>&#123;<br>_sessions.<span class="hljs-built_in">erase</span>(uuid);<br>&#125;<br><br><br><span class="hljs-comment">// CSession类</span><br><span class="hljs-comment">// 构造函数</span><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server) :_socket(ioc), _server(server) &#123;<br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()(); <span class="hljs-comment">//boost提供的生成唯一id的函数</span><br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<span class="hljs-comment">// 将随机数转成string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><span class="hljs-comment">// 数据读到_data中，触发HandleRead回调，注意不能再定义一个智能指针。</span><br><span class="hljs-comment">// shared_from_this()函数可以还用当前的智能指针。</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead,<span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;read data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br><span class="hljs-comment">//发送数据</span><br><span class="hljs-built_in">Send</span>(_data, bytes_transferred);<br><span class="hljs-comment">// 继续read，重复调用HandleRead</span><br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, _self_shared));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">// 杀死session</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-comment">// 写数据的时候上锁</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-comment">// 调用HandleWrite，说明肯定已经发送完一个数据，这个时候弹出一下，后面只要发送队列不为空，就一直发送。</span><br>_send_que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_msg, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, _self_shared));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">// 杀死session</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实现发送接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-type">bool</span> pending = <span class="hljs-literal">false</span>; <span class="hljs-comment">// pending为true表示上一次数据没有发完。</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-keyword">if</span> (_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>pending = <span class="hljs-literal">true</span>;<br>&#125;<br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length)); <span class="hljs-comment">// 队列里有数据，就不发送了，让队列里面的回调函数发送就行了。</span><br><span class="hljs-keyword">if</span> (pending) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite,<span class="hljs-keyword">this</span>,std::placeholders::_1,<span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="处理粘包问题"><a href="#处理粘包问题" class="headerlink" title="处理粘包问题"></a>处理粘包问题</h2><p>粘包问题：<code>当客户端发送多个数据包给服务器时，服务器底层的tcp接收缓冲区收到的数据为粘连在一起的，是服务器的问题，不是客户端的问题。</code><br>客户端发送： hello world！   hello world！<br>服务器接收：hello world! hello     world!<br>客户端给服务器发送了两个hello world! 服务其TCP缓冲区接收了两次，但是第一次接收的数据粘包了。</p><p><code>粘包原因：TCP发送数据的时候，数据逻辑性出了问题。</code></p><ul><li>TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位。</li><li>客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据。比如发送缓冲区总大小为10字节，当前有5字节未发送完，那么此时只有5个字节的空闲时间。</li><li>此时调用接口发送hello world!, 就只能发送hello给服务器，那么服务器这次接收到的数据很可能就是连着其他数据的hello，下次才能收到world！。</li></ul><p>还有其他产生粘包问题的原因： </p><ol><li>客户端的发送频率远高于服务器的接收频率，服务器接收不过来，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连。</li><li>tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送。</li></ol><ul><li><code>处理粘包的方法</code>：<strong>主要采用应用层定义收发包格式的方式，这个过程俗称切包处理。用消息id+消息长度+消息内容的tlv协议去切割数据包。</strong></li></ul><p>在代码中对粘包进行处理：</p><ul><li>定义新的数据结构体，数据包含两部分：消息长度+消息内容，用额外的2字节去存储当前消息的长度。</li><li>接收消息数据的CSession类也需要更新。</li><li>数据初始化的时候，就要初始化头部信息。</li></ul><p>完善加上粘包处理后的逻辑：</p><ul><li>头部未解析：<ul><li>收到的数据不是满足头部的大小:未处理的数据加上头部当前缓存的数据，如果小于2字节，就说明头部数据没有接收完。</li><li>收到的数据比头部多：头部的信息已经接收完，取出头部信息。定义数据节点，取出数据信息。<ul><li>若数据节点的长度&lt; 头部信息长度：数据还没收完。将数据放到接收节点中，更新信息。</li><li>若数据节点的长度大于等于头部信息长度：取出首包全部数据，头部节点清楚一下，轮询切包。</li></ul></li></ul></li><li>头部已解析：已经处理完头部，消息体没有接收完。<ul><li>消息体还没有接收全：当前数据拷贝到消息节点里，继续监听对方发送。</li><li>消息体长度够了，拷贝信息到消息节点，更新变量，把剩下的数据轮询切包。<br><img src="https://pic.imgdb.cn/item/66040abe9f345e8d039aacc4.png" alt="在这里插入图片描述"></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><br><span class="hljs-comment">/** copy_len 已经移动的字符数：</span><br><span class="hljs-comment">调用一次HandleRead：会返回总共收到的字节数，会从零开始处理到bytes_transferred这么大，中间会有一些其他的处理，</span><br><span class="hljs-comment">copy_len表示处理到哪里了。</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> copy_len = <span class="hljs-number">0</span>; <span class="hljs-comment">//copy_len表示处理到哪里了</span><br><span class="hljs-keyword">while</span> (bytes_transferred &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (!_b_head_parse) &#123; <span class="hljs-comment">// 最开始的时候头部肯定还没有被解析</span><br><span class="hljs-comment">// 先判断收到的数据是不是满足头部的大小:未处理的数据加上头部当前缓存的数据，如果小于2字节，就说明头部数据没有接收完</span><br><span class="hljs-keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;<br><span class="hljs-comment">// 将数据全部拷贝到头部节点</span><br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_head_node-&gt;_cur_len += bytes_transferred;<span class="hljs-comment">//已经拷贝了，头部节点已经处理的长度就要更新</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<span class="hljs-comment">//清空</span><br><span class="hljs-comment">// 继续去监听读事件</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 收到的数据比头部多</span><br><span class="hljs-comment">// 头部剩余未复制的长度</span><br><span class="hljs-type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;<br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);<br><span class="hljs-comment">// 更新已处理的data长度copy_len 和 剩余未处理的长度bytes_transferred</span><br>copy_len += head_remain;<br>bytes_transferred -= head_remain;<br><span class="hljs-comment">// 获取头部数据 打印数据长度</span><br><span class="hljs-type">short</span> data_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br>cout &lt;&lt; <span class="hljs-string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br><span class="hljs-comment">//头部长度非法 断开连接</span><br><span class="hljs-keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>_recv_msg_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(data_len); <span class="hljs-comment">//数据节点</span><br><span class="hljs-comment">// 消息的长度小于头部规定的长度，说明数据没有收全，则先将部分消息放在接收节点里</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; data_len) &#123;<br><span class="hljs-comment">// 拷贝到节点里</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><span class="hljs-comment">// 继续去接收读事件把</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-comment">//头部处理完成</span><br>_b_head_parse = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 消息的长度大于等于头部规定的长度，说明这一节数据已经收齐了，可以读取接收了，需要进行切包。</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);<br>_recv_msg_node-&gt;_cur_len += data_len;<br>copy_len += data_len;<br>bytes_transferred -= data_len;<br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//第一个消息包的数据取完了</span><br>cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br><span class="hljs-comment">//此处可以调用Send发送测试</span><br><span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br><span class="hljs-comment">//继续轮询剩余未处理数据</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//已经处理完头部，处理上次未接受完的消息数据</span><br><span class="hljs-comment">//接收的数据仍不足剩余未处理的</span><br><span class="hljs-type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;<br><span class="hljs-comment">// 这次接收到的消息体，还不满足整合成一个数据结构体。</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 接收的消息已经满足形成一个数据包结构体了，</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);<br>_recv_msg_node-&gt;_cur_len += remain_msg;<br>bytes_transferred -= remain_msg;<br>copy_len += remain_msg;<br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br><span class="hljs-comment">//此处可以调用Send发送测试</span><br><span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><span class="hljs-comment">//继续轮询剩余未处理数据</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">// 杀死session</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于客户端：发送和接收数据的时候，也要先发送两个字节的数据长度，再发送数据消息的结构。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-comment">// 创建上下文服务</span><br>boost::asio::io_context   ioc;<br><span class="hljs-comment">//构造endpoint</span><br><span class="hljs-function">tcp::endpoint  <span class="hljs-title">remote_ep</span><span class="hljs-params">(asio::ip::address::from_string(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">10086</span>)</span></span>;<br><span class="hljs-function">tcp::socket  <span class="hljs-title">sock</span><span class="hljs-params">(ioc)</span></span>;<br>boost::system::error_code   error = boost::asio::error::host_not_found; ;<br>sock.<span class="hljs-built_in">connect</span>(remote_ep, error);<br><span class="hljs-keyword">if</span> (error) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">message</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Enter message: &quot;</span>;<br><span class="hljs-type">char</span> request[MAX_LENGTH];<br>std::cin.<span class="hljs-built_in">getline</span>(request, MAX_LENGTH); <span class="hljs-comment">//输入数据</span><br><span class="hljs-type">size_t</span> request_length = <span class="hljs-built_in">strlen</span>(request);<br><br><span class="hljs-type">char</span> send_data[MAX_LENGTH] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">memcpy</span>(send_data, &amp;request_length, <span class="hljs-number">2</span>); <span class="hljs-comment">// 先首部2字节，构造数据长度</span><br><span class="hljs-built_in">memcpy</span>(send_data + <span class="hljs-number">2</span>, request, request_length); <span class="hljs-comment">// 再构造数据体</span><br>boost::asio::<span class="hljs-built_in">write</span>(sock, boost::asio::<span class="hljs-built_in">buffer</span>(send_data, request_length + <span class="hljs-number">2</span>));<br><br><span class="hljs-type">char</span> reply_head[HEAD_LENGTH];<br><span class="hljs-type">size_t</span> reply_length = boost::asio::<span class="hljs-built_in">read</span>(sock, boost::asio::<span class="hljs-built_in">buffer</span>(reply_head, HEAD_LENGTH)); <span class="hljs-comment">// 先接收头部，获取信息长度</span><br><span class="hljs-type">short</span> msglen = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;msglen, reply_head, HEAD_LENGTH);<br><span class="hljs-type">char</span> msg[MAX_LENGTH] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">size_t</span>  msg_length = boost::asio::<span class="hljs-built_in">read</span>(sock, boost::asio::<span class="hljs-built_in">buffer</span>(msg, msglen)); <span class="hljs-comment">// 再接收尾部</span><br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Reply is: &quot;</span>;<br>std::cout.<span class="hljs-built_in">write</span>(msg, msglen) &lt;&lt; endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Reply len is &quot;</span> &lt;&lt; msglen;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e)<br>&#123;<br>std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="asio简易处理粘包问题的方法"><a href="#asio简易处理粘包问题的方法" class="headerlink" title="asio简易处理粘包问题的方法"></a>asio简易处理粘包问题的方法</h2><ol><li>上面是通过<code>async_read_some函数监听读事件，绑定回调函数HandleRead。</code></li><li>async_read_some 这个函数的特点是只要对端发数据，服务器接收到数据，即使没有收全对端发送的数据也会触发HandleRead函数。</li><li>所以HandleRead函数的处理方式很复杂</li><li><code>简单的方式可以用async_read函数，读取固定字节数。只有完全读完才会触发回调函数</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 读取指定HEAD_LENGTH大小的字节数才触发HandleReadHead函数</span><br>boost::asio::<span class="hljs-built_in">async_read</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="hljs-keyword">this</span>, <br>        std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">SharedSelf</span>()));<br></code></pre></td></tr></table></figure><ol start="5"><li>这样可以直接在HandleReadHead函数内处理头部信息：<ul><li>解析头部，获取字符串长度，如果长度大于最大长度，数据非法</li><li>字符串长度正常的话，调用HandleReadMsg函数，解析消息体。</li><li>打印消息体，继续接收头部消息。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleReadMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred,</span></span><br><span class="hljs-params"><span class="hljs-function">    std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-built_in">PrintRecvData</span>(_data, bytes_transferred);<br>        std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">2000</span>)</span></span>;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>        _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br>        <span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br>        <span class="hljs-comment">//再次接收头部数据</span><br>        _recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br>        boost::asio::<span class="hljs-built_in">async_read</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH),<br>            std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2,<br>                <span class="hljs-built_in">SharedSelf</span>()));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;handle read msg failed,  error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>        <span class="hljs-built_in">Close</span>();<br>        _server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>参考列表<br><a href="https://www.bilibili.com/video/BV1ys4y1D7Mu">https://www.bilibili.com/video/BV1ys4y1D7Mu</a></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ asio学习二</title>
    <link href="/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <url>/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="C-asio学习二"><a href="#C-asio学习二" class="headerlink" title="C++ asio学习二"></a>C++ asio学习二</h1><h2 id="asio异步写操作"><a href="#asio异步写操作" class="headerlink" title="asio异步写操作"></a>asio异步写操作</h2><ul><li>async_write_some是异步写的函数：传入buffer和回调函数以及参数以后，发送后会调用回调函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br><span class="hljs-comment">// make_shared 延长_send_node 的生命周期。</span><br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-comment">//async_write_some的回调函数要求是两个参数的：发送多少，以及可能返回的错误码，都作为参数传递给回调函数。</span><br>    <span class="hljs-comment">/*但是自己定义的函数参数为3个，通过bind将三个参数转换为两个参数的普通函数。*/</span><br>    <br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, <br>        _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>回调函数需要判断是否所有数据都发送完成了，如果没有，继续调用回调函数进行发送。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, </span></span><br><span class="hljs-params"><span class="hljs-function">   std::<span class="hljs-type">size_t</span> bytes_transferred,</span></span><br><span class="hljs-params"><span class="hljs-function">   std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len &lt; msg_node-&gt;_total_len) &#123;<br>        _send_node-&gt;_cur_len += bytes_transferred;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg+_send_node-&gt;_cur_len,<br>            _send_node-&gt;_total_len-_send_node-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>上面的代码中存在的问题：异步发送的过程是无序的，用户想发送数据的时候就调用WriteToSocketErr,或者循环调用WriteToSocketErr，很可能在一次没发送完数据还未调用回调函数时再次调用WriteToSocketErr。那么有可能出现发送数据的顺序和想要的顺序不同。</code></li><li>为了确保发送数据的顺序正确性，在应用层使用一个队列，保证发送顺序。并用一个标志位用来判断当前是否还有数据正在发送过程中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 函数参数和上面的参数并无差别</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue; <span class="hljs-comment">// 发送数据顺序队列</span><br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    <span class="hljs-type">bool</span> _send_pending;<span class="hljs-comment">// 判断当前是否有数据正在发送,为true表示一个节点还未发送完。</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>发送函数：发送的时候先把数据插到队列中，回调后，将正在发送标志位置为true。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br><span class="hljs-comment">// 将要发送的数据插入队列</span><br>_send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">if</span> (_send_pending) &#123; <span class="hljs-comment">//还有数据在发送的话，就先return</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br><span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(buf), <br>std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>_send_pending = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 调用一次async_write_some，肯定会触发WriteCallBack，这个时候将标志位置为true</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>回调函数：回调函数在执行时，会首先判断队首元素是否全部发送出去了，如果没有就继续发送队首元素。队首元素发送完毕后，继续取出队列中的元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt;)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//出错了</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 取出队首元素</span><br><span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>send_data-&gt;_cur_len += bytes_transferred;<br><span class="hljs-comment">//数据未发送完， 则继续发送</span><br><span class="hljs-keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;<br><span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2)<br>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>_send_queue.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>_send_pending = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 队列不为空，继续发送。</span><br><span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2)<br>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>async_write_some函数不能保证每次回调函数触发时发送的长度为要总长度，每次都要在回调函数判断发送数据是否完成，asio提供了一个更简单的发送函数async_send，这个函数在发送的长度未达到我们要求的长度时就不会触发回调，所以触发回调函数时要么时发送出错了要么是发送完成了,其内部的实现原理就是帮我们不断的调用async_write_some直到完成发送，所以async_send不能和async_write_some混合使用。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br><span class="hljs-comment">// 将要发送的数据插入队列</span><br>_send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">if</span> (_send_pending) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 异步发送数据，数据不会一次发送完，但是只会触发一次回调</span><br><span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>_send_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span><br>&lt;&lt; ec.<span class="hljs-built_in">value</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//如果发送完，则pop出队首元素</span><br>_send_queue.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br><span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>_send_pending = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br><span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack,<br><span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="asio异步读操作"><a href="#asio异步读操作" class="headerlink" title="asio异步读操作"></a>asio异步读操作</h2><ul><li>异步读操作和异步的写操作类似同样有<code>async_read_some</code>和<code>async_receive</code>函数，前者触发的回调函数获取的读数据的长度可能会小于要求读取的总长度，后者触发的回调函数读取的数据长度等于读取的总长度。</li><li>同样的<code>async_read_some</code>和<code>async_receive</code>不能混用，因为async_receive的底层就是循环调用async_read_some。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (_recv_pending) <span class="hljs-keyword">return</span>;<br>_recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br><span class="hljs-comment">// 一块一块接收</span><br>_socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2));<br>_recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>_recv_node-&gt;_cur_len += bytes_transferred;<br><span class="hljs-comment">// 如果没有接受完，继续接收</span><br><span class="hljs-keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;<br>_socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg + _recv_node-&gt;_cur_len,<br>_recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>_recv_pending = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//指针置空</span><br>_recv_node = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>async_receive：接收完数据后才会调用一次回调。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (_recv_pending) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>_recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>_socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2));<br>_recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span><br>&lt;&lt; ec.<span class="hljs-built_in">value</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>_recv_node-&gt;_cur_len += bytes_transferred;<br><span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br><span class="hljs-comment">//如果读完了则将标记置为false</span><br>_recv_pending = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//指针置空</span><br>_recv_node = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="asio-异步echo服务端"><a href="#asio-异步echo服务端" class="headerlink" title="asio 异步echo服务端"></a>asio 异步echo服务端</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;<br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><br><span class="hljs-comment">// Session类主要是处理客户端消息收发的会话类，简单起见，不考虑粘包问题，也不考虑支持手动调用发送的接口，只以应答的方式发送和接收固定长度(1024字节长度)的数据。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 上下文初始化Session，socket绑定上下文</span><br>    <span class="hljs-built_in">Session</span>(boost::asio::io_context&amp; ioc) :_socket(ioc) &#123;<br>    &#125;<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">Socket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _socket;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 在start中监听客户端的读写</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// handle_read和handle_write分别为服务器的读回调函数和写回调函数。</span><br>    <span class="hljs-comment">// 当服务器读数据时，会调用handle_read，在handle_read过程中，要把数据回传给客户端，要写时，会调用handle_write。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br><br>    tcp::socket _socket; <span class="hljs-comment">//_socket为单独处理客户端读写的socket。</span><br>    <span class="hljs-keyword">enum</span> &#123; max_length = <span class="hljs-number">1024</span> &#125;;<br>    <span class="hljs-type">char</span> _data[max_length]; <span class="hljs-comment">//_data用来接收客户端传递的数据</span><br><br>&#125;;<br><br><span class="hljs-comment">//最大报文接收大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> RECVSIZE = <span class="hljs-number">1024</span>;<br><br><br><span class="hljs-comment">// Server类是为服务器接收连接的管理类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_accept</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//启动连接描述符，初始化一个acceptor,将要接收连接的acceptor绑定到服务上</span><br>    <span class="hljs-comment">// 内部就是将accpeptor对应的socket描述符绑定到epoll或iocp模型上，实现事件驱动。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>; <span class="hljs-comment">// 有连接过来的时候，触发回调函数，回调session的数据。</span><br>    boost::asio::io_context&amp; _ioc;<span class="hljs-comment">// 上下文，不允许被复制被构造。</span><br>    tcp::acceptor _acceptor;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::Start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br><span class="hljs-comment">// async_read_some 在boost asio底层用的是epoll，把_socket的读事件添加到epoll表里。</span><br><span class="hljs-comment">// 当_socket有读事件就绪的时候，就会触发handle_read，读：对端发送数据，_socket底层的读tcp缓冲区由空变成有数据。</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(<br>boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2)<br>);<br><br>&#125;<br><br><span class="hljs-comment">// 读的回调函数：客户端发送数据过来，就会调用这个函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl; <span class="hljs-comment">// 收到数据</span><br><span class="hljs-comment">// 将收到的数据发送回客户端，就行了。</span><br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transfered),<br>std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1)); <span class="hljs-comment">// 当发送完成后触发handle_write回调函数。</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;read error&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 写回调函数，写回调之后，就要开始读了。</span><br><span class="hljs-comment">// 触发写回调，是因为tcp有空闲空间，能够把用户态的数据拷贝到tcp缓冲区。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br><span class="hljs-comment">// 继续读去吧。</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length), std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read,<br><span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;write error&quot;</span>&lt;&lt;error.<span class="hljs-built_in">value</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数:_ioc是引用变量，要用初始化列表的方式进行赋值,_acceptor专门捕获连接</span><br>Server::<span class="hljs-built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port):_ioc(ioc),_acceptor(ioc,tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(),port)) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; endl;<br><span class="hljs-built_in">start_accept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>Session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Session</span>(_ioc); <span class="hljs-comment">// 定义新的session</span><br><span class="hljs-comment">// 新的连接到来以后，调用handle_accept</span><br><span class="hljs-comment">// placeholders::_1 占位符，是asio api要求的错误码。</span><br><span class="hljs-comment">// asio就会通过placeholders::_1 这个占位符，把错误码发送给handle_accept函数。</span><br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),std::<span class="hljs-built_in">bind</span>(&amp;Server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>new_session-&gt;<span class="hljs-built_in">Start</span>();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">delete</span> new_session;<br>&#125;<br><span class="hljs-built_in">start_accept</span>();<span class="hljs-comment">//再次调用start_accept(),继续接收，不能接收完新的连接之后，就什么都不干了。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>客户端不用写成异步的，因为客户端并不是以并发为主。</code></p><h3 id="asio异步服务器中存在的隐患"><a href="#asio异步服务器中存在的隐患" class="headerlink" title="asio异步服务器中存在的隐患"></a>asio异步服务器中存在的隐患</h3><ul><li>当<code>服务器即将发送数据前(调用async_write前)，此刻客户端中断</code>，</li><li>服务器此时调用async_write会触发发送回调函数，<code>判断ec为非0进而执行delete this逻辑回收session</code>。</li><li>但要注意的是<code>客户端关闭后，在tcp层面会触发读就绪事件，服务器会触发读事件回调函数。</code>在读事件回调函数中判断错误码ec为非0，进而再次执行delete操作，<code>从而造成二次析构，这是极度危险的。</code></li><li>参考列表<br><a href="https://www.bilibili.com/video/BV15P411S7fp/?p=7&spm_id_from=pageDriver">https://www.bilibili.com/video/BV15P411S7fp/?p=7&amp;spm_id_from=pageDriver</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ asio学习一</title>
    <link href="/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <url>/2024/03/26/C++%20asio%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="C-asio学习一"><a href="#C-asio学习一" class="headerlink" title="C++ asio学习一"></a>C++ asio学习一</h1><h2 id="TCP通信基本流程"><a href="#TCP通信基本流程" class="headerlink" title="TCP通信基本流程"></a>TCP通信基本流程</h2><p><img src="https://pic.imgdb.cn/item/66040c0b9f345e8d03a6401e.png" alt="在这里插入图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单线程流程中，服务器创建用于监听的套接字，绑定本地的ip和端口，listen函数去监听绑定的端口。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有客户端进行连接，服务器端就可以和发起连接的客户端建立连接，连接建立成功会生成一个用于通信的套接字。<strong>用于监听的套接字和用于通信的套接字是不一样的</strong>。监听的套接字用于建立连接，通信的套接字用于数据交互。用于数据交互的read和write都是阻塞函数，在单线程下面，一个服务器想和多客户端进行通信，肯定是做不到的，因为accept，read，write都是阻塞的。</p><hr><h2 id="Boost网络库节点创建"><a href="#Boost网络库节点创建" class="headerlink" title="Boost网络库节点创建"></a>Boost网络库节点创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">client_end_point</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 创建客户端端点</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">server_end_point</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 创建服务端节点</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">create_acceptor_socket</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 创建服务器接收socket,生成一个acceptor的socket，用来接收新的连接。</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">bind_acceptor_socket</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 绑定socket到端口,对于acceptor类型的socket，服务器要将其绑定到指定的端点,所有连接这个端点的连接都可以被接收到。</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">connnect_to_end</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//客户端连接 作为客户端可以连接服务器指定的端点进行连接</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">dns_connect_to_end</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//通过dns域名解析的方式，去连接服务器</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">accept_new_connection</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 服务器接收连接</span><br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;endpoint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">client_end_point</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.4.8.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>; <br><br>boost::system::error_code ec; <span class="hljs-comment">//错误码，用来判断错误类型</span><br>asio::ip::address ip_address = asio::ip::address::<span class="hljs-built_in">from_string</span>(raw_ip_address, ec);<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// ip访问失败</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to parse the IP address. Error code = &quot;</span>&lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 转换成需要通信的地址，绑定ip和端口</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">server_end_point</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>    asio::ip::address ip_address = asio::ip::address_v6::<span class="hljs-built_in">any</span>();<span class="hljs-comment">//任何地址都可以与我通信</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建socket分为4步::</span><br>    <span class="hljs-comment">// 1. 创建上下文iocontext</span><br>    <span class="hljs-comment">// 2. 选择协议，</span><br>    <span class="hljs-comment">// 3. 生成socket</span><br>    <span class="hljs-comment">// 4. 打开socket。</span><br><br>    <span class="hljs-comment">// 创建上下文</span><br>    asio::io_context ioc;<br>    <span class="hljs-comment">// 创建协议</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br>    <span class="hljs-comment">// 生成socket</span><br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ioc)</span></span>;<br>    <span class="hljs-comment">// 打开socket</span><br>    boost::system::error_code ec; <span class="hljs-comment">//错误码，用来判断错误类型</span><br>    sock.<span class="hljs-built_in">open</span>(protocol, ec);<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// socket打开失败</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to parse the socket. Error code = &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_acceptor_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    asio::io_context ioc;<br>    <span class="hljs-comment">// 旧版写法</span><br>    <span class="hljs-comment">//asio::ip::tcp::acceptor acceptor(ioc);</span><br>    <span class="hljs-comment">//asio::ip::tcp protocol = asio::ip::tcp::v4();</span><br>    <span class="hljs-comment">//boost::system::error_code ec; //错误码，用来判断错误类型</span><br>    <span class="hljs-comment">//acceptor.open(protocol, ec);</span><br>    <span class="hljs-comment">//if (ec.value() != 0) &#123;</span><br>    <span class="hljs-comment">//    // acceptor打开失败</span><br>    <span class="hljs-comment">//    std::cout &lt;&lt; &quot;Failed to parse the acceptor. Error code = &quot; &lt;&lt; ec.value() &lt;&lt; &quot;. Message: &quot; &lt;&lt; ec.message();</span><br>    <span class="hljs-comment">//    return ec.value();</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">// 新版写法</span><br>    asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ioc, asio::ip::tcp::endpoint(asio::ip::tcp::v4(), <span class="hljs-number">3333</span>))</span></span>; <span class="hljs-comment">//比较简单，直接创建acceptor,默认实现绑定</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind_acceptor_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address_v4::any(),port_num)</span></span>;<br>    <span class="hljs-comment">//创建服务，绑定服务</span><br>    asio::io_context  ios;<br>    asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<span class="hljs-comment">//需要手动绑定</span><br>    boost::system::error_code ec;<br>    acceptor.<span class="hljs-built_in">bind</span>(ep, ec);<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// socket打开失败</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to bind the socket. Error code = &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connnect_to_end</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;<br>        asio::io_context ios;<br>        <br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>; <span class="hljs-comment">//创建socket</span><br>         <br>        sock.<span class="hljs-built_in">connect</span>(ep); <span class="hljs-comment">// 连接</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dns_connect_to_end</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string host = <span class="hljs-string">&quot;samplehost&quot;</span>;<br>    std::string port_num = <span class="hljs-string">&quot;3333&quot;</span>;<br>    asio::io_context ios;<br><br>    <span class="hljs-comment">// resolver_query：提供的查询服务</span><br>    asio::ip::tcp::<span class="hljs-function">resolver::query <span class="hljs-title">resolver_query</span><span class="hljs-params">(host, port_num, asio::ip::tcp::resolver::query::numeric_service)</span></span>;<span class="hljs-comment">//客户端连接的时候做域名解析</span><br>    asio::ip::<span class="hljs-function">tcp::resolver <span class="hljs-title">resolver</span><span class="hljs-params">(ios)</span></span>;<span class="hljs-comment">//域名解析器</span><br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        asio::ip::tcp::resolver::iterator it = resolver.<span class="hljs-built_in">resolve</span>(resolver_query); <span class="hljs-comment">//返回解析的迭代器</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>; <span class="hljs-comment">//创建socket</span><br>        asio::<span class="hljs-built_in">connect</span>(sock,it);<span class="hljs-comment">//一个全局的连接器</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (system::system_error&amp; e)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept_new_connection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BACKLOG_SIZE = <span class="hljs-number">30</span>;<span class="hljs-comment">//缓冲区大小</span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address_v4::any(),port_num)</span></span>;<span class="hljs-comment">//生成端点</span><br><br>    asio::io_context ios;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-comment">// 生成服务接收器</span><br>        asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<span class="hljs-comment">//需要手动绑定</span><br>        acceptor.<span class="hljs-built_in">bind</span>(ep);<br>        acceptor.<span class="hljs-built_in">listen</span>(BACKLOG_SIZE);<br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br>        acceptor.<span class="hljs-built_in">accept</span>(sock);<span class="hljs-comment">// 新的连接通信由sock处理</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (system::system_error&amp; e)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><ol><li>服务器与客户端建立连接之后，需要进行数据传输，需要用到buffer。</li><li>boost::asio提供了<code>asio::mutable_buffer</code> 和 <code>asio::const_buffer</code>这两个结构，他们是一段连续的空间，首字节存储了后续数据的长度。</li><li><code>asio::mutable_buffer用于写服务，asio::const_buffer用于读服务。</code>但是这两个结构都没有被asio的api直接使用。对于api的buffer参数，asio提出了MutableBufferSequence和ConstBufferSequence概念，他们是由多个asio::mutable_buffer和asio::const_buffer组成的。也就是说boost::asio为了节省空间，将一部分连续的空间组合起来，作为参数交给api使用。</li><li>越过复杂的组合概念，<code>asio提出了buffer()函数，该函数接收多种形式的字节流，该函数返回asio::mutable_buffers_1 o或者asio::const_buffers_1结构的对象。</code></li><li>最终，可以用buffer()函数生成我们要用的缓存存储数据。</li></ol><ul><li>boost的发送接口send要求的参数为ConstBufferSequence类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">asio::const_buffers_1 output_buf = asio::<span class="hljs-built_in">buffer</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>asio.<span class="hljs-built_in">send</span>(output_buf);<br></code></pre></td></tr></table></figure><ul><li>output_buf可以直接传递给该send接口。也可以将数组转化为send接受的类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use_buffer_array</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span>  BUF_SIZE_BYTES = <span class="hljs-number">20</span>;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">char</span>[] &gt; <span class="hljs-title">buf</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[BUF_SIZE_BYTES])</span></span>;<br>    <span class="hljs-keyword">auto</span> input_buf = asio::<span class="hljs-built_in">buffer</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(buf.<span class="hljs-built_in">get</span>()), BUF_SIZE_BYTES);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="asio-tcp同步写"><a href="#asio-tcp同步写" class="headerlink" title="asio tcp同步写"></a>asio tcp同步写</h2><ul><li><p>write，向socket中写入数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_to_socket</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br>    std::string buf = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br>    std::<span class="hljs-type">size_t</span> total_bytes_written = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环发送</span><br>    <span class="hljs-comment">// write_some返回每次写入的字节数</span><br>    <span class="hljs-comment">// 粘包的时候，或者缓冲区不够，这种时候，具体读了多少，都要通过返回值判断</span><br>    <span class="hljs-comment">// 发送的时候要用buffer构造</span><br>    <span class="hljs-keyword">while</span> (total_bytes_written != buf.<span class="hljs-built_in">length</span>()) &#123;<br>        total_bytes_written += sock.<span class="hljs-built_in">write_some</span>(asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>() + total_bytes_written, buf.<span class="hljs-built_in">length</span>() - total_bytes_written));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同步send：保证send的数据，一次性发送完成，就是想要的数据长度和大小。调用send()函数即可。send会一直等待，如果tcp没有发完，就会一直阻塞。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_data_by_write_some</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;<br>        asio::io_context ioc;<br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ioc, ep.protocol())</span></span>;<br>        sock.<span class="hljs-built_in">connect</span>(ep);<br><br>        std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        <span class="hljs-comment">// send会一直等待，如果tcp没有发完，就会一直阻塞。直到数据全部发送完毕</span><br>        <span class="hljs-type">int</span> send_length = sock.<span class="hljs-built_in">send</span>(asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>        <span class="hljs-keyword">if</span> (send_length &lt;= <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;send failed&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (system::system_error&amp; e)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同步write：类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_data_by_wirte</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function">            <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">                port_num)</span></span>;<br>        asio::io_service ios;<br>        <span class="hljs-comment">// Step 1. Allocating and opening the socket.</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br>        sock.<span class="hljs-built_in">connect</span>(ep);<br>        std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        <span class="hljs-type">int</span> send_length = asio::<span class="hljs-built_in">write</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>        <span class="hljs-keyword">if</span> (send_length &lt;= <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;send failed&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="asio-tcp同步读"><a href="#asio-tcp同步读" class="headerlink" title="asio tcp同步读"></a>asio tcp同步读</h2><ul><li>同步读和同步写类似，提供了读取指定字节数的接口read_some。不断地轮询去读</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">read_from_socket</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br>    <span class="hljs-comment">// 存消息的数组结构</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> MESSAGE_SIZE = <span class="hljs-number">7</span>;<br>    <span class="hljs-type">char</span> buf[MESSAGE_SIZE];<br>    std::<span class="hljs-type">size_t</span> total_bytes_read = <span class="hljs-number">0</span>;<span class="hljs-comment">// 表示已经读了多少字节</span><br><br>    <span class="hljs-comment">//按照偏移量进行读，不断轮询，不够的话就继续读</span><br>    <span class="hljs-keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;<br>        total_bytes_read += sock.<span class="hljs-built_in">read_some</span>(<br>            asio::<span class="hljs-built_in">buffer</span>(buf + total_bytes_read,<br>                MESSAGE_SIZE - total_bytes_read));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buf, total_bytes_read); <span class="hljs-comment">//返回给调用者</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一次读完，用receive</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_receive</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),port_num)</span></span>;<br>        asio::io_service ios;<br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br>        sock.<span class="hljs-built_in">connect</span>(ep);<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br>        <span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br>        <span class="hljs-comment">// receive函数一次性只返回定义的size大小的数据，没有读满，函数不会返回。</span><br>        <span class="hljs-comment">// receive_length&lt;0：系统级的错误</span><br>        <span class="hljs-comment">// receive_length=0：对端关闭了。</span><br>        <span class="hljs-comment">// receive_length&gt;0：肯定等于7，等于BUFF_SIZE大小，读不完，函数不会返回，函数会阻塞。</span><br>        <span class="hljs-type">int</span> receive_length = sock.<span class="hljs-built_in">receive</span>(asio::<span class="hljs-built_in">buffer</span>(buffer_receive,BUFF_SIZE));<br>        <span class="hljs-keyword">if</span> (receive_length &lt;= <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>read：也可以一次性同步读取对方发送的数据</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_read</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;<br>        asio::io_service ios;<br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br>        sock.<span class="hljs-built_in">connect</span>(ep);<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br>        <span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br>        <span class="hljs-comment">// asio给的接口</span><br>        <span class="hljs-type">int</span> receive_length = asio::<span class="hljs-built_in">read</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br>        <span class="hljs-keyword">if</span> (receive_length &lt;= <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="同步阻塞方式的读写demo"><a href="#同步阻塞方式的读写demo" class="headerlink" title="同步阻塞方式的读写demo"></a>同步阻塞方式的读写demo</h2><ul><li>客户端需要根据服务器的ip和port创建一个endpoint，然后连接，创建socket，传输数据。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-comment">//#include&quot;endpoint.h&quot;</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::asio::ip;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_LENGTH = <span class="hljs-number">1024</span>; <span class="hljs-comment">//发送和接收数据的最大长度为1024</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-comment">// 创建上下文服务</span><br>boost::asio::io_context ioc;<br><span class="hljs-comment">// 构建endpoint</span><br><span class="hljs-function">tcp::endpoint <span class="hljs-title">remote_ep</span><span class="hljs-params">(address::from_string(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">10086</span>)</span></span>;<br><span class="hljs-comment">// 创建socket</span><br><span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ioc)</span></span>;<br>boost::system::error_code error = boost::asio::error::host_not_found;<br>sock.<span class="hljs-built_in">connect</span>(remote_ep, error);<br><span class="hljs-keyword">if</span> (error) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">message</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Enter message&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-type">char</span> request[MAX_LENGTH];<br>std::cin.<span class="hljs-built_in">getline</span>(request, MAX_LENGTH);<span class="hljs-comment">//输入数据到Request里面</span><br><span class="hljs-type">size_t</span> request_length = <span class="hljs-built_in">strlen</span>(request);<br><span class="hljs-comment">// 获取输入数据长度后，一次性发送完所有数据</span><br>boost::asio::<span class="hljs-built_in">write</span>(sock, boost::asio::<span class="hljs-built_in">buffer</span>(request, request_length));<br><br><span class="hljs-comment">// 接收数据</span><br><span class="hljs-type">char</span> reply[MAX_LENGTH];<br><span class="hljs-type">size_t</span> reply_length = boost::asio::<span class="hljs-built_in">read</span>(sock,boost::asio::<span class="hljs-built_in">buffer</span>(reply, request_length));<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Reply is: &quot;</span>;<br>std::cout.<span class="hljs-built_in">write</span>(reply, reply_length);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e)<br>&#123;<br>std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception:&quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务端接收客户端的连接，并在连接后开辟新的线程处理客户端的消息，将客户端发送的消息返回回去。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> max_length = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;tcp::socket&gt; socket_ptr;<br>std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">// session：处理某个连接到来以后的收发数据，是跑在线程里的</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session</span><span class="hljs-params">(socket_ptr sock)</span> </span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">char</span> data[max_length];<br><span class="hljs-built_in">memset</span>(data, <span class="hljs-string">&#x27;\0&#x27;</span>, max_length);<br>boost::system::error_code error;<br><span class="hljs-comment">// read来读，一次读完，服务器会在这等，直到都到最大长度为止,可能要等很长时间</span><br><span class="hljs-comment">// size_t length = boost::asio::read(sock,boost::asio::buffer(data, max_length), error);</span><br><span class="hljs-type">size_t</span> length = sock-&gt;<span class="hljs-built_in">read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(data, max_length), error); <span class="hljs-comment">// 假设不粘包，服务器缓冲区充足</span><br><span class="hljs-keyword">if</span> (error == boost::asio::error::eof) &#123; <span class="hljs-comment">//对端关闭</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;connection closed by peer&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error) &#123;<span class="hljs-comment">// 其他异常抛出</span><br><span class="hljs-keyword">throw</span> boost::system::<span class="hljs-built_in">system_error</span>(error);<br>&#125;<br><br><span class="hljs-comment">// 打印对端地址和收到的数据消息</span><br>cout &lt;&lt; <span class="hljs-string">&quot;receive from &quot;</span> &lt;&lt; sock-&gt;<span class="hljs-built_in">remote_endpoint</span>().<span class="hljs-built_in">address</span>().<span class="hljs-built_in">to_string</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;receive message is &quot;</span> &lt;&lt; data &lt;&lt; endl;<br><span class="hljs-comment">//回传给对方</span><br>boost::asio::<span class="hljs-built_in">write</span>(*sock, boost::asio::<span class="hljs-built_in">buffer</span>(data, length));<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e)<br>&#123;<br>std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception:&quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// server用来接收客户端的连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server</span><span class="hljs-params">(boost::asio::io_context&amp; io_context, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span> </span>&#123;<br><span class="hljs-function">tcp::acceptor <span class="hljs-title">a</span><span class="hljs-params">(io_context, tcp::endpoint(tcp::v4(), port))</span></span>;<span class="hljs-comment">// 绑定本地ip和端口</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-function">socket_ptr <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">new</span> tcp::socket(io_context))</span></span>;<span class="hljs-comment">// 建立socket</span><br>a.<span class="hljs-built_in">accept</span>(*socket); <span class="hljs-comment">//接收连接</span><br><span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_shared</span>&lt;std::thread&gt;(session, socket); <span class="hljs-comment">// 执行session中，独立线程。</span><br>thread_set.<span class="hljs-built_in">insert</span>(t); <span class="hljs-comment">//保证线程不被释放，这次for循环结束后，线程有时间执行工作。</span><br><span class="hljs-comment">// 子线程退出以后，主线程才能退出</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 创建上下文服务</span><br>boost::asio::io_context ioc;<br><span class="hljs-built_in">server</span>(ioc, <span class="hljs-number">10086</span>);<br><span class="hljs-comment">// 子线程退出以后，主线程才能退出</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : thread_set) &#123;<br>t-&gt;<span class="hljs-built_in">join</span>();<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception:&quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>同步读写的缺陷</code></p><ul><li>阻塞式读写，如果客户端不发送read，服务器端是阻塞的。</li><li>通过进程开辟的线程为新连接处理读写，但一个进程开辟的线程是有限的，大约2048个，线程也不能开辟太多。</li><li>服务器和客户端为应答式，实际场景为全双工通信模式，发送和接收要独立分开。</li><li>该服务器和客户端未考虑粘包处理。</li></ul><p>参考列表：<br><a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2LfzYBkRCfdEDrtE6hWz8VrCLoS">https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2LfzYBkRCfdEDrtE6hWz8VrCLoS</a></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ JSON解析</title>
    <link href="/2024/03/26/C++%20JSON%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/03/26/C++%20JSON%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="C-JSON解析"><a href="#C-JSON解析" class="headerlink" title="C++ JSON解析"></a>C++ JSON解析</h1><h2 id="JSONCPP"><a href="#JSONCPP" class="headerlink" title="JSONCPP"></a>JSONCPP</h2><p>JSONCPP源码链接：<a href="https://github.com/open-source-parsers/jsoncpp">https://github.com/open-source-parsers/jsoncpp</a></p><ol><li>JSOCPP源码下载以后，首先复制一份include文件夹下的json文件夹，头文件留着后续备用。<br><img src="https://pic.imgdb.cn/item/66040b2b9f345e8d039e4bd4.png" alt="在这里插入图片描述"></li><li>使用Cmake生成项目。在IDE中编译jsoncpp_lib，可以在项目的lib&#x2F;Debug文件夹下找到jsoncpp.lib，在bin&#x2F;Debug&#x2F;文件夹下找到jsoncpp.dll。将头文件和动态链接库文件，放入项目中即可使用。<br><img src="https://pic.imgdb.cn/item/66040ba49f345e8d03a26b7d.png" alt="在这里插入图片描述"><br><img src="https://pic.imgdb.cn/item/66040bb99f345e8d03a331f6.png" alt="在这里插入图片描述"><br>jsoncpp库中的类被定义到了一个Json命名空间中，使用时最好先声明这个命名空间。</li></ol><p>使用jsoncpp库解析json格式的数据，三个类：</p><ul><li>Value 类：将json支持的数据类型进行了包装，最终得到一个Value类型。</li><li>FastWriter类：将Value对象中的数据序列化为字符串。</li><li>Reader类：反序列化，将json字符串解析成Value类型。</li></ul><hr><h3 id="C-实现JSON解析器"><a href="#C-实现JSON解析器" class="headerlink" title="C++实现JSON解析器"></a>C++实现JSON解析器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Cliu &#123;<br><br><span class="hljs-keyword">namespace</span> json &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonElement</span>;<br>    <span class="hljs-keyword">using</span> JsonObject = std::map&lt;std::string, JsonElement*&gt;;<br>    <span class="hljs-keyword">using</span> JsonArray = std::vector&lt;JsonElement*&gt;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonElement</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Type</span> &#123;<br>            JSON_OBJECT,<br>            JSON_ARRAY,<br><br>            JSON_STRING,<br>            JSON_NUMBER,<br><br>            JSON_BOOL,<br><br>            JSON_NULL<br>        &#125;;<br><br>        <span class="hljs-keyword">union</span> <span class="hljs-title class_">Value</span> &#123;<br>            JsonObject* value_object;<br>            JsonArray* value_array;<br><br>            std::string* value_string;<br>            <span class="hljs-type">float</span> value_number;<br><br>            <span class="hljs-type">bool</span> value_bool;<br>        &#125;;<br><br>        <span class="hljs-built_in">JsonElement</span>() : <span class="hljs-built_in">JsonElement</span>(Type::JSON_NULL) &#123;&#125;<br><br>        <span class="hljs-built_in">JsonElement</span>(<span class="hljs-type">const</span> Type&amp; type) : <span class="hljs-built_in">type_</span>(type) &#123;<br>            <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> Type::JSON_OBJECT:<br>                value_.value_object = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">map</span>&lt;std::string, JsonElement*&gt;();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_ARRAY:<br>                value_.value_array = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">vector</span>&lt;JsonElement*&gt;();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_STRING:<br>                value_.value_string = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_NUMBER:<br>                value_.value_number = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_BOOL:<br>                value_.value_bool = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_NULL:<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-built_in">JsonElement</span>(JsonObject* object) : <span class="hljs-built_in">type_</span>(Type::JSON_OBJECT) &#123; <span class="hljs-built_in">value</span>(object); &#125;<br>        <span class="hljs-built_in">JsonElement</span>(JsonArray* array) : <span class="hljs-built_in">type_</span>(Type::JSON_ARRAY) &#123; <span class="hljs-built_in">value</span>(array); &#125;<br>        <span class="hljs-built_in">JsonElement</span>(std::string* str) : <span class="hljs-built_in">type_</span>(Type::JSON_STRING) &#123; <span class="hljs-built_in">value</span>(str); &#125;<br>        <span class="hljs-built_in">JsonElement</span>(<span class="hljs-type">float</span> number) : <span class="hljs-built_in">type_</span>(Type::JSON_NUMBER) &#123; <span class="hljs-built_in">value</span>(number); &#125;<br>        <span class="hljs-built_in">JsonElement</span>(<span class="hljs-type">bool</span> val) : <span class="hljs-built_in">type_</span>(Type::JSON_BOOL) &#123; <span class="hljs-built_in">value</span>(val); &#125;<br><br>        ~<span class="hljs-built_in">JsonElement</span>() &#123;<br>            <span class="hljs-keyword">if</span> (type_ == Type::JSON_OBJECT) &#123;<br>                JsonObject* object = value_.value_object;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; a : *object) &#123;<br>                    <span class="hljs-keyword">delete</span> a.second;<br>                &#125;<br>                <span class="hljs-keyword">delete</span> object;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type_ == Type::JSON_ARRAY) &#123;<br>                JsonArray* array = value_.value_array;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : *array) &#123;<br>                    <span class="hljs-keyword">delete</span> item;<br>                &#125;<br>                <span class="hljs-keyword">delete</span> array;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type_ == Type::JSON_STRING) &#123;<br>                std::string* val = value_.value_string;<br>                <span class="hljs-keyword">delete</span> val;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">Type <span class="hljs-title">type</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> type_; &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">value</span><span class="hljs-params">(JsonObject* value)</span> </span>&#123;<br>            type_ = Type::JSON_OBJECT;<br>            value_.value_object = value;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">value</span><span class="hljs-params">(JsonArray* value)</span> </span>&#123;<br>            type_ = Type::JSON_ARRAY;<br>            value_.value_array = value;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">value</span><span class="hljs-params">(std::string* value)</span> </span>&#123;<br>            type_ = Type::JSON_STRING;<br>            value_.value_string = value;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">float</span> value)</span> </span>&#123;<br>            type_ = Type::JSON_NUMBER;<br>            value_.value_number = value;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">bool</span> value)</span> </span>&#123;<br>            type_ = Type::JSON_BOOL;<br>            value_.value_bool = value;<br>        &#125;<br><br>        <span class="hljs-function">JsonObject* <span class="hljs-title">AsObject</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (type_ == Type::JSON_OBJECT) &#123;<br>                <span class="hljs-keyword">return</span> value_.value_object;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Type of JsonElement isn&#x27;t JsonObject!&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">JsonArray* <span class="hljs-title">AsArray</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (type_ == Type::JSON_ARRAY) &#123;<br>                <span class="hljs-keyword">return</span> value_.value_array;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Type of JsonElement isn&#x27;t JsonArray!&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">std::string* <span class="hljs-title">AsString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (type_ == Type::JSON_STRING) &#123;<br>                <span class="hljs-keyword">return</span> value_.value_string;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Type of JsonElement isn&#x27;t String!&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">AsNumber</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (type_ == Type::JSON_NUMBER) &#123;<br>                <span class="hljs-keyword">return</span> value_.value_number;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Type of JsonElement isn&#x27;t Number!&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0.0f</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AsBoolean</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (type_ == Type::JSON_BOOL) &#123;<br>                <span class="hljs-keyword">return</span> value_.value_bool;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Type of JsonElement isn&#x27;t Boolean!&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">std::string <span class="hljs-title">Dumps</span><span class="hljs-params">()</span> </span>&#123;<br>            std::stringstream ss;<br>            <span class="hljs-keyword">switch</span> (type_) &#123;<br>            <span class="hljs-keyword">case</span> Type::JSON_OBJECT:<br>                ss &lt;&lt; *(value_.value_object);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_ARRAY:<br>                ss &lt;&lt; *(value_.value_array);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_STRING:<br>                ss &lt;&lt; <span class="hljs-string">&#x27;\&quot;&#x27;</span> &lt;&lt; *(value_.value_string) &lt;&lt; <span class="hljs-string">&#x27;\&quot;&#x27;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_NUMBER:<br>                ss &lt;&lt; value_.value_number;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_BOOL:<br>                ss &lt;&lt; (value_.value_bool == <span class="hljs-literal">true</span> ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> Type::JSON_NULL:<br>                ss &lt;&lt; <span class="hljs-string">&quot;null&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ss.<span class="hljs-built_in">str</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> JsonObject&amp; object) &#123;<br>            os &lt;&lt; <span class="hljs-string">&quot;&#123;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = object.<span class="hljs-built_in">begin</span>(); iter != object.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>                os &lt;&lt; <span class="hljs-string">&#x27;\&quot;&#x27;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&#x27;\&quot;&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; iter-&gt;second-&gt;<span class="hljs-built_in">Dumps</span>();<br>                <span class="hljs-keyword">if</span> (iter != --object.<span class="hljs-built_in">end</span>()) &#123;<br>                    os &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>                &#125;<br>            &#125;<br>            os &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span>;<br>            <span class="hljs-keyword">return</span> os;<br>        &#125;<br><br>        <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> JsonArray&amp; array) &#123;<br>            os &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                os &lt;&lt; array[i]-&gt;<span class="hljs-built_in">Dumps</span>();<br>                <span class="hljs-keyword">if</span> (i != array.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                    os &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>                &#125;<br>            &#125;<br>            os &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>            <span class="hljs-keyword">return</span> os;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        Type type_;<br>        Value value_;<br>    &#125;;<br><br>&#125; <span class="hljs-comment">// namespace json</span><br><br>&#125; <span class="hljs-comment">// namespace Cliu</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Error.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Cliu &#123;<br><br><span class="hljs-keyword">namespace</span> json &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Scanner</span>(<span class="hljs-type">const</span> std::string&amp; source) : <span class="hljs-built_in">source_</span>(source), <span class="hljs-built_in">current_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-built_in">Scanner</span>(std::string&amp;&amp; source) : <span class="hljs-built_in">source_</span>(std::<span class="hljs-built_in">move</span>(source)), <span class="hljs-built_in">current_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">JsonTokenType</span><br>&#123;<br>BEGIN_OBJECT, <span class="hljs-comment">///&lt; &#123;</span><br>END_OBJECT, <span class="hljs-comment">///&lt; &#125;</span><br><br>VALUE_SEPARATOR, <span class="hljs-comment">///&lt; , 逗号</span><br>NAME_SEPARATOR, <span class="hljs-comment">///&lt; : 冒号</span><br><br>VALUE_STRING, <span class="hljs-comment">///&lt; &quot;string&quot;</span><br>VALUE_NUMBER, <span class="hljs-comment">///&lt; 1,2,2e10</span><br><br>LITERAL_TRUE, <span class="hljs-comment">///&lt; true</span><br>LITERAL_FALSE,<span class="hljs-comment">///&lt; false</span><br>LITERAL_NULL, <span class="hljs-comment">///&lt; null</span><br><br>BEGIN_ARRAY, <span class="hljs-comment">///&lt; [ 数组左括号</span><br>END_ARRAY, <span class="hljs-comment">///&lt; ] 数组右括号</span><br><br>END_OF_SOURCE, <span class="hljs-comment">///&lt; EOF</span><br><br>        ERROR <br><br>&#125;;<br><br><span class="hljs-function">JsonTokenType <span class="hljs-title">Scan</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 扫描下一个，返回下一个token的type</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Rollback</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> JsonTokenType&amp; type) &#123;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> JsonTokenType::BEGIN_ARRAY:<br>            os &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::END_ARRAY:<br>            os &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::BEGIN_OBJECT:<br>            os &lt;&lt; <span class="hljs-string">&quot;&#123;&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::END_OBJECT:<br>            os &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::NAME_SEPARATOR:<br>            os &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::VALUE_SEPARATOR:<br>            os &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::VALUE_NUMBER:<br>            os &lt;&lt; <span class="hljs-string">&quot;number&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::VALUE_STRING:<br>            os &lt;&lt; <span class="hljs-string">&quot;string&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::LITERAL_TRUE:<br>            os &lt;&lt; <span class="hljs-string">&quot;true&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::LITERAL_FALSE:<br>            os &lt;&lt; <span class="hljs-string">&quot;false&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::LITERAL_NULL:<br>            os &lt;&lt; <span class="hljs-string">&quot;null&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> JsonTokenType::END_OF_SOURCE:<br>            os &lt;&lt; <span class="hljs-string">&quot;EOF&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetNumberValue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value_number_; &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">GetStringValue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value_string_; &#125;;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsAtEnd</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Advance</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScanTrue</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScanFalse</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScanNull</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScanString</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScanNumber</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Peek</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">PeekNext</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsDigit</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>;<br><br><br><span class="hljs-keyword">private</span>:<br>std::string source_; <span class="hljs-comment">///&lt; json source</span><br><span class="hljs-type">size_t</span> current_;      <span class="hljs-comment">///&lt; current pos of processing character</span><br>    <span class="hljs-type">size_t</span> prev_pos_;  <span class="hljs-comment">///&lt; previous handling pos;</span><br><br><span class="hljs-type">float</span> value_number_;        <span class="hljs-comment">///&lt; number value</span><br>std::string value_string_;  <span class="hljs-comment">///&lt; string value</span><br><br>&#125;;<span class="hljs-comment">// end of class Scanner</span><br><br>&#125; <span class="hljs-comment">// namespace json</span><br><br>&#125; <span class="hljs-comment">// namespace Cliu</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Scanner.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Cliu &#123;<br><br><span class="hljs-keyword">namespace</span> json &#123;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Scanner::IsAtEnd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> current_ &gt;= source_.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Scanner::Advance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> source_[current_++];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Scanner::Rollback</span><span class="hljs-params">()</span> </span>&#123; current_ = prev_pos_; &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Scanner::IsDigit</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Scanner::Peek</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 获取下一个</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsAtEnd</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> source_[current_];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Scanner::PeekNext</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 要确保下一个值是存在的</span><br>    <span class="hljs-keyword">if</span> (current_ + <span class="hljs-number">1</span> &gt;= source_.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> source_[current_ + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Scanner::ScanTrue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 判断是否是true</span><br>    <span class="hljs-keyword">if</span> (source_.<span class="hljs-built_in">compare</span>(current_, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;rue&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        current_ += <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Scan `true` error&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Scanner::ScanFalse</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (source_.<span class="hljs-built_in">compare</span>(current_, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;alse&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        current_ += <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Scan `false` error&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Scanner::ScanNull</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (source_.<span class="hljs-built_in">compare</span>(current_, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;ull&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        current_ += <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Scan `null` error&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Scanner::ScanString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> pos = current_;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Peek</span>() != <span class="hljs-string">&#x27;\&quot;&#x27;</span> &amp;&amp; !<span class="hljs-built_in">IsAtEnd</span>()) &#123;<br>        <span class="hljs-built_in">Advance</span>();<span class="hljs-comment">// 再走一步 //没有考虑转义字符</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsAtEnd</span>()) &#123;<br>        <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;invalid string: missing closing quote&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">Advance</span>();<br><br>    value_string_ = source_.<span class="hljs-built_in">substr</span>(pos, current_ - pos - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Scanner::ScanNumber</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> pos = current_ - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">IsDigit</span>(<span class="hljs-built_in">Peek</span>())) &#123;<br>        <span class="hljs-built_in">Advance</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// fractional part</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Peek</span>() == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; <span class="hljs-built_in">IsDigit</span>(<span class="hljs-built_in">PeekNext</span>())) &#123;<br>        <span class="hljs-built_in">Advance</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">IsDigit</span>(<span class="hljs-built_in">Peek</span>())) &#123;<br>            <span class="hljs-built_in">Advance</span>();<br>        &#125;<br>    &#125;<br><br>    value_number_ = std::<span class="hljs-built_in">atof</span>(source_.<span class="hljs-built_in">substr</span>(pos, current_ - pos).<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><br><span class="hljs-function">Scanner::JsonTokenType <span class="hljs-title">Scanner::Scan</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 判断是否扫描完毕</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsAtEnd</span>()) &#123;<br><span class="hljs-keyword">return</span> JsonTokenType::END_OF_SOURCE; <span class="hljs-comment">// 返回扫描完毕标识符</span><br>&#125;<br>    prev_pos_ = current_;<br><span class="hljs-type">char</span> c = <span class="hljs-built_in">Advance</span>(); <span class="hljs-comment">// 获取下一个字符</span><br><span class="hljs-keyword">switch</span> (c)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<br>        <span class="hljs-keyword">return</span> JsonTokenType::BEGIN_ARRAY;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>:<br>        <span class="hljs-keyword">return</span> JsonTokenType::END_ARRAY;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:<br>        <span class="hljs-keyword">return</span> JsonTokenType::BEGIN_OBJECT;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:<br>        <span class="hljs-keyword">return</span> JsonTokenType::END_OBJECT;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;:&#x27;</span>:<br>        <span class="hljs-keyword">return</span> JsonTokenType::NAME_SEPARATOR;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;,&#x27;</span>:<br>        <span class="hljs-keyword">return</span> JsonTokenType::VALUE_SEPARATOR;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>        <span class="hljs-built_in">ScanTrue</span>();<br>        <span class="hljs-keyword">return</span> JsonTokenType::LITERAL_TRUE;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>        <span class="hljs-built_in">ScanFalse</span>();<br>        <span class="hljs-keyword">return</span> JsonTokenType::LITERAL_FALSE;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:<br>        <span class="hljs-built_in">ScanNull</span>();<br>        <span class="hljs-keyword">return</span> JsonTokenType::LITERAL_NULL;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:<br>        <span class="hljs-built_in">ScanNumber</span>();<br>        <span class="hljs-keyword">return</span> JsonTokenType::VALUE_NUMBER;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\&quot;&#x27;</span>:<br>        <span class="hljs-built_in">ScanString</span>();<br>        <span class="hljs-keyword">return</span> JsonTokenType::VALUE_STRING;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\r&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Scan</span>();<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// error</span><br>        std::string message = <span class="hljs-string">&quot;Unsupported Token: &quot;</span>;<br>        message += c;<br>        <span class="hljs-built_in">Error</span>(std::<span class="hljs-built_in">string</span>(message));<br>        <span class="hljs-keyword">return</span> JsonTokenType::ERROR;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">JsonTokenType</span>();<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace json</span><br><br>&#125; <span class="hljs-comment">// namespace Cliu</span><br><br><br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Scanner.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;JsonElement.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Cliu &#123;<br><br><span class="hljs-keyword">namespace</span> json &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parser</span> &#123;<br><span class="hljs-keyword">using</span> JsonTokenType = Scanner::JsonTokenType;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">JsonElement* <span class="hljs-title">Parse</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">Parser</span>(<span class="hljs-type">const</span> Scanner&amp; scanner) : <span class="hljs-built_in">scanner_</span>(scanner) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function">JsonObject* <span class="hljs-title">ParseObject</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">JsonArray* <span class="hljs-title">ParseArray</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>Scanner scanner_;<br>&#125;;<br><br>&#125; <span class="hljs-comment">// namespace json</span><br><br>&#125; <span class="hljs-comment">// namespace Cliu</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Parser.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Cliu &#123;<br><br><span class="hljs-keyword">namespace</span> json &#123;<br><br><span class="hljs-function">JsonElement* <span class="hljs-title">Parser::Parse</span><span class="hljs-params">()</span> </span>&#123;<br>JsonElement* element = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JsonElement</span>();<br>JsonTokenType token_type_ = scanner_.<span class="hljs-built_in">Scan</span>();<br><br><span class="hljs-keyword">if</span> (token_type_ != JsonTokenType::END_OF_SOURCE) &#123;<br><span class="hljs-keyword">switch</span> (token_type_) &#123;<br><span class="hljs-keyword">case</span> JsonTokenType::BEGIN_OBJECT: &#123;<br>JsonObject* object = <span class="hljs-built_in">ParseObject</span>();<br>element-&gt;<span class="hljs-built_in">value</span>(object);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> JsonTokenType::BEGIN_ARRAY: &#123;<br>JsonArray* array = <span class="hljs-built_in">ParseArray</span>();<br>element-&gt;<span class="hljs-built_in">value</span>(array);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> JsonTokenType::VALUE_STRING: &#123;<br>std::string* val = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(scanner_.<span class="hljs-built_in">GetStringValue</span>());<br>element-&gt;<span class="hljs-built_in">value</span>(val);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> JsonTokenType::VALUE_NUMBER: &#123;<br>element-&gt;<span class="hljs-built_in">value</span>(scanner_.<span class="hljs-built_in">GetNumberValue</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> JsonTokenType::LITERAL_TRUE: &#123;<br>element-&gt;<span class="hljs-built_in">value</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> JsonTokenType::LITERAL_FALSE: &#123;<br>element-&gt;<span class="hljs-built_in">value</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> JsonTokenType::LITERAL_NULL: &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-function">JsonObject* <span class="hljs-title">Parser::ParseObject</span><span class="hljs-params">()</span> </span>&#123;<br>JsonObject* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JsonObject</span>();<br><br>JsonTokenType next = scanner_.<span class="hljs-built_in">Scan</span>();<br><span class="hljs-keyword">if</span> (next == JsonTokenType::END_OBJECT) &#123; <span class="hljs-comment">//判断是否为空对象</span><br><span class="hljs-keyword">return</span> res;<br>&#125;<br>scanner_.<span class="hljs-built_in">Rollback</span>();<span class="hljs-comment">// 回退一步</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>next = scanner_.<span class="hljs-built_in">Scan</span>();<br><span class="hljs-keyword">if</span> (next != JsonTokenType::VALUE_STRING) &#123;<br><span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Key must be string!&quot;</span>);<br>&#125;<br>std::string key = scanner_.<span class="hljs-built_in">GetStringValue</span>();<br>next = scanner_.<span class="hljs-built_in">Scan</span>();<br><span class="hljs-keyword">if</span> (next != JsonTokenType::NAME_SEPARATOR) &#123;<br><span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Expected &#x27;:&#x27; in object!&quot;</span>);<br>&#125;<br>(*res)[key] = <span class="hljs-built_in">Parse</span>();<br>next = scanner_.<span class="hljs-built_in">Scan</span>();<br><span class="hljs-keyword">if</span> (next == JsonTokenType::END_OBJECT) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (next != JsonTokenType::VALUE_SEPARATOR) &#123;<br><span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Expected &#x27;,&#x27; in object!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">JsonArray* <span class="hljs-title">Parser::ParseArray</span><span class="hljs-params">()</span> </span>&#123;<br>JsonArray* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JsonArray</span>();<br>JsonTokenType next = scanner_.<span class="hljs-built_in">Scan</span>();<br><span class="hljs-keyword">if</span> (next == JsonTokenType::END_ARRAY) &#123;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>scanner_.<span class="hljs-built_in">Rollback</span>();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>res-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Parse</span>());<br>next = scanner_.<span class="hljs-built_in">Scan</span>();<br><span class="hljs-keyword">if</span> (next == JsonTokenType::END_ARRAY) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (next != JsonTokenType::VALUE_SEPARATOR) &#123;<br><span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Expected &#x27;,&#x27; in array!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br>&#125; <span class="hljs-comment">// namespace json</span><br><br>&#125; <span class="hljs-comment">// namespace Cliu</span><br></code></pre></td></tr></table></figure><p>参考列表<br><a href="https://subingwen.cn/cpp/jsoncpp/?highlight=json">https://subingwen.cn/cpp/jsoncpp/?highlight=json</a><br><a href="https://blog.csdn.net/qq_43142808/article/details/115654942">https://blog.csdn.net/qq_43142808/article/details/115654942</a><br><a href="https://zhuanlan.zhihu.com/p/476271291">https://zhuanlan.zhihu.com/p/476271291</a></p>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ LRU</title>
    <link href="/2024/03/26/C++%20LRU/"/>
    <url>/2024/03/26/C++%20LRU/</url>
    
    <content type="html"><![CDATA[<h1 id="C-LRU"><a href="#C-LRU" class="headerlink" title="C++ LRU"></a>C++ LRU</h1><p>LRU：<code>最近最少使用缓存，实现 LRUCache 类：</code></p><ul><li>LRUCache(int capacity) ：以正整数作为容量capacity，初始化LRU缓存。</li><li>int get(int key)：如果关键字 key 存在于缓存中，则返回关键字的值，否则返回-1。</li><li>void put(int key, int value)：如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value。如果插入操作导致关键字数量超过 capacity ，则应该逐出最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</li></ul><p>总是希望最近使用的、最频繁使用的数据存储在比较靠前的位置。于是，LRU 缓存要具备以下特点：</p><ul><li><code>插入某个数据时，它应该被放到 Cache 的最前面</code></li><li><code>查询某个数据之后，它应该被挪到 Cache 的最前面</code></li><li><code>插入数据时，如果 Cache 的容量不够时，把 Cache 尾部的数据移出</code></li></ul><p>一个常见的LRU缓存的实现思路是使用哈希表和双向链表结合的方法：</p><ol><li><code>哈希表:</code> 存储键和指向其在双向链表中节点的指针，用于O(1)时间复杂度内查找键。</li><li><code>双向链表</code>: 存储键值对，链表的顺序由元素的使用顺序决定。最近使用的元素被放置在链表的前端，而最少使用的元素则被放置在链表的尾端。</li></ol><p>如果考虑线程安全性，就需要用到锁，C++中的mutex，配合std::lock_guard使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> _LRU&#123;<br><br><span class="hljs-comment">// 设计一个不限类型的线程安全的LRU，还不让使用STL</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    K key;<br>    V value;<br>    Node* prev;<br>    Node* next;<br><br>    <span class="hljs-built_in">Node</span>(K k, V v):<span class="hljs-built_in">key</span>(k),<span class="hljs-built_in">value</span>(v),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> cap) : <span class="hljs-built_in">capacity</span>(cap),<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>)&#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt;(<span class="hljs-built_in">K</span>(),<span class="hljs-built_in">V</span>());<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt;(<span class="hljs-built_in">K</span>(),<span class="hljs-built_in">V</span>()); <br>        <span class="hljs-comment">/*head = new Node&lt;K,V&gt;(0,0);</span><br><span class="hljs-comment">        tail = new Node&lt;K,V&gt;(0,0);*/</span><br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>        <span class="hljs-comment">// 初始化哈希表</span><br>        hashTable = <span class="hljs-keyword">new</span> NodePointer[capacity]();<br>    &#125;<br><br>    ~<span class="hljs-built_in">LRUCache</span>()&#123;<br>        NodePointer cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            NodePointer next = cur-&gt;next;<br>            <span class="hljs-keyword">delete</span> cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> []hashTable;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入或更新节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index = <span class="hljs-built_in">hash</span>(key);<br>        <br>        <span class="hljs-comment">// 如果键已经存在，更新值并移动到头部</span><br>        <span class="hljs-keyword">if</span>(hashTable[index])&#123;<br>            hashTable[index]-&gt;value = value;<br>            <span class="hljs-built_in">moveToHead</span>(hashTable[index]);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            NodePointer newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt;(key,value);<br>            hashTable[index] = newNode;<br>            <span class="hljs-built_in">moveToHead</span>(newNode);<br>            <span class="hljs-comment">// 如果超出容量，移除LRU节点</span><br>            size++;<br>            <span class="hljs-keyword">if</span>(size&gt;capacity)&#123;<br>                <span class="hljs-built_in">removeLRU</span>();<br>                size--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取节点的值</span><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index = <span class="hljs-built_in">hash</span>(key);<br><br>        NodePointer node = hashTable[index];<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;key == key) &#123;<br>                <span class="hljs-built_in">moveToHead</span>(node);<br>                <span class="hljs-keyword">return</span> node-&gt;value;<br>            &#125;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">V</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">using</span> NodePointer = Node&lt;K,V&gt;*;<br>    NodePointer head;<span class="hljs-comment">// 虚拟头节点</span><br>    NodePointer tail;<br>    NodePointer* hashTable; <span class="hljs-comment">//散列表</span><br>    std::mutex mutex;<br>    <br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(K key)</span> </span>&#123;<br>        <span class="hljs-comment">// 最简单的散列函数</span><br>        <span class="hljs-keyword">return</span> std::hash&lt;K&gt;&#123;&#125;(key) % capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(NodePointer node)</span> </span>&#123;<br>        <span class="hljs-comment">//if (node == head)return;</span><br>        <span class="hljs-comment">// 从当前位置移除节点</span><br>        <span class="hljs-comment">// 如果是新节点，就不要做这个操作了</span><br>        <span class="hljs-keyword">if</span>(node-&gt;prev)&#123;<br>            node-&gt;prev-&gt;next = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;next)&#123;<br>            node-&gt;next-&gt;prev = node-&gt;prev;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 移动node节点到头部</span><br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;prev = node;<br>        node-&gt;prev = head;<br>        head-&gt;next = node;<br>    &#125;<br><br>    <span class="hljs-comment">// 移除最少使用的节点（LRU节点）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeLRU</span><span class="hljs-params">()</span></span>&#123;<br>        NodePointer lru = tail-&gt;prev;<br>        <span class="hljs-keyword">if</span>(lru == head) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 从链表移除LRU节点</span><br>        lru-&gt;prev-&gt;next = tail;<br>        tail-&gt;prev = lru-&gt;prev;<br><br>        <span class="hljs-comment">// 在hash表中删除该节点</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index = <span class="hljs-built_in">hash</span>(lru-&gt;key);<br>        hashTable[index] = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> lru;<br>    &#125;<br>&#125;;<br><br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">_LRU::LRUCache&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">cache</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">// 容量为3，hash算法也是以3为分母</span><br><br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 1</span><br><br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <br>    std::cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 2</span><br><br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 插入4,4以后，和1,1冲突，hash表key=1的value变为4 </span><br>    std::cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 4</span><br>    std::cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">3</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 3 </span><br>    std::cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">4</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0 //找不到，为0</span><br>    std::cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 2</span><br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 插入5,5 和2,2冲突，hash表key=2的value变为5 </span><br>    std::cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0 //找不到，为0</span><br>    std::cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考列表<br><a href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/</a><br><a href="https://www.jianshu.com/p/f82a90bd3a22">https://www.jianshu.com/p/f82a90bd3a22</a></p>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++数据库连接池</title>
    <link href="/2024/03/26/C++%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2024/03/26/C++%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-数据库连接池"><a href="#C-数据库连接池" class="headerlink" title="C++数据库连接池"></a>C++数据库连接池</h1><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>对于数据库操作都是在访问数据库的时候创建连接，访问完毕断开连接。但是如果在高并发情况下，有些需要频繁处理的操作就会消耗很多的资源和时间，比如：</p><ul><li>建立通信连接的TCP三次握手</li><li>数据库服务器的连接认证</li><li>数据库服务器关闭连接时的资源回收</li><li>断开通信连接的TCP四次挥手</li></ul><p><code>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。在并发程度比较高的时候，连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率。</code></p><hr><h2 id="C-API"><a href="#C-API" class="headerlink" title="C API"></a>C API</h2><ul><li>MYSQL *mysql_real_connect：连接mysql服务器。</li><li>int mysql_query(MYSQL *mysql, const char *query); 执行sql语句</li><li>MYSQL_RES *mysql_store_result(MYSQL *mysql); 获取结果集</li><li>unsigned int mysql_num_fields(MYSQL_RES *result) 得到结果集的列数</li><li>MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result); 获取表头 -&gt; 列名(字段名)</li><li>unsigned long *mysql_fetch_lengths(MYSQL_RES *result); 得到结果集中字段的长度</li><li>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result); 遍历结果集</li><li>void mysql_free_result(MYSQL_RES *result); 释放结果集</li><li>void mysql_close(MYSQL *mysql); 关闭mysql实例</li><li>const char *mysql_character_set_name(MYSQL *mysql)  为当前连接返回默认的字符集。</li><li>int mysql_set_character_set(MYSQL *mysql, char *csname); 设置api使用的字符集</li><li>my_bool mysql_autocommit(MYSQL *mysql, my_bool mode)  mysql中默认会进行事务的提交。</li><li>my_bool mysql_commit(MYSQL *mysql); 事务提交</li><li>my_bool mysql_rollback(MYSQL *mysql)  数据回滚</li><li>const char *mysql_error(MYSQL *mysql); 打印错误信息</li><li>unsigned int mysql_errno(MYSQL *mysql); 返回错误编号</li><li>Windows：libmysql.dll 库。</li><li>Linux：libmysqlclient.so。</li></ul><h2 id="数据库步骤"><a href="#数据库步骤" class="headerlink" title="数据库步骤"></a>数据库步骤</h2><p><code>数据库连接顺序</code></p><ol><li>初始化连接环境</li><li>连接mysql的服务器，需要提供如下连接数据: IP，端口，用户名，密码，数据库名字</li><li>数据库的增删查改操作</li><li>事务处理：提交事务；或者回滚。</li><li>数据库的读操作</li><li>遍历结果集。</li><li>释放资源。</li></ol><p><code>数据库连接池</code></p><ul><li>单例模式，只需要一个类对象。</li><li>所有的数据库连接应该维护到一个安全的队列中，直接使用STL的queue。</li><li>在需要的时候可以从连接池中得到一个或多个可用的数据库连接，对于连接的动态创建和销毁，用单独的线程去处理。</li><li>如果队列中没有多余的可用连接，需要动态的创建新连接。</li><li>如果队列中空闲的连接太多，需要动态的销毁一部分。</li><li>数据库操作完毕，需要将连接归还到连接池中。生产者和消费者模型：锁，条件变量。</li></ul><p>数据库连接服务操作模块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mysql.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> chrono;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MysqlConn</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 初始化数据库连接</span><br>    <span class="hljs-built_in">MysqlConn</span>();<br>    <span class="hljs-comment">// 释放数据库连接</span><br>    ~<span class="hljs-built_in">MysqlConn</span>();<br>    <span class="hljs-comment">// 连接数据库</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(string user, string passwd, string dbName, string ip, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = <span class="hljs-number">3306</span>)</span></span>;<br>    <span class="hljs-comment">// 更新数据库: insert, update, delete</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">update</span><span class="hljs-params">(string sql)</span></span>;<br>    <span class="hljs-comment">// 查询数据库</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(string sql)</span></span>;<br>    <span class="hljs-comment">// 遍历查询得到的结果集</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 得到结果集中的字段值</span><br>    <span class="hljs-function">string <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br>    <span class="hljs-comment">// 事务操作</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">transaction</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 提交事务</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 事务回滚 </span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rollback</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 刷新起始的空闲时间点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">refreshAliveTime</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 计算连接存活的总时长</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">getAliveTime</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">freeResult</span><span class="hljs-params">()</span></span>;<br>    MYSQL* m_conn = <span class="hljs-literal">nullptr</span>;<br>    MYSQL_RES* m_result = <span class="hljs-literal">nullptr</span>;<br>    MYSQL_ROW m_row = <span class="hljs-literal">nullptr</span>;<br>    steady_clock::time_point m_alivetime;<span class="hljs-comment">// 绝对时钟判断连接存活时长</span><br>&#125;;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MysqlConn.h&quot;</span></span><br><br>MysqlConn::<span class="hljs-built_in">MysqlConn</span>()<br>&#123;<br>    m_conn = <span class="hljs-built_in">mysql_init</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//初始化对象</span><br>    <span class="hljs-built_in">mysql_set_character_set</span>(m_conn, <span class="hljs-string">&quot;utf8&quot;</span>); <span class="hljs-comment">// 设置utf-8编码格式</span><br>&#125;<br><br>MysqlConn::~<span class="hljs-built_in">MysqlConn</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (m_conn != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-built_in">mysql_close</span>(m_conn); <span class="hljs-comment">//关闭连接</span><br>    &#125;<br>    <span class="hljs-built_in">freeResult</span>(); <span class="hljs-comment">// 释放一个结果集合使用的内存。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MysqlConn::connect</span><span class="hljs-params">(string user, string passwd, string dbName, string ip, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    MYSQL* ptr = <span class="hljs-built_in">mysql_real_connect</span>(m_conn, ip.<span class="hljs-built_in">c_str</span>(), user.<span class="hljs-built_in">c_str</span>(), passwd.<span class="hljs-built_in">c_str</span>(), dbName.<span class="hljs-built_in">c_str</span>(), port, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//连接mysql服务器</span><br>    <span class="hljs-keyword">return</span> ptr != <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MysqlConn::update</span><span class="hljs-params">(string sql)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">mysql_query</span>(m_conn, sql.<span class="hljs-built_in">c_str</span>())) <span class="hljs-comment">//更新数据库</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MysqlConn::query</span><span class="hljs-params">(string sql)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">freeResult</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">mysql_query</span>(m_conn, sql.<span class="hljs-built_in">c_str</span>()))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    m_result = <span class="hljs-built_in">mysql_store_result</span>(m_conn); <span class="hljs-comment">// 保存结果集</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MysqlConn::next</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m_result != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        m_row = <span class="hljs-built_in">mysql_fetch_row</span>(m_result);<br>        <span class="hljs-keyword">if</span> (m_row != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">MysqlConn::value</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rowCount = <span class="hljs-built_in">mysql_num_fields</span>(m_result);<br>    <span class="hljs-keyword">if</span> (index &gt;= rowCount || index &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>();<br>    &#125;<br>    <span class="hljs-type">char</span>* val = m_row[index];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length = <span class="hljs-built_in">mysql_fetch_lengths</span>(m_result)[index];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(val, length);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MysqlConn::transaction</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">mysql_autocommit</span>(m_conn, <span class="hljs-literal">false</span>); <span class="hljs-comment">//手动提交，不自动提交事务。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MysqlConn::commit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">mysql_commit</span>(m_conn); <span class="hljs-comment">//提交事务</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MysqlConn::rollback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">mysql_rollback</span>(m_conn); <span class="hljs-comment">// 事务回滚</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MysqlConn::refreshAliveTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_alivetime = steady_clock::<span class="hljs-built_in">now</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">MysqlConn::getAliveTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    nanoseconds res = steady_clock::<span class="hljs-built_in">now</span>() - m_alivetime;<span class="hljs-comment">// 纳秒 较高精度</span><br>    milliseconds millsec = <span class="hljs-built_in">duration_cast</span>&lt;milliseconds&gt;(res);<span class="hljs-comment">// 毫秒 精度相对较低</span><br>    <span class="hljs-keyword">return</span> millsec.<span class="hljs-built_in">count</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MysqlConn::freeResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m_result)<br>    &#123;<br>        <span class="hljs-built_in">mysql_free_result</span>(m_result);<br>        m_result = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>连接池</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MysqlConn.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ConnectionPool* <span class="hljs-title">getConnectPool</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 创建单例模式</span><br>    <span class="hljs-built_in">ConnectionPool</span>(<span class="hljs-type">const</span> ConnectionPool&amp; obj) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">//禁止使用拷贝构造</span><br>    ConnectionPool&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ConnectionPool&amp; obj) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁止使用拷贝赋值运算符</span><br>    <span class="hljs-function">shared_ptr&lt;MysqlConn&gt; <span class="hljs-title">getConnection</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">ConnectionPool</span>();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">ConnectionPool</span>(); <span class="hljs-comment">//构造函数设置为私有的，单例模式</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">parseJsonFile</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">produceConnection</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recycleConnection</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addConnection</span><span class="hljs-params">()</span></span>;<br><br>    string m_ip;<span class="hljs-comment">// 数据库服务器ip地址</span><br>    string m_user;<span class="hljs-comment">// 数据库服务器用户名</span><br>    string m_passwd;<span class="hljs-comment">// 数据库服务器密码</span><br>    string m_dbName;<span class="hljs-comment">// 数据库服务器的数据库名</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_port;<span class="hljs-comment">// 数据库服务器绑定的端口</span><br>    <span class="hljs-type">int</span> m_minSize;<span class="hljs-comment">// 连接池维护的最小连接数</span><br>    <span class="hljs-type">int</span> m_maxSize;<span class="hljs-comment">// 连接池维护的最大连接数</span><br>    <span class="hljs-type">int</span> m_timeout;<span class="hljs-comment">// 连接池获取连接的超时时长</span><br>    <span class="hljs-type">int</span> m_maxIdleTime;<span class="hljs-comment">// 连接池中连接的最大空闲时长</span><br><br><br>    queue&lt;MysqlConn*&gt; m_connectionQ; <span class="hljs-comment">// 连接队列</span><br>    mutex m_mutexQ; <br>    condition_variable m_cond;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ConnectionPool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/json.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Json;<br><span class="hljs-function">ConnectionPool* <span class="hljs-title">ConnectionPool::getConnectPool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> ConnectionPool pool;<br>    <span class="hljs-keyword">return</span> &amp;pool;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ConnectionPool::parseJsonFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;dbconf.json&quot;</span>)</span></span>;<br>    Reader rd;<br>    Value root;<br>    rd.<span class="hljs-built_in">parse</span>(ifs, root);<br>    <span class="hljs-keyword">if</span> (root.<span class="hljs-built_in">isObject</span>())<br>    &#123;<br>        m_ip = root[<span class="hljs-string">&quot;ip&quot;</span>].<span class="hljs-built_in">asString</span>();<br>        m_port = root[<span class="hljs-string">&quot;port&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>        m_user = root[<span class="hljs-string">&quot;userName&quot;</span>].<span class="hljs-built_in">asString</span>();<br>        m_passwd = root[<span class="hljs-string">&quot;password&quot;</span>].<span class="hljs-built_in">asString</span>();<br>        m_dbName = root[<span class="hljs-string">&quot;dbName&quot;</span>].<span class="hljs-built_in">asString</span>();<br>        m_minSize = root[<span class="hljs-string">&quot;minSize&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>        m_maxSize = root[<span class="hljs-string">&quot;maxSize&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>        m_maxIdleTime = root[<span class="hljs-string">&quot;maxIdleTime&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>        m_timeout = root[<span class="hljs-string">&quot;timeout&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 生产连接线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectionPool::produceConnection</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(m_mutexQ)</span></span>; <span class="hljs-comment">// 锁</span><br>        <span class="hljs-keyword">while</span> (m_connectionQ.<span class="hljs-built_in">size</span>() &gt;= m_minSize)<br>        &#123;<br>            m_cond.<span class="hljs-built_in">wait</span>(locker); <span class="hljs-comment">// 条件变量</span><br>        &#125;<br>        <span class="hljs-built_in">addConnection</span>(); <span class="hljs-comment">// 执行连接</span><br>        m_cond.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 通知消费者线程消费</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 销毁连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectionPool::recycleConnection</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));<br>        <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(m_mutexQ)</span></span>;<br>        <span class="hljs-keyword">while</span> (m_connectionQ.<span class="hljs-built_in">size</span>() &gt; m_minSize)<br>        &#123;<br>            MysqlConn* conn = m_connectionQ.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">if</span> (conn-&gt;<span class="hljs-built_in">getAliveTime</span>() &gt;= m_maxIdleTime) <span class="hljs-comment">// 判断连接存活时长，如果满足条件就行删除</span><br>            &#123;<br>                m_connectionQ.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">delete</span> conn;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectionPool::addConnection</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MysqlConn* conn = <span class="hljs-keyword">new</span> MysqlConn;<br>    conn-&gt;<span class="hljs-built_in">connect</span>(m_user, m_passwd, m_dbName, m_ip, m_port);<br>    conn-&gt;<span class="hljs-built_in">refreshAliveTime</span>();<br>    m_connectionQ.<span class="hljs-built_in">push</span>(conn);<br>&#125;<br><br><span class="hljs-comment">// 取出可用连接</span><br><span class="hljs-function">shared_ptr&lt;MysqlConn&gt; <span class="hljs-title">ConnectionPool::getConnection</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(m_mutexQ)</span></span>;<br>    <span class="hljs-keyword">while</span> (m_connectionQ.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">// 判断连接是否为空</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (cv_status::timeout == m_cond.<span class="hljs-built_in">wait_for</span>(locker, chrono::<span class="hljs-built_in">milliseconds</span>(m_timeout)))<span class="hljs-comment">// 阻塞一段时间</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (m_connectionQ.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-comment">//return nullptr;</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// lambda表达式定义shared_ptr的销毁函数。</span><br>    <span class="hljs-function">shared_ptr&lt;MysqlConn&gt; <span class="hljs-title">connptr</span><span class="hljs-params">(m_connectionQ.front(), [<span class="hljs-keyword">this</span>](MysqlConn* conn) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        lock_guard&lt;mutex&gt; locker(m_mutexQ);</span></span><br><span class="hljs-params"><span class="hljs-function">        conn-&gt;refreshAliveTime();</span></span><br><span class="hljs-params"><span class="hljs-function">        m_connectionQ.push(conn);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span></span>;<br>    m_connectionQ.<span class="hljs-built_in">pop</span>();<br>    m_cond.<span class="hljs-built_in">notify_all</span>();<span class="hljs-comment">// 唤醒生产者线程，附带着也会唤醒消费者线程</span><br>    <span class="hljs-keyword">return</span> connptr;<br>&#125;<br><br>ConnectionPool::~<span class="hljs-built_in">ConnectionPool</span>()<br>&#123;<br>    <span class="hljs-keyword">while</span> (!m_connectionQ.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        MysqlConn* conn = m_connectionQ.<span class="hljs-built_in">front</span>();<br>        m_connectionQ.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">delete</span> conn;<br>    &#125;<br>&#125;<br><br>ConnectionPool::<span class="hljs-built_in">ConnectionPool</span>()<br>&#123;<br>    <span class="hljs-comment">// 加载配置文件</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">parseJsonFile</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_minSize; ++i) <span class="hljs-comment">// 默认情况保证有minsize个数的连接就行了。</span><br>    &#123;<br>        <span class="hljs-built_in">addConnection</span>();<br>    &#125;<br>    <span class="hljs-function">thread <span class="hljs-title">producer</span><span class="hljs-params">(&amp;ConnectionPool::produceConnection, <span class="hljs-keyword">this</span>)</span></span>;<span class="hljs-comment">// 生产连接</span><br>    <span class="hljs-function">thread <span class="hljs-title">recycler</span><span class="hljs-params">(&amp;ConnectionPool::recycleConnection, <span class="hljs-keyword">this</span>)</span></span>;<span class="hljs-comment">// 看有没有需要销毁的连接</span><br>    producer.<span class="hljs-built_in">detach</span>();<br>    recycler.<span class="hljs-built_in">detach</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>参考列表：<br><a href="https://www.bilibili.com/video/BV1Fr4y1s7w4">https://www.bilibili.com/video/BV1Fr4y1s7w4</a><br><a href="https://blog.csdn.net/CrankZ/article/details/82874158">https://blog.csdn.net/CrankZ/article/details/82874158</a></p>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现string类</title>
    <link href="/2024/03/26/C++%E5%AE%9E%E7%8E%B0string%E7%B1%BB/"/>
    <url>/2024/03/26/C++%E5%AE%9E%E7%8E%B0string%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实现string类"><a href="#C-实现string类" class="headerlink" title="C++实现string类"></a>C++实现string类</h1><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><h2 id="写一个string类，能够完成string类的操作：1-构造函数，能使用-构造，构造函数传入的参数为const-char-类型2-拷贝构造函数3-析构函数4-operator-5-operator-6-operator-7-operator"><a href="#写一个string类，能够完成string类的操作：1-构造函数，能使用-构造，构造函数传入的参数为const-char-类型2-拷贝构造函数3-析构函数4-operator-5-operator-6-operator-7-operator" class="headerlink" title="写一个string类，能够完成string类的操作：1. 构造函数，能使用&#x3D;构造，构造函数传入的参数为const char* 类型2. 拷贝构造函数3. 析构函数4. operator &#x3D;5. operator +6. operator +&#x3D;7. operator &lt;&lt;8. 从string类型转换成const char*类型，data()方法9. 将string转成int类型10. 统计string的长度，也就是size()方法11. 清空字符串12. 判断字符串是否为空13. 追加append函数，类似于+&#x3D;"></a>写一个string类，能够完成string类的操作：<br>1. 构造函数，能使用&#x3D;构造，构造函数传入的参数为const char* 类型<br>2. 拷贝构造函数<br>3. 析构函数<br>4. operator &#x3D;<br>5. operator +<br>6. operator +&#x3D;<br>7. operator &lt;&lt;<br>8. 从string类型转换成const char*类型，data()方法<br>9. 将string转成int类型<br>10. 统计string的长度，也就是size()方法<br>11. 清空字符串<br>12. 判断字符串是否为空<br>13. 追加append函数，类似于+&#x3D;</h2><h3 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h3><ul><li>char* ptr：指向堆内存空间，从堆内存申请空间。</li><li>int len：记录字符串实际长度，不包含结束符。</li></ul><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>默认构造函数中，为ptr申请一个字节的堆内存，这样任何情况下，ptr都不为nullptr，避免了ptr是否为nullptr的情况，在随时访问的时候，就可以少写很多if判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myString::<span class="hljs-built_in">myString</span>()&#123;<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//为ptr申请一个字节的堆内存</span><br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    len = <span class="hljs-number">0</span>; <span class="hljs-comment">//字符串实际长度为0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="含参构造函数"><a href="#含参构造函数" class="headerlink" title="含参构造函数"></a>含参构造函数</h3><ol><li>传入一个const char* r，让构造函数接受字符串字面量作为参数，因为字符串字面量在C++中是const char[]类型的，自然会转换为const char*类型。</li><li>先为ptr申请字符串r长度+1的内存空间，多一个字节是为了保存结束符’\0’。</li><li>再将r所指的内存空间中的内容，拷贝给ptr所指的内存空间，使用memmove，memmove被用来将字符串从一个内存位置复制到另一个位置。</li><li>在实际的调用中，用一个“&#x3D;”赋值的时候，就会调用含餐构造函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myString::<span class="hljs-built_in">myString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r)&#123;<br><span class="hljs-comment">// 先为ptr申请字符串r长度+1的内存空间，多一个字节是为了保存结束符&#x27;\0&#x27;</span><br>    len = <span class="hljs-built_in">strlen</span>(r);<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 将r所指的内存空间中的内容，拷贝给ptr所指的内存空间，为了避免内存泄漏，使用memmove</span><br>    <span class="hljs-built_in">memmove</span>(ptr,r,len+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ol><li>释放ptr指向的内存空间</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myString::~<span class="hljs-built_in">myString</span>()&#123;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ol><li>因为有指针进行new堆内存操作，需要重写拷贝构造函数进行深拷贝。</li><li>如果不重写拷贝构造函数的话，会调用系统默认的拷贝构造。</li><li>默认的拷贝构造是浅拷贝，在包含堆内存操作的类中，会出现重复释放，造成段错误。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 拷贝构造，深拷贝</span><br>myString::<span class="hljs-built_in">myString</span>(<span class="hljs-type">const</span> myString&amp; r)&#123;<br>    <span class="hljs-comment">//free(ptr);</span><br>    len = r.len;<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<span class="hljs-comment">// 为p的ptr申请独立的空间</span><br><span class="hljs-comment">// 将r中的ptr拷贝给p的ptr</span><br>    <span class="hljs-built_in">memmove</span>(ptr,r.ptr,len+<span class="hljs-number">1</span>); <span class="hljs-comment">// 拷贝数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li>防止自赋值</li><li>注意对原本非空指针的释放</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myString myString::<span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> myString&amp; r)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;r) &#123; <span class="hljs-comment">// 防止自赋值</span><br>        <span class="hljs-keyword">if</span>(ptr != <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-built_in">free</span>(ptr);<br>        len = r.len;<br>        ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memset</span>(ptr, <span class="hljs-number">0</span>, len+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memmove</span>(ptr, r.ptr, len+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 应该返回对象的引用</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加号运算符和-运算符"><a href="#加号运算符和-运算符" class="headerlink" title="加号运算符和+&#x3D;运算符"></a>加号运算符和+&#x3D;运算符</h3><ul><li>p1 &#x3D; p1+”hello”</li><li>p1 &#x3D; p1+p2; 两种都有可能，要写全参数类型</li><li>+&#x3D;运算符和+类似</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// p1 = p1+&quot;hello&quot;;</span><br>myString myString::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r)&#123;<br>    <span class="hljs-comment">// 创建新的对象，新对象的长度以及ptr指向内存空间是this+r的总和</span><br>    myString newStr;<br>    <span class="hljs-built_in">free</span>(newStr.ptr); <span class="hljs-comment">//这里要把newStr.ptr指向的内存进行释放，否则会出现内存泄漏</span><br>    newStr.len = <span class="hljs-keyword">this</span>-&gt;len+<span class="hljs-built_in">strlen</span>(r);<br>    newStr.ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(newStr.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(newStr.ptr,<span class="hljs-number">0</span>,newStr.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(newStr.ptr,ptr,len);<br>    <span class="hljs-built_in">strcat</span>(newStr.ptr,r);<br>    <span class="hljs-keyword">return</span> newStr;<br>&#125;<br><br><span class="hljs-comment">// p1 = p1+p2</span><br>myString myString::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> myString&amp; r)&#123;<br>    myString newStr;<br>    <span class="hljs-built_in">free</span>(newStr.ptr); <span class="hljs-comment">//这里要把newStr.ptr指向的内存进行释放，否则会出现内存泄漏</span><br>    newStr.len = <span class="hljs-keyword">this</span>-&gt;len+r.len;<br>    newStr.ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(newStr.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(newStr.ptr,<span class="hljs-number">0</span>,newStr.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(newStr.ptr,ptr,len);<br>    <span class="hljs-built_in">strcat</span>(newStr.ptr,r.ptr);<br>    <span class="hljs-keyword">return</span> newStr;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myString myString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r)&#123;<br>    <span class="hljs-type">char</span>* temp = ptr;<br>    <span class="hljs-type">int</span> l = len; <span class="hljs-comment">// 保存原来的ptr和len</span><br>    <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-keyword">this</span>-&gt;len+<span class="hljs-built_in">strlen</span>(r);<br>    <span class="hljs-keyword">this</span>-&gt;ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">this</span>-&gt;len+<span class="hljs-number">1</span>); <span class="hljs-comment">//ptr指向新的内存空间</span><br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(ptr,temp,l); <span class="hljs-comment">// 把原来的ptr内容拷贝给新的ptr</span><br>    <span class="hljs-built_in">strcat</span>(ptr,r);<br>    <span class="hljs-built_in">free</span>(temp);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br>myString myString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> myString&amp; r)&#123;<br>    <span class="hljs-type">char</span>* temp = ptr;<br>    <span class="hljs-type">int</span> l = len;<br>    len = len+r.len;<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(ptr,temp,l);<br>    <span class="hljs-built_in">strcat</span>(ptr,r.ptr);<br>    <span class="hljs-built_in">free</span>(temp); <span class="hljs-comment">//temp记得free</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当myString对象没有保存任何字符串的时候，应该至少为该对象中的ptr申请至少一个字节的空间</span><br><span class="hljs-comment"> * 这样任何情况下，ptr都不为nullptr，避免了ptr是否为nullptr的情况，在随时访问的时候，</span><br><span class="hljs-comment"> * 就可以少写很多if判断。</span><br><span class="hljs-comment"> *  · 无参构造函数要重写。</span><br><span class="hljs-comment"> *  · 因为有指针进行new堆内存操作，默认的拷贝构造是浅拷贝，需要重写拷贝构造，否则会出现重复释放，造成段错误。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myString</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">myString</span>(); <span class="hljs-comment">//无参构造函数</span><br>    <span class="hljs-built_in">myString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r); <span class="hljs-comment">//单参构造函数</span><br>    <span class="hljs-built_in">myString</span>(<span class="hljs-type">const</span> myString&amp; r); <span class="hljs-comment">//单参构造函数</span><br>    ~<span class="hljs-built_in">myString</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;ptr&lt;&lt;endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> len;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;<br>    myString <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> myString&amp; r);<br>    myString <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r);<br>    myString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> myString&amp; r);<br>    myString <span class="hljs-keyword">operator</span>+= (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r);<br>    myString <span class="hljs-keyword">operator</span>+= (<span class="hljs-type">const</span> myString&amp; r);<br>    <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n);<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> myString&amp; r)</span></span>;<br><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (std::ostream&amp; out, <span class="hljs-type">const</span> myString&amp; r);<br>    <span class="hljs-keyword">friend</span> std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt; (std::ostream&amp; in, myString&amp; r);<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">data</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;ptr;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">toInt</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* ptr; <span class="hljs-comment">//指向堆内存空间</span><br>    <span class="hljs-type">int</span> len; <span class="hljs-comment">// 字符串实际长度，不包含结束符</span><br>&#125;;<br><br>myString::<span class="hljs-built_in">myString</span>()&#123;<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//为ptr申请一个字节的堆内存</span><br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    len = <span class="hljs-number">0</span>;<br>&#125;<br><br>myString::<span class="hljs-built_in">myString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r)&#123;<br><span class="hljs-comment">// 先为ptr申请字符串r长度+1的内存空间，多一个字节是为了保存结束符&#x27;\0&#x27;</span><br>    len = <span class="hljs-built_in">strlen</span>(r);<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 将r所指的内存空间中的内容，拷贝给ptr所指的内存空间，为了避免内存泄漏，使用memmove</span><br>    <span class="hljs-built_in">memmove</span>(ptr,r,len+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 拷贝构造，深拷贝</span><br>myString::<span class="hljs-built_in">myString</span>(<span class="hljs-type">const</span> myString&amp; r)&#123;<br>    len = r.len;<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<span class="hljs-comment">// 为p的ptr申请独立的空间</span><br><span class="hljs-comment">// 将r中的ptr拷贝给p的ptr</span><br>    <span class="hljs-built_in">memmove</span>(ptr,r.ptr,len+<span class="hljs-number">1</span>); <span class="hljs-comment">// 拷贝数据</span><br>&#125;<br><br>myString::~<span class="hljs-built_in">myString</span>()&#123;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myString::clear</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">free</span>(ptr);<br>    ptr=(<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    len = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myString::empty</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> !len;<br>&#125;<br><br>myString myString::<span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> myString&amp; r)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;r) &#123; <span class="hljs-comment">// 防止自赋值</span><br>        <span class="hljs-keyword">if</span>(ptr != <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-built_in">free</span>(ptr);<br>        len = r.len;<br>        ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memset</span>(ptr, <span class="hljs-number">0</span>, len+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memmove</span>(ptr, r.ptr, len+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 应该返回对象的引用。</span><br>&#125;<br><br><span class="hljs-comment">// p1 = p1+&quot;hello&quot;;</span><br>myString myString::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r)&#123;<br>    <span class="hljs-comment">// 创建新的对象，新对象的长度以及ptr指向内存空间是this+r的总和</span><br>    myString newStr;<br>    <span class="hljs-built_in">free</span>(newStr.ptr); <span class="hljs-comment">//这里要把newStr.ptr指向的内存进行释放，否则会出现内存泄漏</span><br>    newStr.len = <span class="hljs-keyword">this</span>-&gt;len+<span class="hljs-built_in">strlen</span>(r);<br>    newStr.ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(newStr.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(newStr.ptr,<span class="hljs-number">0</span>,newStr.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(newStr.ptr,ptr,len);<br>    <span class="hljs-built_in">strcat</span>(newStr.ptr,r);<br>    <span class="hljs-keyword">return</span> newStr;<br>&#125;<br><br><span class="hljs-comment">// p1 = p1+p2</span><br>myString myString::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> myString&amp; r)&#123;<br>    myString newStr;<br>    <span class="hljs-built_in">free</span>(newStr.ptr); <span class="hljs-comment">//这里要把newStr.ptr指向的内存进行释放，否则会出现内存泄漏</span><br>    newStr.len = <span class="hljs-keyword">this</span>-&gt;len+r.len;<br>    newStr.ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(newStr.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(newStr.ptr,<span class="hljs-number">0</span>,newStr.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(newStr.ptr,ptr,len);<br>    <span class="hljs-built_in">strcat</span>(newStr.ptr,r.ptr);<br>    <span class="hljs-keyword">return</span> newStr;<br>&#125;<br><br>myString myString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r)&#123;<br>    <span class="hljs-type">char</span>* temp = ptr;<br>    <span class="hljs-type">int</span> l = len; <span class="hljs-comment">// 保存原来的ptr和len</span><br>    <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-keyword">this</span>-&gt;len+<span class="hljs-built_in">strlen</span>(r);<br>    <span class="hljs-keyword">this</span>-&gt;ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">this</span>-&gt;len+<span class="hljs-number">1</span>); <span class="hljs-comment">//ptr指向新的内存空间</span><br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(ptr,temp,l); <span class="hljs-comment">// 把原来的ptr内容拷贝给新的ptr</span><br>    <span class="hljs-built_in">strcat</span>(ptr,r);<br>    <span class="hljs-built_in">free</span>(temp);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br>myString myString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> myString&amp; r)&#123;<br>    <span class="hljs-type">char</span>* temp = ptr;<br>    <span class="hljs-type">int</span> l = len;<br>    len = len+r.len;<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(ptr,temp,l);<br>    <span class="hljs-built_in">strcat</span>(ptr,r.ptr);<br>    <span class="hljs-built_in">free</span>(temp); <span class="hljs-comment">//temp记得free</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-type">char</span> myString::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n)&#123;<br>    <span class="hljs-keyword">return</span> ptr[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myString::append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* r)</span></span>&#123;<br>    <span class="hljs-type">char</span>* temp = ptr;<br>    <span class="hljs-type">int</span> l = len; <span class="hljs-comment">// 保存原来的ptr和len</span><br>    <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-keyword">this</span>-&gt;len+<span class="hljs-built_in">strlen</span>(r);<br>    <span class="hljs-keyword">this</span>-&gt;ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">this</span>-&gt;len+<span class="hljs-number">1</span>); <span class="hljs-comment">//ptr指向新的内存空间</span><br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(ptr,temp,l); <span class="hljs-comment">// 把原来的ptr内容拷贝给新的ptr</span><br>    <span class="hljs-built_in">strcat</span>(ptr,r);<br>    <span class="hljs-built_in">free</span>(temp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myString::append</span><span class="hljs-params">(<span class="hljs-type">const</span> myString&amp; r)</span></span>&#123;<br>    <span class="hljs-type">char</span>* temp = <span class="hljs-keyword">this</span>-&gt;ptr;<br>    <span class="hljs-type">int</span> l = len;<br>    len = len+r.len;<br>    ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(ptr,temp,l);<br>    <span class="hljs-built_in">strcat</span>(ptr,r.ptr);<br>    <span class="hljs-built_in">free</span>(temp); <span class="hljs-comment">//temp记得free</span><br>&#125;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (std::ostream&amp; out, <span class="hljs-type">const</span> myString&amp; r)&#123;<br>    out&lt;&lt;r.ptr;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br>std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt; (std::ostream&amp; in, myString&amp; r)&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    std::cin&gt;&gt;buf;<br>    <span class="hljs-built_in">free</span>(r.ptr);<br>    r.len = <span class="hljs-built_in">strlen</span>(buf);<br>    r.ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(r.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(r.ptr,<span class="hljs-number">0</span>,r.len+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memmove</span>(r.ptr,buf,r.len+<span class="hljs-number">1</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myString::toInt</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">atoi</span>(<span class="hljs-keyword">this</span>-&gt;ptr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    myString str = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// 转换构造函数，也就是单参构造函数</span><br>    <span class="hljs-function">myString <span class="hljs-title">ptr</span><span class="hljs-params">(str)</span></span>; <span class="hljs-comment">// 拷贝构造</span><br>    myString atp = str; <span class="hljs-comment">//拷贝构造</span><br>    ptr = str; <span class="hljs-comment">//运算符 operator=</span><br>    ptr = ptr + <span class="hljs-string">&quot; world&quot;</span>;<br>    ptr.<span class="hljs-built_in">show</span>(); <br>    myString str2 = <span class="hljs-string">&quot; world&quot;</span>;<br>    str2 = str+str2;<br>    str += <span class="hljs-string">&quot; world&quot;</span>;<br>    str.<span class="hljs-built_in">show</span>();<br>    ptr+=str2;<br>    ptr.<span class="hljs-built_in">show</span>();<br>    atp.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; world&quot;</span>);<br>    atp.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++学习</title>
    <link href="/2024/03/26/Effective%20C++%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/26/Effective%20C++%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Effective-C-学习"><a href="#Effective-C-学习" class="headerlink" title="Effective C++学习"></a>Effective C++学习</h2><h3 id="尽量用const-enum-inline-替换-define"><a href="#尽量用const-enum-inline-替换-define" class="headerlink" title="尽量用const, enum, inline 替换#define"></a>尽量用const, enum, inline 替换#define</h3><ol><li>define只在预处理阶段起作用，简单的文本替换，因为在预处理阶段就已经做了替换，发生错误的时候，报错信息不好找。</li><li>可以用const来代替宏定义，const在编译、链接过程中起作用；</li><li>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</li><li><code>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</code></li><li>define预处理后，占用代码段空间，const占用数据段空间；</li><li>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</li><li>define独特功能，比如可以用来防止文件重复引用。</li></ol><p><code>C++里有一个特殊的：类中的静态数据，在类中声明，在类外定义，其中整数可以不定义就使用。</code></p><p><code>enum可以替换const和define，优雅的实现一个常量的设置。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">enum</span>&#123;NumTurns =<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> scores[NumTurns]; <span class="hljs-comment">//constant</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTurns</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> NumTurns;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>使用inline函数，替换宏定义函数</code></p><ul><li>#define是关键字，inline是函数；</li><li>宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</li><li>inline函数有类型检查，相比宏定义比较安全；</li></ul><p>#define 更容易出错。inline可以获得宏的所有效率，也可以获得类型安全。</p><h3 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h3><p>const出现在* 左侧，指向的是常量，<br>const出现在* 右侧，指针本身是常量。<br>顶层const：指的是const修饰的变量本身是一个常量，星号右边。<br>底层const：指的是const修饰的变量所指向的对象是一个常量，星号左边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> b1 = &amp;a;    <span class="hljs-comment">//顶层const，b1本身是一个常量。指针常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* b2 = &amp;a;    <span class="hljs-comment">//底层const，b2本身可变，所指的对象是常量。常量指针</span><br></code></pre></td></tr></table></figure><p><code>STL中迭代器以指针为模型。</code><br>const可以使代码变得更加健壮，确保哪些东西可以修改，哪些东西不可以修改。const还可以定义不同的函数重载。</p><h3 id="确认对象在使用前就已经被初始化"><a href="#确认对象在使用前就已经被初始化" class="headerlink" title="确认对象在使用前就已经被初始化"></a>确认对象在使用前就已经被初始化</h3><p>内置类型如int,string等在默认构造函数进入构造函数体之前就已经完成了初始化，构造函数体中是在进行赋值，一般采用列表初始化的方法，直接进行初始化，直接调用拷贝构造方法，效率更高一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>():<span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>)&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>C++中不同编译单元中定义的非局部静态对象的初始化顺序是不固定的。所以定义的时候，最好将非局部静态对象定义为局部静态对象。</code></li></ul><h3 id="构造，析构，赋值运算，拷贝构造"><a href="#构造，析构，赋值运算，拷贝构造" class="headerlink" title="构造，析构，赋值运算，拷贝构造"></a>构造，析构，赋值运算，拷贝构造</h3><ul><li>如果不自己声明任何函数，编译器会生成默认构造，拷贝构造，赋值运算符和析构函数，也不是任何时候都生成，需要用到才会生成。</li><li>如果定义了构造函数，编译器就不会再生成默认构造函数</li><li>如果类中的数据成员为static或者引用，编译器就会拒绝自动生成赋值运算符操作。</li><li>如果基类的拷贝赋值运算符为private，派生类将无法生成拷贝赋值运算符，无法处理基类部分。</li><li>如果不想编译器自动生成函数，就该明确拒绝。<ul><li>解法一：将拷贝构造和拷贝赋值运算符都设置为private，只给声明，不写定义，编译的时候没问题，链接的时候会出问题。</li><li>解法一更进一步：定义一个基类，以后定义的类继承自这个基类，就没有办法拷贝构造和赋值运算。</li><li>解法二：C++11 直接调用delete。</li></ul></li></ul><p><code>拷贝构造函数：</code></p><ul><li>当编写一个copy或者拷贝构造函数，应该确保复制成员里面的所有变量，以及所有基类的成员</li><li>不要尝试用一个拷贝构造函数调用另一个拷贝构造函数，如果想要精简代码的话，应该把所有的功能机能放到第三个函数里面，并且由两个拷贝构造函数共同调用</li><li>当新增加一个变量或者继承一个类的时候，很容易出现忘记拷贝构造的情况，所以每增加一个变量都需要在拷贝构造里面修改对应的方法。</li></ul><h3 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h3><ul><li>类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而<code>派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</code></li><li><code>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</code></li></ul><p><code>如果类不会成为基类，也不要刻意的去写上virtual的析构函数，会引入虚表指针，占据额外的空间。</code></p><p>标准库的string类型不含虚函数，将string作为基类的话，有可能会出现内存泄漏。</p><p>想创建一个抽象类，但是没有任何纯虚函数，怎么办？<code>声明纯虚析构函数。</code></p><h3 id="不要让析构函数抛出异常"><a href="#不要让析构函数抛出异常" class="headerlink" title="不要让析构函数抛出异常"></a>不要让析构函数抛出异常</h3><ol><li>再封装一层中间层，下层抛出异常的话，在这一层捕捉。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConnection</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> DBConnection <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">DBConn</span>()&#123;<br>        <span class="hljs-comment">// db.close();</span><br>        <span class="hljs-comment">// 方案1</span><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            db.<span class="hljs-built_in">close</span>();<br>        &#125;<br>        <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::exception&amp; e)<br>        &#123;<br>            std::<span class="hljs-built_in">abort</span>();<br>            <span class="hljs-comment">// 或者记录下异常</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    DBConnection db;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>重新设计接口，使其客户有机会对可能出现的问题作出反应。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-comment">//给客户使用的</span></span><br><span class="hljs-function">    </span>&#123;<br>        db.<span class="hljs-built_in">close</span>();<br>        closed = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">DBConn</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!closed)<br>        &#123;<br>            <span class="hljs-keyword">try</span> <span class="hljs-comment">//如果客户没关闭，再关闭 双保险</span><br>            &#123;<br>                db.<span class="hljs-built_in">close</span>();<br>            &#125;<br>            <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>            &#123;<br>                std::<span class="hljs-built_in">abort</span>();<br>                <span class="hljs-comment">// 或者记录下异常</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    DBConnection db;<br>    <span class="hljs-type">bool</span> closed;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>如果某个操作可能在失败时抛出异常，又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数</code><br>析构函数不要抛出异常，因该在内部捕捉异常。如果客户需要对某个操作抛出的异常做出反应，应该将这个操作放到普通函数（而不是析构函数）里面</p><h3 id="不在构造和析构过程中调用virtual函数"><a href="#不在构造和析构过程中调用virtual函数" class="headerlink" title="不在构造和析构过程中调用virtual函数"></a>不在构造和析构过程中调用virtual函数</h3><p>如果在构造函数中执行virtual函数，派生类对象的基类部分，会首先构造，构造基类时，虚函数永远不会进入派生类。所以要避免这种情况。</p><ul><li>如果在父类的构造函数中，调用子类的虚函数，是没有办法做到的。</li><li>如果在父类的析构函数中，调用子类的析构函数，也是没有办法的。</li></ul><h3 id="令operator-返回一个指向-this的引用"><a href="#令operator-返回一个指向-this的引用" class="headerlink" title="令operator&#x3D; 返回一个指向 *this的引用"></a>令operator&#x3D; 返回一个指向 *this的引用</h3><p>该约定主要是为了支持连读和连写，这个操作同样适用于-&#x3D;,+&#x3D;,*&#x3D;等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp;rhs)&#123; <span class="hljs-comment">//返回的是当前类的一个引用。</span><br>        <span class="hljs-comment">//..</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>    &#125;<br>    A&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> A&amp;rhs)&#123; <span class="hljs-comment">//返回的是当前类的一个引用。</span><br>        <span class="hljs-comment">//..</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="在operator-中处理“自我赋值”"><a href="#在operator-中处理“自我赋值”" class="headerlink" title="在operator&#x3D; 中处理“自我赋值”"></a>在operator&#x3D; 中处理“自我赋值”</h3><p> 主要是要处理 a[i] &#x3D; a[j] 或者 *px &#x3D; *py这样的自我赋值。有可能会出现一场安全性问题，或者在使用之前就销毁了原来的对象，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span>&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    Bitmap *pb;<br>&#125;;<br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb; <span class="hljs-comment">// 当this和rhs是同一个对象的时候，就相当于直接把rhs的bitmap也销毁掉了</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; rhs)</span></span>;    <span class="hljs-comment">//交换this和rhs的数据</span><br>&#125;;<br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    Widget <span class="hljs-built_in">temp</span>(rhs)           <span class="hljs-comment">//为rhs数据制作一个副本</span><br>    <span class="hljs-built_in">swap</span>(temp);                <span class="hljs-comment">//将this数据和上述副本数据交换</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<span class="hljs-comment">//出了作用域，原来的副本销毁</span><br></code></pre></td></tr></table></figure><h3 id="以对象管理资源-COPY-提供对原始资源的访问"><a href="#以对象管理资源-COPY-提供对原始资源的访问" class="headerlink" title="以对象管理资源&#x2F;COPY&#x2F;提供对原始资源的访问"></a>以对象管理资源&#x2F;COPY&#x2F;提供对原始资源的访问</h3><p><code>为了防止在delete语句执行前return，所以需要用对象来管理这些资源。这样当控制流离开f以后，该对象的析构函数会自动释放那些资源。</code></p><ul><li>将资源放进智能指针，如shared_ptr或unique_ptr对象包装中，函数体结束以后，资源就会自动释放，调用析构函数。尽量使用shared_ptr，行为更加符合逻辑一些。</li><li>为了防止资源泄露，使用RAII对象，在构造函数中获得资源并在析构函数中释放资源。</li></ul><p><code>在资源管理类里面，如果出现了拷贝复制行为的话，需要注意这个复制具体的含义，从而保证和我们想要的效果一样</code><br>下面的代码会对锁进行拷贝，但是并没有达到想要的独立类对象的需求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span>:mutexPtr(pm)&#123;</span><br>        <span class="hljs-built_in">lock</span>(mutexPtr);<span class="hljs-comment">//获得资源锁</span><br>    &#125;<br>    ~<span class="hljs-built_in">Lock</span>()&#123;<span class="hljs-built_in">unlock</span>(mutexPtr);&#125;<span class="hljs-comment">//释放资源锁</span><br><span class="hljs-keyword">private</span>:<br>    Mutex *mutexPtr;<br>&#125;<br><span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;m)</span><span class="hljs-comment">//锁定m</span></span><br><span class="hljs-function">Lock <span class="hljs-title">m2</span><span class="hljs-params">(m1)</span></span>;<br><span class="hljs-comment">//好像是锁定m1这个锁。。而我们想要的是除了复制资源管理对象以外，还想复制它所包括的资源（deep copy）。通过使用shared_ptr可以有效避免这种情况。</span><br></code></pre></td></tr></table></figure><ul><li>要么禁止拷贝复制</li><li>要么用引用计数，添加智能指针。可以作为删除器来使用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* pm)</span>:mutexPtr(pm,unlock)&#123;</span> <span class="hljs-comment">//用互斥量和unlock函数初始化shared_ptr</span><br>        <span class="hljs-built_in">lock</span>(mutexPtr.<span class="hljs-built_in">get</span>());<span class="hljs-comment">//作为删除器</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;Mutex&gt; mutexPtr;<span class="hljs-comment">//获取普通指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="用独立语句将new的对象置入智能指针"><a href="#用独立语句将new的对象置入智能指针" class="headerlink" title="用独立语句将new的对象置入智能指针"></a>用独立语句将new的对象置入智能指针</h3><p>主要是为了防止内存泄漏<br>考虑以下场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">priority</span>()) <span class="hljs-comment">// 可能会造成内存泄漏</span><br></code></pre></td></tr></table></figure><p>内存泄漏的原因为：先执行new Widget，再调用priority， 最后执行shared_ptr构造函数，那么当priority的调用发生异常的时候，new Widget返回的指针就会丢失了。当然不同编译器对上面这个代码的执行顺序不一样。所以安全的做法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span><br><span class="hljs-function"><span class="hljs-title">processWidget</span><span class="hljs-params">(pw, priority())</span></span><br></code></pre></td></tr></table></figure><p>这就是用独立语句将new的对象置入智能指针。<code>凡是有new语句的，尽量放在单独的语句当中，特别是当使用new出来的对象放到智能指针里面的时候</code></p><h3 id="写更加容易被正确使用的接口"><a href="#写更加容易被正确使用的接口" class="headerlink" title="写更加容易被正确使用的接口"></a>写更加容易被正确使用的接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> year);<br></code></pre></td></tr></table></figure><p>这一段代码可以有很多问题，例如用户将day和month顺序写反（因为三个参数都是int类型的），可以修改成：<br>Date(const Month &amp;m, const Day &amp;d, const Year &amp;y);&#x2F;&#x2F;注意这里将每一个类型的数据单独设计成一个类，同时加上const限定符，为了让接口更加易用，可以对month加以限制，只有12个月份</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Month</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Jan</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//这里用函数代替对象，主要是方式第四条：non-local static对象的初始化顺序问题</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>对于一些返回指针的问题函数，例如：Investment *createInvestment(); 可以设计成返回类型为智能指针类型：std::shared_ptr&lt;Investment&gt; createInvestment();</code></p><h3 id="以pass-by-reference-to-const替换pass-by-value"><a href="#以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="以pass-by-reference-to-const替换pass-by-value"></a>以pass-by-reference-to-const替换pass-by-value</h3><p>有些传递参数的时候用引用和cosnt结合的操作，可以降低很多的构造和析构函数调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student &amp;s)</span></span>;<span class="hljs-comment">//省了很多构造析构拷贝赋值操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(s)</span></span>;<br><br>subStudent s;<br><span class="hljs-built_in">validateStudent</span>(s);<span class="hljs-comment">//调用后,则在validateStudent函数内部实际上是一个student类型，如果有重载操作的话会出现问题</span><br></code></pre></td></tr></table></figure><p><code>对于内置类型和stl标准库中的迭代器和函数对象，pass-by-value更加合适</code></p><p><code>必须返回对象时，别妄想返回其reference，因为很容易返回一个被删除的局部变量，就算是没被删除，在外部也不好释放堆内存</code></p><h3 id="以non-member、non-friend替换member函数"><a href="#以non-member、non-friend替换member函数" class="headerlink" title="以non-member、non-friend替换member函数"></a>以non-member、non-friend替换member函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br>member 函数：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    ......<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">clearCache</span>(); <span class="hljs-built_in">clearHistory</span>();<span class="hljs-built_in">removeCookies</span>();&#125;<br>&#125;<br><br>non-member non-<span class="hljs-keyword">friend</span>函数：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>&#123;<br>    wb.<span class="hljs-built_in">clearCache</span>();<br>    wb.<span class="hljs-built_in">clearHistory</span>();<br>    wb.<span class="hljs-built_in">removeCookies</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>member可以访问class的private函数，enums，typedefs等，但是non-member函数则无法访问上面这些东西，所以non-member non-friend函数更好。</li><li>熟悉namespace用法：namespace可以用来对某些便利函数进行分割，将同一个命名空间中的不同类型的方法放到不同文件中，C++标准库就是这么用的。</li></ul><h3 id="若所有参数皆需类型转换，请为此采用non-member函数"><a href="#若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数皆需类型转换，请为此采用non-member函数"></a>若所有参数皆需类型转换，请为此采用non-member函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational&amp; rhs)<span class="hljs-type">const</span>;<br>&#125;<br>Rational oneHalf;<br>result = oneHalf * <span class="hljs-number">2</span>;<br>result = <span class="hljs-number">2</span> * oneHalf;<span class="hljs-comment">//出错，因为没有int转Rational函数</span><br><br>non-member函数<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;&#125;<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>()*rhs.<span class="hljs-built_in">numerator</span>(), lhs.<span class="hljs-built_in">denominator</span>()* rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br>result = <span class="hljs-number">2</span> * oneHalf; <span class="hljs-comment">//不会出错</span><br></code></pre></td></tr></table></figure><p>member函数中，无法解析2导致编译出错，non-member函数重新定义，就可以对2进行编译。</p><h3 id="尽量不要进行强制类型转换"><a href="#尽量不要进行强制类型转换" class="headerlink" title="尽量不要进行强制类型转换"></a>尽量不要进行强制类型转换</h3><ul><li>尽可能延后变量定义式的出现时间：主要是防止变量在定义以后没有使用，影响效率，应该在用到的时候再定义，同时通过default构造而不是赋值来初始化。</li></ul><p>尽量不要进行强制类型转换：</p><ul><li>double转int会丢失精度。</li><li>将一个类转换成他的父类也容易出现问题</li></ul><p>C++的四种新型类型转换：<code>应优先使用 static_cast。如果需要处理多态性，使用 dynamic_cast。只有在特殊情况下，当其他转换不适用时，才考虑使用 const_cast 或 reinterpret_cast。</code></p><ol><li>static_cast：<code>它可以在相关类型之间进行转换，例如将浮点数转换为整数，或将派生类的指针转换为基类的指针。</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">float</span> f = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(i); <span class="hljs-comment">// 将int转换为float</span><br></code></pre></td></tr></table></figure></li><li>dynamic_cast ：<code>主要用于处理多态。</code>它在运行时执行安全的向下转换（由基类指针转换为派生类指针）。如果转换失败（即如果指针不实际指向派生类对象），则返回 nullptr。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base* b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>Derived* d = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="hljs-comment">// 安全的向下转换</span><br></code></pre></td></tr></table></figure></li><li>const_cast：<code>用来移除或添加 const（或 volatile）属性。它通常用于指针或引用，允许修改被 const 修饰的变量。</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* modifiable = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;ci); <span class="hljs-comment">// 移除const属性</span><br></code></pre></td></tr></table></figure></li><li>reinterpret_cast：提供了低级别的强制转换，它可以将任意指针类型转换为另一个指针类型，甚至可以转换为足够大的整数类型。这种转换不做任何类型检查，因此可能导致不安全的行为。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span>* ip = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(p); <span class="hljs-comment">// 将void*转换为int*</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="异常安全的考虑"><a href="#异常安全的考虑" class="headerlink" title="异常安全的考虑"></a>异常安全的考虑</h3><ul><li>尽量不要返回指向private变量的指针引用等，如果真的要用，尽量使用const进行限制，同时尽量避免悬吊的可能性。</li><li>函数提供的异常安全保证，通常最高只等于其所调用各个函数的“异常安全保证”中最弱的那个。即函数的异常安全保证具有连带性</li></ul><h3 id="不要过度使用inline"><a href="#不要过度使用inline" class="headerlink" title="不要过度使用inline"></a>不要过度使用inline</h3><ul><li><code>关键字 inline 建议编译器使用函数定义中的代码替换对该函数的每次调用。</code></li><li><code>理论上，使用内联函数可以加速程序运行，因为它们消除了与函数调用关联的开销。 调用函数需要将返回地址推送到堆栈、将参数推送到堆栈、跳转到函数体，然后在函数完成时执行返回指令。 通过内联函数可以消除此过程。 相对于未内联扩展的函数，编译器还有其他机会来优化内联扩展的函数。 </code></li><li>内联函数的一个缺点是程序的整体大小可能会增加。</li><li>内联代码替换操作由编译器自行决定。 例如，如果某个函数的地址已被占用或编译器判定函数过大，则编译器不会内联该函数。</li><li><code>inline 函数的过度使用会让程序的体积变大，内存占用过高</code></li><li>编译器是可以拒绝将函数inline的，不过当编译器不知道该调用哪个函数的时候，会报一个warning。</li><li>尽量不要为template或者构造函数设置成inline的，因为template inline以后有可能为每一个模板都生成对应的函数，从而让代码过于臃肿 同样的道理，构造函数在实际的过程中也会产生很多的代码.</li></ul><h3 id="降低文件间编译的依存关系"><a href="#降低文件间编译的依存关系" class="headerlink" title="降低文件间编译的依存关系"></a>降低文件间编译的依存关系</h3><p>当有代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;address.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">private</span><br>    Dates m_data;<span class="hljs-comment">//Dates类</span><br>    Addresses m_addr;<span class="hljs-comment">//Addresses类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种代码情况下，Person和Dates以及Addresses文件之间，形成了编译依存关系。如果这些头文件有任何一个改变，或者这些头文件所依赖的其他头文件有所改变，那么含Person class的文件就得重新编译。<code>程序头文件应该有且仅有声明</code><br>如何实现解耦？</p><ul><li>定义一个接口类Impl：接口类与具体细目结合，用“声明的依存性”替换“定义的依存性”。</li><li>或者定义一个全虚函数：然后通过继承的子类来实现相关的方法。这种情况下这些virtual函数通常被成为factory工厂函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">原代码：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">private</span><br>    Dates m_data;<br>    Addresses m_addr;<br>&#125;<br><br>添加一个Person的实现类，定义为PersonImpl，修改后的代码：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">全虚函数<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些需要在继承时注意的"><a href="#一些需要在继承时注意的" class="headerlink" title="一些需要在继承时注意的"></a>一些需要在继承时注意的</h3><ul><li>保证继承逻辑正确性，企鹅不是鸟类。</li><li>避免遮掩继承而来的名称：如果继承base类并加上重载函数，而且又希望重新定义或覆写其中的一部分，那么需要加载一个using声明，否则会有些继承函数被覆盖。<br><img src="https://pic.imgdb.cn/item/66040d299f345e8d03b0349d.png" alt="在这里插入图片描述"><br><img src="https://pic.imgdb.cn/item/66040d3f9f345e8d03b0f941.png" alt="在这里插入图片描述"></li><li>pure virtual 函数式提供了一个接口继承，当一个函数式pure virtual的时候，意味着所有的实现都在子类里面实现。不过pure virtual也是可以有实现的，调用他的方法是在调用前加上基类的名称ps-&gt;Shape::draw();</li><li>接口继承和实现继承不同，在public继承下，derived classes总是继承base的接口。</li><li>pure virtual函数只具体指定接口继承。</li><li>（非纯）impure virtual函数具体指定接口继承以及缺省实现继承。</li><li>non-virtual函数具体指定接口继承以及强制性的实现继承</li></ul><h3 id="考虑virtual函数以外的其他选择"><a href="#考虑virtual函数以外的其他选择" class="headerlink" title="考虑virtual函数以外的其他选择"></a>考虑virtual函数以外的其他选择</h3><ul><li><code>模板方法模式：NVI手法：通过public non-virtual成员函数间接调用private virtual函数，即所谓的template method设计模式：这种方法的优点在于事前工作和事后工作，这些工作能够保证virtual函数在真正工作之前之后被单独调用</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-comment">//做一些事前工作</span><br>        <span class="hljs-type">int</span> retVal = <span class="hljs-built_in">doHealthValue</span>();<br>        <span class="hljs-comment">//做一些事后工作</span><br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">doHealthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        ...                   <span class="hljs-comment">//缺省算法，计算健康函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>函数指针（strategy设计模式：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>; <span class="hljs-comment">// 前置声明</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter&amp; gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*HealthCalcFunc)</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter&amp;)</span></span>;<span class="hljs-comment">//函数指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCHaracter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span>:healthFunc(hcf)&#123;</span>&#125;<span class="hljs-comment">//可以换一个函数的</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);&#125;<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>不要重新定义继承而来的non-virtual函数</code></li><li><code>绝不重新定义继承而来的缺省参数值</code>：virtual函数是动态绑定，但是缺省参数值是静态绑定。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red, Green, Blue&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color=Red)</span><span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color=Green)</span><span class="hljs-type">const</span></span>;<span class="hljs-comment">//和父类的默认参数不同</span><br>&#125;<br>Shape* pr = <span class="hljs-keyword">new</span> Rectangle; <span class="hljs-comment">// 注意此时pr的静态类型是Shape，但是他的动态类型是Rectangle</span><br>pr-&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">//virtual函数是动态绑定，而缺省参数值是静态绑定，所以会调用Red</span><br></code></pre></td></tr></table></figure><h3 id="复合类"><a href="#复合类" class="headerlink" title="复合类"></a>复合类</h3><ul><li>复合是一种类型之间的关系，当某种类型的对象内含有其他类型的对象时，就是复合关系。</li><li>比如一个Person类，包含一个Address对象，一个PhoneNumber对象。</li><li>set并不是一个list，但是set可以has a list：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//.......</span><br><span class="hljs-keyword">private</span>:<br>    std::list&lt;T&gt; rep;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="private继承和多重继承"><a href="#private继承和多重继承" class="headerlink" title="private继承和多重继承"></a>private继承和多重继承</h3><ul><li>因为private继承只是一种实现上的继承，不包含接口继承，即有一部分父类的private成员是子类无法访问的，而且经过private继承以后，子类的所有成员都是private的。</li><li>private继承通常比复合的级别低，但是<code>当derived class 需要访问protect base class 的成员，或者需要重新定义继承而来的virtual函数时</code>，这么设计是合理的。</li></ul><p>多重继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowableItem</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkOut</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectronicGadget</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkOut</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MP3Player</span>:<span class="hljs-keyword">public</span> BorrowableItem, <span class="hljs-keyword">public</span> ElectronicGadget&#123;...&#125;;<br>MP3Player mp;<br>mp.<span class="hljs-built_in">checkOut</span>();<span class="hljs-comment">//歧义，到底是哪个类的函数</span><br>只能使用：<br>mp.BorrowableItem::<span class="hljs-built_in">checkOut</span>();<br></code></pre></td></tr></table></figure><ul><li>在实际应用中, 经常会出现两个类继承与同一个父类，然后再有一个类多继承这两个类：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">First</span> : <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Parent</span><span class="hljs-params">(...)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Second</span> : <span class="hljs-keyword">public</span> Parent&#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">last</span>:<span class="hljs-keyword">public</span> First, <span class="hljs-keyword">public</span> Second&#123;...&#125;;<br></code></pre></td></tr></table></figure><ul><li>这个时候，last子类会包含两个Parent类中的成员数据，这属于数据冗余，是不能容忍的。可以采用virtual虚继承来避免这种情况。但是virtual继承会带来额外的代价。</li></ul><h3 id="隐式接口和编译期多态"><a href="#隐式接口和编译期多态" class="headerlink" title="隐式接口和编译期多态"></a>隐式接口和编译期多态</h3><ul><li>面向对象编程：以显式接口（explicit interfaces）和运行期多态（runtime polymorphism）解决问题。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>; <span class="hljs-comment">//第25条</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(Widget&amp; w)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(w.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">10</span>)&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在templete编程中：隐式接口（implicit interface）和编译器多态（compile-time polymorphism）更重要。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(w.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">10</span>)&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在上面这段代码中，w必须支持哪一种接口，由template中执行于w身上的操作来决定，例如T必须支持size等函数。这叫做隐式接口。</li><li>w的任何函数调用，例如operator&gt;，都有可能造成template具现化，使得调用成功，根据不同的T调用具现化出来不同的函数，这叫做编译期多态。</li></ul><h3 id="typename的双重意义"><a href="#typename的双重意义" class="headerlink" title="typename的双重意义"></a>typename的双重意义</h3><ul><li>声明template参数时，前缀关键字class和typename是可以互换的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class和typename两者有什么不同? 没有不同</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>; <br></code></pre></td></tr></table></figure></li><li>需要使用typename标识嵌套从属类型名称，但不能在base class lists（基类列）或者member initialization list（成员初始列）内以它作为base class修饰符：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(container.<span class="hljs-built_in">size</span>() &gt;=<span class="hljs-number">2</span>)<br>        <span class="hljs-function"><span class="hljs-keyword">typename</span> C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>;<br>        <span class="hljs-comment">//这里的typename表示C::const_iterator是一个类型名称，</span><br>        <span class="hljs-comment">//因为有可能会出现C这个类型里面没有const_iterator这个类型</span><br>        <span class="hljs-comment">//或者C这个类型里面有一个名为const_iterator的变量</span><br>&#125;<br><br><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">typename</span> Base ::Nested&#123;&#125;<span class="hljs-comment">//错误的！！！！！</span><br></code></pre></td></tr></table></figure><h3 id="学习处理模板化基类内的名称"><a href="#学习处理模板化基类内的名称" class="headerlink" title="学习处理模板化基类内的名称"></a>学习处理模板化基类内的名称</h3><ul><li>class CompanyA和CompanyB都有发送明文的函数：sendCleartext</li><li>信息类MsgInfo：</li><li>MsgSender：模板类，负责发送消息。根据不同的Company去调用sendCleartext。</li><li>LoggingMsgSender：在MsgSender的基础上又记录了一些日志。但是无法编译，因为找不到一个特例化的MsgSender&lt; company&gt;。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyA</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendCleartext</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>    ....<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyB</span>&#123;....&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgInfo</span>&#123;....&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClear</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span>&#123;<br>        std::string msg;<br>        Company c;<br>        c.<span class="hljs-built_in">sendCleartext</span>(msg);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<span class="hljs-comment">//想要在发送消息的时候同时写入log，因此有了这个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span>:<span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span>&#123;<br>        <span class="hljs-comment">//记录log</span><br>        <span class="hljs-built_in">sendClear</span>(info);<span class="hljs-comment">//无法通过编译，因为找不到一个特例化的MsgSender&lt;company&gt;</span><br>        <span class="hljs-comment">// 编译的时候，不会主动的调用基类中的函数，因为存在一个特化版本，不存在这个函数会出问题。</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>解决方法：对编译器说：base class template的任何特例化版本都支持其一般版本所提供的接口。</li><li>方法一：生成一个全特例化的模板</li><li>方法二：使用this：假设sendClear会被继承，会从基类里面寻找</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span>:<span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span>&#123;<br>        <span class="hljs-comment">//记录log</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">sendClear</span>(info);<span class="hljs-comment">//假设sendClear将被继承</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法三：使用using：告诉编译器，请他假设sendClear位于base class里面</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span>:<span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br>    <span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::sendClear; <span class="hljs-comment">//告诉编译器，请他假设sendClear位于base class里面</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span>&#123;<br>        <span class="hljs-comment">//记录log</span><br>        <span class="hljs-built_in">sendClear</span>(info);<span class="hljs-comment">//假设sendClear将被继承</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法四：指明位置，和使用using差不多。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span>:<span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span>&#123;<br>        <span class="hljs-comment">//记录log</span><br>        MsgSender&lt;Company&gt;::<span class="hljs-built_in">sendClear</span>(info);<span class="hljs-comment">//假设sendClear将被继承</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="将与参数无关的代码抽离templates"><a href="#将与参数无关的代码抽离templates" class="headerlink" title="将与参数无关的代码抽离templates"></a>将与参数无关的代码抽离templates</h3><ul><li>在下面的代码中，sm1和sm2分别属于两个类，就会产生invert()函数，造成代码冗余。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//求逆矩阵</span><br>&#125;<br><br>SquareMatrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">5</span>&gt; sm1;<br>SquareMatrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10</span>&gt; sm2;<br></code></pre></td></tr></table></figure></li><li>修改代码：SquareMatrix继承自base类，避免了遮掩base版的invert，n的不同大小，不会产生不同的类，代码冗余降低。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrixBase</span>&#123;<br>    <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> matrixSize)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>:<span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;  <span class="hljs-comment">//避免遮掩base版的invert</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;   <span class="hljs-comment">//一个inline调用，调用base class版的invert</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生依赖关系。</li><li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可以消除，做法是以函数参数后者class成员变量替换template参数</li></ul><h3 id="运用成员函数模板接受所有兼容类型"><a href="#运用成员函数模板接受所有兼容类型" class="headerlink" title="运用成员函数模板接受所有兼容类型"></a>运用成员函数模板接受所有兼容类型</h3><p>利用多态性将基类指针指向派生类对象很简单，但是对于包含模板的类型转换是比较麻烦的。因为编译器对于派生类模板参数和基类模板参数，是没有连接关系的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Top* pt2 = <span class="hljs-keyword">new</span> Bottom; <span class="hljs-comment">//将Bottom*转换为Top*是很容易的</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SmartPtr</span><span class="hljs-params">(T* realPtr)</span></span>;<br>&#125;;<br>SmartPtr&lt;Top&gt; pt2 = <span class="hljs-built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="hljs-keyword">new</span> Bottom);<span class="hljs-comment">//将SmartPtr&lt;Bottom&gt;转换成SmartPtr&lt;Top&gt;是有些麻烦的</span><br><br></code></pre></td></tr></table></figure><p>可运用模板成员函数，来进行变动：使用成员函数模板生成“可接受所有兼容类型”的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> SmartPtr&lt;U&gt;&amp; other)</span>  <span class="hljs-comment">//为了生成copy构造函数</span></span><br><span class="hljs-function">        :heldPtr(other.get())&#123;</span>....&#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> heldPtr; &#125;<br><span class="hljs-keyword">private</span>:<br>    T* heldPtr;                        <span class="hljs-comment">//这个SmartPtr持有的内置原始指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="需要类型转换时请为模板定义非成员函数"><a href="#需要类型转换时请为模板定义非成员函数" class="headerlink" title="需要类型转换时请为模板定义非成员函数"></a>需要类型转换时请为模板定义非成员函数</h3><p>进行混合类型算术运算的时候，会出现编译通过不了的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;....&#125;<br><br><span class="hljs-function">Rational&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational&lt;<span class="hljs-type">int</span>&gt; result = oneHalf * <span class="hljs-number">2</span>; <span class="hljs-comment">//错误，无法通过编译</span><br><span class="hljs-comment">// no match for &#x27;operator&#x27; (operand types are &#x27;Ratinal&lt;int&gt;&#x27; and &#x27;int&#x27;</span><br></code></pre></td></tr></table></figure><p>解决方法：使用friend声明一个函数,进行混合式调用<br>这里的friend和非friend函数是没有关联的。类外部的函数，并非为声明函数的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>()*rhs.<span class="hljs-built_in">numerator</span>(), lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp;rhs)&#123;....&#125;<br></code></pre></td></tr></table></figure><p><code>当我们编写一个class template， 而他所提供的“与此template相关的”函数支持所有参数隐形类型转换时，请将那些函数定义为classtemplate内部的friend函数</code></p><h3 id="认识template元编程"><a href="#认识template元编程" class="headerlink" title="认识template元编程"></a>认识template元编程</h3><p>Template metaprogramming是<code>编写执行于编译期间的程序</code>，因为这些代码运行于编译器而不是运行期，所以<code>效率会很高，同时一些运行期容易出现的问题也容易暴露出来</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&#123;<br>    <span class="hljs-keyword">enum</span>&#123;<br>        value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value<br>    &#125;;<br>&#125;;<br><span class="hljs-comment">// 类似递归出口</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt;&#123;<br>    <span class="hljs-keyword">enum</span>&#123; value = <span class="hljs-number">1</span> &#125;;<br>&#125;;                       <span class="hljs-comment">//这就是一个计算阶乘的元编程</span><br></code></pre></td></tr></table></figure><h3 id="了解new-handler的行为"><a href="#了解new-handler的行为" class="headerlink" title="了解new-handler的行为"></a>了解new-handler的行为</h3><p>当new无法申请到新的内存的时候，会不断的调用new-handler，直到找到足够的内存，new_handler是一个错误处理函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std&#123; <br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>; <br><span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>new_handler是一个函数指针，可以用set_new_handler把函数设置到系统中，返回一个new_handler：<code>set_new_handler允许客户制定一个函数，在内存分配无法获得满足时被调用</code><br>一个设计良好的new-handler要做下面的事情：</p><ul><li>让更多内存可以被使用</li><li>安装另一个new-handler，如果目前这个new-handler无法取得更多可用内存，或许他知道另外哪个new-handler有这个能力，然后用那个new-handler替换自己</li><li>卸除new-handler</li><li>抛出bad_alloc的异常</li><li>不返回，调用abort或者exit</li></ul><p>new-handler无法给每个class进行定制，但是可以重写new运算符，设计出自己的new-handler<br>此时这个new应该类似于下面的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* Widget::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>&#123;<br>        <span class="hljs-function">NewHandlerHolder <span class="hljs-title">h</span><span class="hljs-params">(std::set_new_handler(currentHandler))</span></span>;  <span class="hljs-comment">// 安装Widget的new-handler</span><br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);                                   <br>        <span class="hljs-comment">//分配内存或者抛出异常，恢复global new-handler</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h3><ul><li>了解new和delete的合理替换时机。</li><li>重写delete的时候，要保证删除null指针永远是安全的</li><li>如果operator new接受的参数除了一定会有的size_t之外还有其他的参数delete的时候，也要注意。</li></ul><p>参考列表：<br>Effective C++<br><a href="https://www.bilibili.com/video/BV1Vs4y1z7zo/">https://www.bilibili.com/video/BV1Vs4y1z7zo/</a></p>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树浅浅学习</title>
    <link href="/2024/03/26/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B5%85%E6%B5%85%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/26/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B5%85%E6%B5%85%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树浅浅学习"><a href="#红黑树浅浅学习" class="headerlink" title="红黑树浅浅学习"></a>红黑树浅浅学习</h1><h2 id="红黑树概念"><a href="#红黑树概念" class="headerlink" title="红黑树概念"></a>红黑树概念</h2><ul><li>二叉树：二叉树是每个节点最多有两个子树的树结构。</li><li>二叉查找树：又称“二叉搜索树”，左孩子比父节点小，右孩子比父节点大，还有一个特性就是”中序遍历“可以让结点有序。</li><li>平衡二叉树：它是一颗空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。</li><li>红黑树是一种自平衡的二叉查找树，它属于平衡树，但是却没有平衡二叉树那么“平衡”。可以保证在最坏情况下基本动态操作的时间复杂度为O(log n)。</li><li>红黑树中的每个节点都有一个颜色属性，可以是红色或黑色。</li></ul><p>红黑树满足以下5个性质：</p><ul><li>每个节点要么是红色的，要么是黑色的，根节点是黑色的。</li><li>每个叶子节点（NIL节点，空节点）是黑色的。</li><li>任何相邻节点不能同时为红色。</li><li>任何叶子节点，到根节点，所经过的黑节点数目相同。</li><li>当前节点到其所有叶节点包含的黑色节点数量相同。</li></ul><p><code>通过这些性质，红黑树可以保证在插入和删除节点时，自动调整树的结构，以保持树的平衡和性质的满足。相比于普通的二叉查找树，红黑树的平衡性更好，查找、插入和删除都具有更稳定的时间复杂度，因此在很多场景下被广泛应用。</code><br><img src="https://pic.imgdb.cn/item/660409da9f345e8d03927164.png#pic_center" alt="在这里插入图片描述"></p><hr><h2 id="红黑树平衡性调整"><a href="#红黑树平衡性调整" class="headerlink" title="红黑树平衡性调整"></a>红黑树平衡性调整</h2><ol><li>依次插入 100 90 120，不需要进行平衡性调整<br><img src="https://pic.imgdb.cn/item/66040a329f345e8d0395fb22.png" alt="在这里插入图片描述"></li><li>插入85，把90和120变成黑色，100变成红色。但100必须为黑色，100也变成黑色<br><img src="https://pic.imgdb.cn/item/66040a419f345e8d03967eda.png" alt="在这里插入图片描述"></li></ol><p><code>平衡性调整情况1：爷节点为黑色，父节点为红色，且有叔节点为红色，父亲节点为爷节点的左孩子</code></p><ul><li>将父节点和叔节点都变为黑色。</li><li>爷节点变成红色<ul><li>若爷节点变色之后红黑树性质出现问题，需要沿着爷节点继续向上调整</li><li>若爷节点为根节点，要变黑色。</li></ul></li></ul><ol><li>插入60为红色，红黑树继续进行调整，85变成黑色，90变成红色。<br><img src="https://pic.imgdb.cn/item/66040a5b9f345e8d03977077.png" alt="在这里插入图片描述"></li></ol><p><code>平衡性调整情况2：爷节点为黑色，父节点为红色，没有叔节点或叔节点为黑色，父亲节点为爷节点的左孩子，插入的节点是父节点的左孩子</code></p><p><code>平衡性调整情况3：爷节点为黑色，父节点为红色，没有叔节点或叔节点为黑色，父亲节点为爷节点的右孩子，插入的节点是父节点的左孩子</code></p><p><code>平衡性调整情况4-6分别为1-3的反情况</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBNode</span>&#123;<br>    T data;<br>    RBNode* leftChild;<br>    RBNode* rightChild;<br>    RBNode* parentNd;<br><br>    <span class="hljs-type">bool</span> isRed; <span class="hljs-comment">//判断是否为红色节点。</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RBTree</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RBTree</span>():<span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br><br>    ~<span class="hljs-built_in">RBTree</span>()&#123;<br>        <span class="hljs-built_in">ReleaseNode</span>(root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertElem</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;e)</span></span>&#123;<br>        <span class="hljs-built_in">InsertElem</span>(root,e);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertElem</span><span class="hljs-params">(RBNode&lt;T&gt;*&amp; tNode, <span class="hljs-type">const</span> T&amp; e)</span></span>&#123; <span class="hljs-comment">//第一个参数类型：指针引用</span><br>        RBNode&lt;T&gt;* point = tNode; <span class="hljs-comment">// 从指向根节点开始</span><br>        RBNode&lt;T&gt;* parent = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 保存父节点，根节点的父节点先为nullptr</span><br><br>        <span class="hljs-comment">// 通过一个while循环寻找要插入节点的位置，同时还要把插入路线上所经过的所有节点都保存到栈中，因为这些节点的平衡因子可能要调整。</span><br>        <span class="hljs-keyword">while</span>(point !=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(e==point-&gt;data) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//要插入的数据和当前树中某节点的数据相同，不允许插入</span><br>            <br>            parent = point; <span class="hljs-comment">// 记录父节点</span><br><br>            <span class="hljs-keyword">if</span>(e &gt; point-&gt;data)&#123;<br>                point = point-&gt;rightChild;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                point = point-&gt;leftChild;<br>            &#125;<br>        &#125;<span class="hljs-comment">// end while</span><br><br>        <span class="hljs-comment">// 走到这里，point 等于nullptr，该生成新节点了</span><br>        point = <span class="hljs-keyword">new</span> RBNode&lt;T&gt;;<br>        point-&gt;data = e;<br>        point-&gt;leftChild = <span class="hljs-literal">nullptr</span>;<br>        point-&gt;rightChild = <span class="hljs-literal">nullptr</span>;<br>        point-&gt;parentNd = <span class="hljs-literal">nullptr</span>;<br>        point-&gt;isRed = <span class="hljs-literal">true</span>; <span class="hljs-comment">//缺省插入的节点先给红色，之后才会判断需不需要进行调整</span><br><br>        <span class="hljs-keyword">if</span>(parent == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-comment">// 创建的是根节点</span><br>            point-&gt;isRed = <span class="hljs-literal">false</span>;<br>            tNode = point;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br><br>        <span class="hljs-comment">// 创建的不是根节点，要把节点链接到父节点上</span><br>        <span class="hljs-keyword">if</span>(e &gt; parent-&gt;data)&#123;<br>            parent-&gt;rightChild = point;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            parent-&gt;leftChild = point;<br>        &#125;<br><br>        point-&gt;parentNd = parent;<br>        <span class="hljs-keyword">if</span>(parent-&gt;isRed == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//如果父节点是黑色，当前插入的又是红色节点，不需要做什么直接返回</span><br><br>        <span class="hljs-built_in">BalanceTune</span>(point,parent);<br>        <br>        <span class="hljs-comment">// 不管前面经历了什么，根节点固定黑色</span><br>        root-&gt;isRed = <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">// 获取兄弟节点指针</span><br>    <span class="hljs-function">RBNode&lt;T&gt;* <span class="hljs-title">getBrotherNode</span><span class="hljs-params">(RBNode&lt;T&gt;* p)</span></span>&#123;<br>        <span class="hljs-comment">// 由调用者确认p-&gt;parent 一定不为nullptr</span><br>        <span class="hljs-keyword">if</span>(p-&gt;parentNd-&gt;leftChild == p)&#123;<br>            <span class="hljs-keyword">return</span> p-&gt;parentNd-&gt;rightChild;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;parentNd-&gt;leftChild; <br>    &#125;<br><br><br>    <span class="hljs-comment">// 平衡性调整</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BalanceTune</span><span class="hljs-params">(RBNode&lt;T&gt;* point, RBNode&lt;T&gt;* parent)</span></span>&#123;<br>        <span class="hljs-comment">// 能走到这里的，要插入的节点肯定至少在第三层了，因为如果是第二层，那么插入的节点都是红色的，父节点肯定是黑色的</span><br><br>        <span class="hljs-comment">// 父节点为红色才能走下来(当前节点为红色，此时需要进行平衡性调整)</span><br>        RBNode&lt;T&gt;* parentBroNode = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//叔节点，可能不存在</span><br>        RBNode&lt;T&gt;* grandFatherNode = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//爷节点，因为父节点为红色，红色不能为根，那么至少都是爷节点做根</span><br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            parentBroNode = (parent-&gt;parentNd !=<span class="hljs-literal">nullptr</span>) ? (<span class="hljs-built_in">getBrotherNode</span>(parent)):<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//叔节点</span><br>            grandFatherNode = point-&gt;parentNd-&gt;parentNd; <span class="hljs-comment">//爷节点</span><br><br>            <span class="hljs-comment">// 不断向上调整，爷节点可能有为空的时候</span><br>            <span class="hljs-keyword">if</span>(grandFatherNode == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">// 如果叔节点为红色，那么爷节点不可能为红色</span><br>            <span class="hljs-keyword">if</span>(parentBroNode != <span class="hljs-literal">nullptr</span> &amp;&amp; parentBroNode-&gt;isRed == <span class="hljs-literal">true</span>)&#123;<span class="hljs-comment">//平衡性调整情况1，没有将爷节点置为黑色的原因是统一在外部进行根节点为黑色的设置</span><br><br>                <span class="hljs-comment">// 先处理变色问题</span><br>                <span class="hljs-comment">// (1)父节点和叔节点变为黑色，爷节点变为红色</span><br>                parent-&gt;isRed = <span class="hljs-literal">false</span>;<br>                parentBroNode-&gt;isRed = <span class="hljs-literal">false</span>;<br>                grandFatherNode-&gt;isRed = <span class="hljs-literal">true</span>;<br><br>                <span class="hljs-comment">// (2)如果爷节点是根，跳出循环，根节点颜色在循环外进行设置为黑色的处理</span><br>                <span class="hljs-keyword">if</span>(grandFatherNode == root) <span class="hljs-keyword">break</span>;<br><br><br>                <span class="hljs-comment">// (3) 往上走继续循环</span><br>                point = grandFatherNode;<br>                parent = point-&gt;parentNd;<br>                <span class="hljs-keyword">if</span>(parent-&gt;isRed = <span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <br><br>            <span class="hljs-comment">// 能走到这里的平衡性调整情况2，不满足if(parentBroNode != nullptr &amp;&amp; parentBroNode-&gt;isRed == true)</span><br>            <span class="hljs-comment">// 叔节点为黑色或叔节点为空的情况</span><br>            <span class="hljs-comment">// 旋转变色之前的一些信息，这是通用代码</span><br>            RBNode&lt;T&gt;* gff = grandFatherNode-&gt;parentNd; <span class="hljs-comment">//太爷节点</span><br>            <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记1：grandFatherNode是父节点的左孩子，标记2：grandFatherNode是父节点的右孩子。</span><br>            <span class="hljs-keyword">if</span>(gff!=<span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">if</span>(gff-&gt;leftChild == grandFatherNode)&#123;<br>                    sign = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    sign = <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(grandFatherNode-&gt;leftChild == parent)&#123; <span class="hljs-comment">//第一种情形，父亲是爷节点的左孩子</span><br>                <span class="hljs-comment">// 开始旋转和变色以调整平衡</span><br>                <span class="hljs-keyword">if</span>(parent-&gt;leftChild == point)&#123; <span class="hljs-comment">//新节点是父亲节点的左孩子</span><br>                    <span class="hljs-comment">// 右旋转</span><br>                    <span class="hljs-built_in">RotateRight</span>(grandFatherNode);<br>                &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//新节点是父亲节点的右孩子</span><br>                    <span class="hljs-comment">// 先左旋后右旋</span><br>                    <span class="hljs-built_in">RotateLeftRight</span>(grandFatherNode);<br>                &#125;<br><br>                <span class="hljs-comment">// 旋转之后变色的代码，通用</span><br>                grandFatherNode-&gt;isRed = <span class="hljs-literal">false</span>; <span class="hljs-comment">//新的根节点设置为黑色</span><br>                grandFatherNode-&gt;rightChild-&gt;isRed = <span class="hljs-literal">true</span>; <span class="hljs-comment">//新右叶子设置为红色</span><br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 第二种情形，父亲是爷节点的右孩子</span><br>                <span class="hljs-keyword">if</span>(parent-&gt;rightChild == point)&#123; <span class="hljs-comment">//新节点是父亲的右孩子</span><br>                    <span class="hljs-built_in">RotateLeft</span>(grandFatherNode);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">RotateRightLeft</span>(grandFatherNode);<br>                &#125;<br>                <span class="hljs-comment">// 旋转变色之后的一些公用代码</span><br>                grandFatherNode-&gt;isRed = <span class="hljs-literal">false</span>; <span class="hljs-comment">//新根设置为黑色</span><br>                grandFatherNode-&gt;leftChild-&gt;isRed = <span class="hljs-literal">true</span>; <span class="hljs-comment">//新左叶子设置为红色</span><br>            &#125;<br><br><br>            <span class="hljs-comment">//*** 一些通用代码</span><br>            <span class="hljs-comment">// 根已经改变了，所以要设置一些节点指向信息</span><br>            <span class="hljs-keyword">if</span>(gff == <span class="hljs-literal">nullptr</span>)&#123;<br>                root = grandFatherNode;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;<br>                gff-&gt;leftChild = grandFatherNode;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">2</span>)&#123;<br>                gff-&gt;rightChild = grandFatherNode;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br><br>        &#125;<span class="hljs-comment">// end while(true)</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 右旋转</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RotateRight</span><span class="hljs-params">(RBNode&lt;T&gt;*&amp; pointer)</span></span>&#123; <span class="hljs-comment">//注意参数类型</span><br>        RBNode&lt;T&gt;* ptmproot = pointer;<br>        pointer = ptmproot-&gt;leftChild;<br>        pointer-&gt;parentNd = ptmproot-&gt;parentNd;<br><br>        ptmproot-&gt;leftChild = pointer-&gt;rightChild;<br>        <span class="hljs-keyword">if</span>(pointer-&gt;rightChild)&#123;<br>            pointer-&gt;rightChild-&gt;parentNd =ptmproot;<br>        &#125;<br>        pointer-&gt;rightChild = ptmproot;<br>        ptmproot-&gt;parentNd = pointer;<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReleaseNode</span><span class="hljs-params">(RBNode&lt;T&gt;* pnode)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(pnode !=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-built_in">ReleaseNode</span>(pnode-&gt;leftChild);<br>            <span class="hljs-built_in">ReleaseNode</span>(pnode-&gt;rightChild);<br>        &#125;<br>        <span class="hljs-keyword">delete</span> pnode;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    RBNode&lt;T&gt;* root; <br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    RBTree&lt;<span class="hljs-type">int</span>&gt; myrbtr;<br>    <span class="hljs-type">int</span> array[] = &#123;<span class="hljs-number">80</span>,<span class="hljs-number">50</span>,<span class="hljs-number">120</span>,<span class="hljs-number">30</span>,<span class="hljs-number">60</span>,<span class="hljs-number">20</span>,<span class="hljs-number">40</span>&#125;;<br>    <span class="hljs-type">int</span> acount = <span class="hljs-built_in">sizeof</span>(array)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;acount;i++)&#123;<br>        myrbtr.<span class="hljs-built_in">InsertElem</span>(array[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现线程池二</title>
    <link href="/2024/03/26/C++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BA%8C/"/>
    <url>/2024/03/26/C++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实现线程池二"><a href="#C-实现线程池二" class="headerlink" title="C++实现线程池二"></a>C++实现线程池二</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>大型的软件项目需要处理非常多的任务，例如：对于大量数据的数据流处理，或者是包含复杂GUI界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。</p><p>如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。</p><h3 id="C-实现生产者消费者模型"><a href="#C-实现生产者消费者模型" class="headerlink" title="C++ 实现生产者消费者模型"></a>C++ 实现生产者消费者模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">// 某些调用可能会抛出std::system_error</span><br>std::mutex mutex;<br>std::condition_variable condvar;<br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; msgQueue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = start; x &lt; end; x++) &#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">200</span>));<br>        &#123;        <br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mutex)</span></span>;<br>            msgQueue.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Produce message %d\n&quot;</span>, x);<br>        condvar.<span class="hljs-built_in">notify_all</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">int</span> demand)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">ulock</span><span class="hljs-params">(mutex)</span></span>;<br>        condvar.<span class="hljs-built_in">wait</span>(ulock, []&#123; <span class="hljs-keyword">return</span> msgQueue.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>;&#125;);<br>        <span class="hljs-comment">// wait的第二个参数使得显式的double check不再必要</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Consume message %d\n&quot;</span>, msgQueue.<span class="hljs-built_in">front</span>());<br>        msgQueue.<span class="hljs-built_in">pop</span>();<br>        --demand;<br>        <span class="hljs-keyword">if</span> (!demand) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">producer1</span><span class="hljs-params">(producer, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">producer2</span><span class="hljs-params">(producer, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">producer3</span><span class="hljs-params">(producer, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer1</span><span class="hljs-params">(consumer, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer2</span><span class="hljs-params">(consumer, <span class="hljs-number">10</span>)</span></span>;<br><br>    producer1.<span class="hljs-built_in">join</span>();<br>    producer2.<span class="hljs-built_in">join</span>();<br>    producer3.<span class="hljs-built_in">join</span>();<br>    consumer1.<span class="hljs-built_in">join</span>();<br>    consumer2.<span class="hljs-built_in">join</span>();<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="C-线程池"><a href="#C-线程池" class="headerlink" title="C++线程池"></a>C++线程池</h2><p><code>对上一篇文章中的线程池进行改写，将C语言为C++编写，创建线程池对象，包含队列，从队列中取出线程并运行线程程序</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">liuchang@DESKTOP-LIUCHANG:~/codetest/THreads/cppthreadpool$ tree<br>.<br>├── main.cpp<br>├── main.exe<br>├── Makefile<br>├── run.sh<br>├── TaskQueue.cpp<br>├── TaskQueue.h<br>├── ThreadPool.cpp<br>└── ThreadPool.h<br></code></pre></td></tr></table></figure><p>TaskQueue.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> callback = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>* arg);<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span><br>&#123;<br>    <span class="hljs-built_in">Task</span>&lt;T&gt;()&#123;<br>        function = <span class="hljs-literal">nullptr</span>;<br>        arg = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-built_in">Task</span>&lt;T&gt;(callback f, <span class="hljs-type">void</span>* arg)<br>    &#123;<br>        function = f;<br>        <span class="hljs-keyword">this</span>-&gt;arg = (T*)arg;<br>    &#125;<br>    callback function;<br>    T *arg; <br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TaskQueue</span>();<br>    ~<span class="hljs-built_in">TaskQueue</span>();<br><br>    <span class="hljs-comment">// 添加任务 </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Task&lt;T&gt; &amp;task)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(callback func, <span class="hljs-type">void</span>* arg)</span></span>;<br>    <span class="hljs-comment">// 取出一个任务</span><br>    <span class="hljs-function">Task&lt;T&gt; <span class="hljs-title">takeTask</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 获取当前任务的个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">taskNumber</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> m_taskQ.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> m_mutex;<br>    std::queue&lt;Task&lt;T&gt;&gt; m_taskQ;<br>&#125;;<br></code></pre></td></tr></table></figure><p>TaskQueue.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TaskQueue.h&quot;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>TaskQueue&lt;T&gt;::<span class="hljs-built_in">TaskQueue</span>()&#123;<br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>TaskQueue&lt;T&gt;::~<span class="hljs-built_in">TaskQueue</span>()&#123;<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;m_mutex);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> TaskQueue&lt;T&gt;::<span class="hljs-built_in">addTask</span>(Task&lt;T&gt; &amp;task)&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;m_mutex);<br>    m_taskQ.<span class="hljs-built_in">push</span>(task);<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;m_mutex);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> TaskQueue&lt;T&gt;::<span class="hljs-built_in">addTask</span>(callback func, <span class="hljs-type">void</span>* arg)&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;m_mutex);<br>    m_taskQ.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Task</span>&lt;T&gt;(func,arg));<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;m_mutex);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Task&lt;T&gt; TaskQueue&lt;T&gt;::<span class="hljs-built_in">takeTask</span>()&#123;<br>    Task&lt;T&gt; t;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;m_mutex);<br>    <span class="hljs-keyword">if</span>(!m_taskQ.<span class="hljs-built_in">empty</span>())&#123;<br>        t = m_taskQ.<span class="hljs-built_in">front</span>();<br>        m_taskQ.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;m_mutex);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadPool.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TaskQueue.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TaskQueue.cpp&quot;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 创建线程池并初始化,min线程池最小线程数，max线程池最大线程数</span><br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max);<br><br>    <span class="hljs-comment">// 销毁线程池</span><br>    ~<span class="hljs-built_in">ThreadPool</span>();<br><br>    <span class="hljs-comment">// 给线程池加任务</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Task&lt;T&gt; task)</span></span>;<br><br>    <span class="hljs-comment">// 获取线程池中工作的线程的个数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBusyNum</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 获取线程池中活着的线程的个数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAliveNum</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadExit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 任务队列</span><br>    TaskQueue&lt;T&gt; *taskQ;<br><br>    <span class="hljs-type">pthread_t</span> managerID;       <span class="hljs-comment">// 管理者线程ID</span><br>    <span class="hljs-type">pthread_t</span> *threadIDs;      <span class="hljs-comment">// 工作者线程ID</span><br>    <span class="hljs-type">int</span> minNum;                <span class="hljs-comment">// 最小线程数目</span><br>    <span class="hljs-type">int</span> maxNum;                <span class="hljs-comment">// 最大线程数目</span><br>    <span class="hljs-type">int</span> busyNum;               <span class="hljs-comment">// 忙线程个数</span><br>    <span class="hljs-type">int</span> liveNum;               <span class="hljs-comment">// 存活线程个数</span><br>    <span class="hljs-type">int</span> exitNum;               <span class="hljs-comment">// 要杀死的线程个数</span><br>    <span class="hljs-type">pthread_mutex_t</span> mutexpool; <span class="hljs-comment">// 锁整个线程池</span><br>    <span class="hljs-type">pthread_cond_t</span> notEmpty;   <span class="hljs-comment">// 任务队列是否空了</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NUMBER = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-type">bool</span> shutdown=<span class="hljs-literal">false</span>; <span class="hljs-comment">// 是不是要销毁线程池，销毁为true，不销毁为false</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>ThreadPool.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;ThreadPool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::to_string;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>ThreadPool&lt;T&gt;::<span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)&#123;<br>    <span class="hljs-comment">// 实例化任务队列</span><br>    taskQ = <span class="hljs-keyword">new</span> TaskQueue&lt;T&gt;;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">// 初始化线程池</span><br>        minNum = min;<br>        maxNum = max;<br>        busyNum = <span class="hljs-number">0</span>;<br>        liveNum = min;<br><br>        <span class="hljs-comment">// 根据线程最大上限给线程数组分配内存</span><br>        threadIDs = <span class="hljs-keyword">new</span> <span class="hljs-type">pthread_t</span>[max];<br>        <span class="hljs-keyword">if</span>(threadIDs == <span class="hljs-literal">nullptr</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;malloc threadIDs failed...&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(threadIDs,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_t</span>) * maxNum);<br>        <br>        exitNum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutexpool, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> || <span class="hljs-built_in">pthread_cond_init</span>(&amp;notEmpty, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> )<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;mutex or cond init failed..&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        shutdown = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">pthread_create</span>(&amp;managerID, <span class="hljs-literal">NULL</span>, manager, <span class="hljs-keyword">this</span>); <span class="hljs-comment">// 管理线程调用管理函数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; minNum; i++)<br>        &#123;<br>            <span class="hljs-built_in">pthread_create</span>(&amp;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, <span class="hljs-keyword">this</span>); <span class="hljs-comment">// 工作线程调用worker函数</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;创建子线程,ID: &quot;</span>&lt;&lt;<span class="hljs-built_in">to_string</span>(threadIDs[i]) &lt;&lt; endl;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>ThreadPool&lt;T&gt;::~<span class="hljs-built_in">ThreadPool</span>()&#123;<br>    shutdown = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 销毁管理者线程</span><br>    <span class="hljs-built_in">pthread_join</span>(managerID, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 唤醒所有消费者线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;liveNum;i++)&#123;<br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;notEmpty);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(taskQ) <span class="hljs-keyword">delete</span> taskQ;<br>    <span class="hljs-keyword">if</span>(threadIDs) <span class="hljs-keyword">delete</span>[]threadIDs;<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutexpool);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;notEmpty);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span>* ThreadPool&lt;T&gt;:: <span class="hljs-built_in">worker</span>(<span class="hljs-type">void</span> *arg)&#123;<br>    ThreadPool* pool = <span class="hljs-built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool); <span class="hljs-comment">//对线程池上锁</span><br>        <span class="hljs-keyword">while</span>(pool-&gt;taskQ-&gt;<span class="hljs-built_in">taskNumber</span>()==<span class="hljs-number">0</span> &amp;&amp; !pool-&gt;shutdown)&#123;<br>            <span class="hljs-comment">// 阻塞工作线程</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;thread &quot;</span> &lt;&lt; <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">pthread_self</span>()) &lt;&lt; <span class="hljs-string">&quot; waiting...&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexpool);<br><br>            <span class="hljs-comment">// 解除阻塞后，判断是不是要销毁线程</span><br>            <span class="hljs-keyword">if</span> (pool-&gt;exitNum&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                pool-&gt;exitNum--;<br>                <span class="hljs-keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum)<br>                &#123;<br>                    pool-&gt;liveNum--;<br>                    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>                    pool-&gt;<span class="hljs-built_in">threadExit</span>();<br>                &#125; <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断线程是否被关闭了</span><br>        <span class="hljs-keyword">if</span>(pool-&gt;shutdown)&#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>            pool-&gt;<span class="hljs-built_in">threadExit</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 从任务队列中取出一个任务</span><br>        Task&lt;T&gt; task = pool-&gt;taskQ-&gt;<span class="hljs-built_in">takeTask</span>();<br>        <span class="hljs-comment">// 工作的线程+1 </span><br>        pool-&gt;busyNum++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool); <span class="hljs-comment">// 用完以后解锁</span><br><br>        cout &lt;&lt; <span class="hljs-string">&quot;thread &quot;</span> &lt;&lt; <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">pthread_self</span>()) &lt;&lt; <span class="hljs-string">&quot; start working...&quot;</span> &lt;&lt; endl;<br>        <br>        task.<span class="hljs-built_in">function</span>(task.arg); <br>        <span class="hljs-keyword">delete</span> task.arg;<br>        task.arg= <span class="hljs-literal">nullptr</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;thread &quot;</span> &lt;&lt; <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">pthread_self</span>()) &lt;&lt; <span class="hljs-string">&quot; end working...&quot;</span> &lt;&lt; endl;<br>        <br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>        pool-&gt;busyNum--;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 管理者线程任务函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span>* ThreadPool&lt;T&gt;::<span class="hljs-built_in">manager</span>(<span class="hljs-type">void</span>* arg)&#123;<br>    ThreadPool* pool = <span class="hljs-built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);<br>    <span class="hljs-comment">// 如果线程池没有关闭, 就一直检测。</span><br>    <span class="hljs-keyword">while</span>(!pool-&gt;shutdown)&#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>        <span class="hljs-type">int</span> queueSize=pool-&gt;taskQ-&gt;<span class="hljs-built_in">taskNumber</span>();<br>        <span class="hljs-type">int</span> liveNum = pool-&gt;liveNum;<br>        <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br><br>        <span class="hljs-comment">// 创建线程</span><br>        <span class="hljs-comment">// 当前任务个数&gt;存活的线程数 &amp;&amp; 存活的线程数&lt;最大线程个数</span><br>        <span class="hljs-keyword">if</span> (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)<br>        &#123;<br>            <span class="hljs-comment">// 线程池加锁</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>            <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;maxNum &amp;&amp; num &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (pool-&gt;threadIDs[i] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, pool);<br>                    num++;<br>                    pool-&gt;liveNum++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>        &#125;<br><br>        <span class="hljs-comment">//销毁线程</span><br>        <span class="hljs-keyword">if</span>(busyNum*<span class="hljs-number">2</span> &lt; liveNum &amp;&amp; liveNum&gt; pool-&gt;minNum)&#123;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>            pool-&gt;exitNum = NUMBER;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>            <span class="hljs-comment">// 让工作的线程自杀</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;NUMBER;++i)&#123;<br>                <span class="hljs-built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> ThreadPool&lt;T&gt;::<span class="hljs-built_in">threadExit</span>()&#123;<br>    <span class="hljs-type">pthread_t</span> tid = <span class="hljs-built_in">pthread_self</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxNum; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (threadIDs[i] == tid)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;threadExit() function: thread &quot;</span> <br>                &lt;&lt; <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">pthread_self</span>()) &lt;&lt; <span class="hljs-string">&quot; exiting...&quot;</span> &lt;&lt; endl;<br>            threadIDs[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> ThreadPool&lt;T&gt;::<span class="hljs-built_in">addTask</span>(Task&lt;T&gt; task)<br>&#123;<br>    <span class="hljs-comment">// 往任务队列加任务的时候，不需要自己加锁。内部已经做了同步</span><br>    <span class="hljs-keyword">if</span> (shutdown)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 添加任务，不需要加锁，任务队列中有锁</span><br>    taskQ-&gt;<span class="hljs-built_in">addTask</span>(task);<br>    <span class="hljs-comment">// 唤醒工作的线程</span><br>    <span class="hljs-built_in">pthread_cond_signal</span>(&amp;notEmpty);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> ThreadPool&lt;T&gt;::<span class="hljs-built_in">getAliveNum</span>()<br>&#123;<br>    <span class="hljs-type">int</span> threadNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutexpool);<br>    threadNum = <span class="hljs-keyword">this</span>-&gt;liveNum;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutexpool);<br>    <span class="hljs-keyword">return</span> threadNum;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> ThreadPool&lt;T&gt;::<span class="hljs-built_in">getBusyNum</span>()<br>&#123;<br>    <span class="hljs-type">int</span> busyNumt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutexpool);<br>    busyNumt = <span class="hljs-keyword">this</span>-&gt;busyNum;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutexpool);<br>    <span class="hljs-keyword">return</span> busyNumt;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ThreadPool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ThreadPool.cpp&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">taskFunc</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> num = *(<span class="hljs-type">int</span>*)arg;<br>    cout&lt;&lt;<span class="hljs-string">&quot;thread &quot;</span>&lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt;<span class="hljs-string">&quot; is working, number = &quot;</span>&lt;&lt;num&lt;&lt;endl; <br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">// 创建线程池</span><br>    <span class="hljs-function">ThreadPool&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">// 做小运行线程数为3，最大运行线程数为10</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>        <span class="hljs-type">int</span>* num = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> (i+<span class="hljs-number">100</span>);<br>        pool.<span class="hljs-built_in">addTask</span>(<span class="hljs-built_in">Task</span>&lt;<span class="hljs-type">int</span>&gt;(taskFunc,num));<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-实现线程池二-1"><a href="#C-实现线程池二-1" class="headerlink" title="C++实现线程池二"></a>C++实现线程池二</h2><p>C++11 实现<br>线程池需要维护的两个主要组成部分：</p><ul><li>任务队列：这里直接用一个队列queue来实现</li><li>线程池：</li></ul><p>ThreadPool类：在构造函数中创建了指定数目的线程。在每个线程中，不断地从任务队列中获取任务并执行，直到线程池被停止。在 enqueue() 函数中，将任务封装成一个 std::function 对象，并将它添加到任务队列中。在 ThreadPool 的析构函数中，我们等待所有线程执行完成后再停止所有线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> numThreads):<span class="hljs-built_in">stop</span>(<span class="hljs-literal">false</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; i++)<br>        &#123;<br>            threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>]&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>                    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(mtx);<br>                    condition.<span class="hljs-built_in">wait</span>(lock,[<span class="hljs-keyword">this</span>]&#123;<br>                        <span class="hljs-keyword">return</span> !tasks.<span class="hljs-built_in">empty</span>()||stop;<br>                    &#125;);<br>                    <span class="hljs-keyword">if</span>(stop &amp;&amp; tasks.<span class="hljs-built_in">empty</span>())&#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    std::function&lt;<span class="hljs-built_in">void</span>()&gt; <span class="hljs-built_in">task</span>(std::<span class="hljs-built_in">move</span>(tasks.<span class="hljs-built_in">front</span>()));<br>                    tasks.<span class="hljs-built_in">pop</span>();<br>                    lock.<span class="hljs-built_in">unlock</span>();<br>                    <span class="hljs-built_in">task</span>();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ThreadPool</span>()&#123;<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>            stop = <span class="hljs-literal">true</span>;<br>        &#125;<br>        condition.<span class="hljs-built_in">notify_all</span>();<span class="hljs-comment">//通知所有线程，抓紧时间完成所有任务</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; t: threads)&#123;<br>            t.<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(F &amp;&amp;f, Args&amp;&amp;... args)</span></span>&#123;<br>        std::function&lt;<span class="hljs-type">void</span>()&gt; task = std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<br>        <span class="hljs-comment">//task(std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>            tasks.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(task));<br>        &#125;<br>        condition.<span class="hljs-built_in">notify_one</span>();<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::thread&gt; threads;<br>    std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;<br><br>    std::mutex mtx;<br>    std::condition_variable condition;<br><br>    <span class="hljs-type">bool</span> stop;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>        pool.<span class="hljs-built_in">enqueue</span>([i] &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; is running in thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; is done&quot;</span> &lt;&lt; std::endl;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="async-future-packaged-task-promise"><a href="#async-future-packaged-task-promise" class="headerlink" title="async future packaged_task promise"></a>async future packaged_task promise</h3><p>async是C++11引入的函数模板，用于异步执行一个函数，并返回std::future对象，表示异步操作的结果，使用std::async可以方便地进行异步变成，避免了，手动创建线程和管理线程的麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 传入的func已经开辟新的线程在执行了，执行结果返回给future_result</span><br>    <span class="hljs-comment">// 实际用法，就是开辟多线程更加方便了</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; future_result = std::<span class="hljs-built_in">async</span>(std::launch::async,func); <br>    cout&lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt;endl;<br>    cout&lt;&lt;future_result.<span class="hljs-built_in">get</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>packaged_task是一个类模板，用于将一个可调用对象（如函数，函数对象或lambda表达式）封装成一个异步操作，并返回一个std::future对象，表示异步操作的结果。packaged_task可以方便的将一个函数或可调用对象转换为一个异步操作，供其他线程使用。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-keyword">auto</span> future_result = task.<span class="hljs-built_in">get_future</span>();<span class="hljs-comment">//此时只是封装一个异步操作，但是还没有真正执行异步操作。</span><br><br>    <span class="hljs-comment">//packaged_task是一个可移动对象，要把可移动对象放到线程中执行，要用move转移一下，把函数放到线程中执行。</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(std::move(task))</span></span>; <br> <br>    cout&lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt;endl;<br>    t1.<span class="hljs-built_in">join</span>();<br>    cout&lt;&lt;future_result.<span class="hljs-built_in">get</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::promise是一个协助线程赋值的类模板，用于在线程中产生一个值，并在另一个线程中获取这个值。promise通常与future和async一起使用，用于实现异步编程。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; &amp;f)</span></span>&#123;<br>    f.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-keyword">auto</span> future_result = f.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func,std::ref(f))</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    cout&lt;&lt;future_result.<span class="hljs-built_in">get</span>()&lt;&lt;endl; <span class="hljs-comment">//1000</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="atomic-原子操作"><a href="#atomic-原子操作" class="headerlink" title="atomic 原子操作"></a>atomic 原子操作</h3><p><code>C++11提供了一个原子类型std::atomic&lt;T&gt;，通过这个原子类型管理的内部变量就可以称之为原子变量，我们可以给原子类型指定bool、char、int、long、指针等类型作为模板参数（不支持浮点类型和复合类型）。提供了一种线程安全的方式来访问和修改共享变量，可以避免多线程环境中数据竞争问题。</code></p><p>原子指的是一系列不可被CPU上下文交换的机器指令，这些指令组合在一起就形成了原子操作，在多核CPU下，当某个CPU核心开始运行原子操作时，会暂停其他CPU内核对内存的操作，以保证原子操作不会被其他CPU内核干扰。</p><p>由于<strong>原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多</strong>。相比较于锁而言，<strong>原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能</strong>，几乎所有的语言都支持原子类型。</p><p>在多线程操作中，使用原子变量之后就不需要再使用互斥量来保护该变量了，用起来更简洁。因为对原子变量进行的操作只能是一个原子操作（atomic operation），原子操作指的是不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何的上下文切换。</p><p>常用的原子操作：</p><blockquote><p>load()：将std::atomic变量值加载到当前线程的本地缓存中，并返回这个值。<br>store(val)：将val值存储到atomic变量中，并保证这个操作是原子性的。<br>exchange(val)：改变值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">shared_data</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>        shared_data++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;shared_data = &quot;</span>&lt;&lt;shared_data&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用了原子变量之后，就不需要再定义互斥量了，在使用上更加简便，并且这两种方式都能保证在多线程操作过程中数据的正确性，不会出现数据的混乱。</p><h2 id="C-实现线程池三"><a href="#C-实现线程池三" class="headerlink" title="C++实现线程池三"></a>C++实现线程池三</h2><p>C++11实现线程池：一个简易的<code>单任务队列</code>线程池的实现思路：在线程池构造时初始化线程数，在析构时停止线程池。对外也只需要提供提交任务的接口就够了。</p><ul><li>任务队列：用mutex限制队列的并发访问。</li><li>线程池：接收任何参数的任何函数（普通函数，lambda，成员函数…）,立即返回任务结束的结果，避免阻塞主线程。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 队列，同时用mutex限制并发</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeQueue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;T&gt; m_queue; <span class="hljs-comment">// 利用模板函数构造队列</span><br>    std::mutex m_mutex;    <span class="hljs-comment">// 访问互斥信号量</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SafeQueue</span>() &#123;&#125;<br>    <span class="hljs-built_in">SafeQueue</span>(SafeQueue &amp;&amp;other) &#123;&#125;<br>    ~<span class="hljs-built_in">SafeQueue</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-comment">// 返回队列是否为空</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>; <span class="hljs-comment">// 互斥信号变量加锁，防止m_queue被改变</span><br>        <span class="hljs-keyword">return</span> m_queue.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>; <span class="hljs-comment">// 互斥信号变量加锁，防止m_queue被改变</span><br>        <span class="hljs-keyword">return</span> m_queue.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* // 队列添加元素 在添加lambda表达式时会报错，因为enqueue 方法期望的是一个左值引用，lambda表达式是无名的右值</span><br><span class="hljs-comment">    void enqueue(T &amp;t)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        std::unique_lock&lt;std::mutex&gt; lock(m_mutex);</span><br><span class="hljs-comment">        m_queue.emplace(t);</span><br><span class="hljs-comment">    &#125; */</span><br><br>    <span class="hljs-comment">// 万能引用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        m_queue.<span class="hljs-built_in">emplace</span>(std::forward&lt;T&gt;(t));<span class="hljs-comment">// 队列添加元素 完美转发</span><br>    &#125;<br><br>    <span class="hljs-comment">// 队列取出元素</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(T &amp;t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>; <span class="hljs-comment">// 队列加锁</span><br>        <span class="hljs-keyword">if</span> (m_queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        t = std::<span class="hljs-built_in">move</span>(m_queue.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// 取出队首元素，返回队首元素值，并进行右值引用</span><br>        m_queue.<span class="hljs-built_in">pop</span>();                  <span class="hljs-comment">// 弹出入队的第一个元素</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadWorker</span> <span class="hljs-comment">// 内置线程工作类，执行真正的工作</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> m_id; <span class="hljs-comment">// 工作id</span><br>        ThreadPool *m_pool; <span class="hljs-comment">// 所属线程池</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-built_in">ThreadWorker</span>(ThreadPool *pool, <span class="hljs-type">const</span> <span class="hljs-type">int</span> id) : <span class="hljs-built_in">m_pool</span>(pool), <span class="hljs-built_in">m_id</span>(id)&#123;&#125;<br>        <span class="hljs-comment">// 重载()操作，核心操作，不然函数运行不起来</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span>&#123;<br>            std::function&lt;<span class="hljs-type">void</span>()&gt; func; <span class="hljs-comment">//定义基础函数类func</span><br>            <span class="hljs-type">bool</span> dequeued; <span class="hljs-comment">// 是否正在取出队列中元素</span><br>            <span class="hljs-keyword">while</span> (!m_pool-&gt;m_shutdown)&#123;<br>                &#123;<br>                    <span class="hljs-comment">// 为线程环境加锁，互访问工作线程的休眠和唤醒</span><br>                    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_pool-&gt;m_conditional_mutex)</span></span>;<br>                    <span class="hljs-comment">// 如果任务队列为空，阻塞当前线程</span><br>                    <span class="hljs-keyword">if</span> (m_pool-&gt;m_queue.<span class="hljs-built_in">empty</span>())<br>                    &#123;<br>                        m_pool-&gt;m_conditional_lock.<span class="hljs-built_in">wait</span>(lock); <span class="hljs-comment">// 等待条件变量通知，开启线程</span><br>                    &#125;<br><br>                    <span class="hljs-comment">// 取出任务队列中的元素</span><br>                    dequeued = m_pool-&gt;m_queue.<span class="hljs-built_in">dequeue</span>(func);<br>                &#125;<br>                <span class="hljs-comment">// 如果成功取出，执行工作函数</span><br>                <span class="hljs-keyword">if</span> (dequeued)<br>                    <span class="hljs-built_in">func</span>();<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">bool</span> m_shutdown; <span class="hljs-comment">// 线程池是否关闭</span><br><br>    SafeQueue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; m_queue; <span class="hljs-comment">// 执行函数安全队列，即任务队列</span><br><br>    std::vector&lt;std::thread&gt; m_threads; <span class="hljs-comment">// 工作线程队列</span><br><br>    std::mutex m_conditional_mutex; <span class="hljs-comment">// 线程休眠锁互斥变量</span><br><br>    std::condition_variable m_conditional_lock; <span class="hljs-comment">// 线程环境锁，可以让线程处于休眠或者唤醒状态</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 线程池构造函数</span><br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> n_threads = <span class="hljs-number">4</span>)<br>        : <span class="hljs-built_in">m_threads</span>(std::<span class="hljs-built_in">vector</span>&lt;std::thread&gt;(n_threads)), <span class="hljs-built_in">m_shutdown</span>(<span class="hljs-literal">false</span>)<br>    &#123;<br>    &#125;<br>    <span class="hljs-comment">// 保证资源的唯一性</span><br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">const</span> ThreadPool &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁用拷贝构造</span><br><br>    <span class="hljs-built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁用移动构造</span><br><br>    ThreadPool &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ThreadPool &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁用拷贝赋值运算符</span><br><br>    ThreadPool &amp;<span class="hljs-keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁用移动赋值运算符</span><br><br>    <span class="hljs-comment">// 初始化线程池</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_threads.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            m_threads[i] = std::<span class="hljs-built_in">thread</span>(<span class="hljs-built_in">ThreadWorker</span>(<span class="hljs-keyword">this</span>, i)); <span class="hljs-comment">// 分配工作线程</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 销毁线程池，等待线程池中的工作完成</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_shutdown = <span class="hljs-literal">true</span>;<br>        m_conditional_lock.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 通知，唤醒所有工作线程，抓紧时间处理工作</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_threads.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (m_threads[i].<span class="hljs-built_in">joinable</span>()) <span class="hljs-comment">// 判断线程是否在等待</span><br>            &#123;<br>                m_threads[i].<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 将线程加入到等待队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * template &lt;typename F, typename... Args&gt; 可变参数模板。</span><br><span class="hljs-comment">     * auto submit(F &amp;&amp;f, Args &amp;&amp;...args) -&gt; std::future&lt;decltype(f(args...))&gt; &#123;&#125;  尾返回类型推导的技巧。</span><br><span class="hljs-comment">     * 利用auto关键字，将返回类型后置，可以扩充函数的类型。</span><br><span class="hljs-comment">     * F&amp;&amp; f和Args&amp;&amp;... args中的&amp;&amp;并非是右值引用意思,而是万能引用</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Args&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">submit</span><span class="hljs-params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(f(args...))</span>&gt;</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// Create a function with bounded parameter ready to execute</span><br>        std::function&lt;<span class="hljs-keyword">decltype</span>(f(args...))()&gt; func = std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="hljs-comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span><br><br>        <span class="hljs-comment">// Encapsulate it into a shared pointer in order to be able to copy construct</span><br>        <span class="hljs-keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>(args...))()&gt;&gt;(func);<br><br>        <span class="hljs-comment">/* // Warp packaged task into void function</span><br><span class="hljs-comment">        std::function&lt;void()&gt;warpper_func = [task_ptr]()&#123;</span><br><span class="hljs-comment">            (*task_ptr)();</span><br><span class="hljs-comment">        &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        // 队列通用安全封包函数，并压入安全队列</span><br><span class="hljs-comment">        m_queue.enqueue(warpper_func); */</span><br><br>        m_queue.<span class="hljs-built_in">enqueue</span>([task_ptr]()&#123; <br>            (*task_ptr)(); <br>        &#125;);<br>       <br>        <span class="hljs-comment">// 唤醒一个等待中的线程</span><br>        m_conditional_lock.<span class="hljs-built_in">notify_one</span>();<br><br>        <span class="hljs-comment">// 返回先前注册的任务指针</span><br>        <span class="hljs-keyword">return</span> task_ptr-&gt;<span class="hljs-built_in">get_future</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>参考列表：</p><ol><li><a href="https://www.bilibili.com/video/BV1d841117SH">https://www.bilibili.com/video/BV1d841117SH</a></li><li><a href="https://subingwen.cn/linux/threadpool-cpp/">https://subingwen.cn/linux/threadpool-cpp/</a></li><li><a href="https://segmentfault.com/a/1190000002655852">https://segmentfault.com/a/1190000002655852</a></li><li><a href="https://paul.pub/cpp-concurrency">https://paul.pub/cpp-concurrency</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现线程池一</title>
    <link href="/2024/03/26/C++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%80/"/>
    <url>/2024/03/26/C++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实现线程池一"><a href="#C-实现线程池一" class="headerlink" title="C++实现线程池一"></a>C++实现线程池一</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><code>当并发的线程数量增多，每个线程执行一个很短的任务之后销毁，频繁的创建和销毁线程就会降低系统效率。</code><br>线程池就是希望先一个线程执行完一个任务，不被销毁，去执行其他任务。线程池的任务处理过程中，将任务添加到队列，在创建线程后自动执行这些任务。</p><p><code>线程池的组成：</code></p><ul><li>任务队列：存储需要处理的任务，由工作的线程来处理这些任务，</li><li>工作线程：读取任务队列，执行任务，充当消费者角色。</li><li>管理线程：周期性的管理工作线程，根据任务量，适当微调工作线程的个数。</li></ul><hr><h2 id="C语言线程池"><a href="#C语言线程池" class="headerlink" title="C语言线程池"></a>C语言线程池</h2><p>文件树：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">liuchang@DESKTOP-LIUCHANG:~/codetest/THreads/cthreadpool$ tree<br>.<br>├── main.cpp<br>├── main.exe<br>├── Makefile<br>├── run.sh<br>├── threadpool.cpp<br>└── threadpool.h<br><br>0 directories, 6 files<br></code></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">CC = g++ <span class="hljs-literal">-std</span>=c++<span class="hljs-number">14</span><br>CFLAGS = <span class="hljs-literal">-g</span> <span class="hljs-literal">-Wall</span><br><br>src=<span class="hljs-variable">$</span>(wildcard *.cpp) <span class="hljs-comment">#搜索当前目录下的cpp文件 # 受够繁文缛节了，不再生成中间文件，直接生成可执行文件</span><br>target=main.exe<br><span class="hljs-variable">$</span>(target):<span class="hljs-variable">$</span>(src)<br><span class="hljs-variable">$</span>(CC) <span class="hljs-variable">$</span>(CFLAGS) <span class="hljs-variable">$</span>(src) <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span>(target) <span class="hljs-literal">-lpthread</span><br><br>.PHONY: clean<br>clean:<br><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> main *.o<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;threadpool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">taskFunc</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> num = *(<span class="hljs-type">int</span>*)arg;<br>    cout&lt;&lt;<span class="hljs-string">&quot;thread &quot;</span>&lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt;<span class="hljs-string">&quot; is working, number = &quot;</span>&lt;&lt;num&lt;&lt;endl; <br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-comment">// 创建线程池</span><br>    ThreadPool* pool = <span class="hljs-built_in">threadPoolCreate</span>(<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">// 做小运行线程数为3，最大运行线程数为10，线程池中队列大小为100</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>        <span class="hljs-type">int</span>* num = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        *num = i + <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">threadPoolAdd</span>(pool, taskFunc, num);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">30</span>);<br><br>    <span class="hljs-built_in">threadPoolDestroy</span>(pool);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>threadpool.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadPool</span> ThreadPool;<br><span class="hljs-comment">// 创建线程池并初始化</span><br><span class="hljs-function">ThreadPool* <span class="hljs-title">threadPoolCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> min,<span class="hljs-type">int</span> max,<span class="hljs-type">int</span> queueSize)</span></span>;<br><br><span class="hljs-comment">// 销毁线程池</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threadPoolDestroy</span><span class="hljs-params">(ThreadPool* pool)</span></span>;<br><br><span class="hljs-comment">// 给线程池加任务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadPoolAdd</span><span class="hljs-params">(ThreadPool* pool,<span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span>* arg)</span></span>;<br><br><span class="hljs-comment">// 获取线程池中工作的线程的个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threadPoolBusyNum</span><span class="hljs-params">(ThreadPool* pool)</span></span>;<br><br><span class="hljs-comment">// 获取线程池中活着的线程的个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threadPoolAliveNum</span><span class="hljs-params">(ThreadPool* pool)</span></span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">manager</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadExit</span><span class="hljs-params">(ThreadPool* pool)</span></span>;<br><br></code></pre></td></tr></table></figure><p>threadpool.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;threadpool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUMBER = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 任务结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span><br>&#123;<br>    <span class="hljs-built_in">void</span> (*function)(<span class="hljs-type">void</span> *arg);<br>    <span class="hljs-type">void</span> *arg;<br>&#125; Task;<br><br><span class="hljs-comment">// 线程池结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadPool</span><br>&#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    Task *taskQ;<br>    <span class="hljs-type">int</span> queueCapacity; <span class="hljs-comment">// 容量</span><br>    <span class="hljs-type">int</span> queueSize;     <span class="hljs-comment">// 当前任务个数</span><br>    <span class="hljs-type">int</span> queueFront;    <span class="hljs-comment">// 队头-&gt; 取数据</span><br>    <span class="hljs-type">int</span> queueRear;     <span class="hljs-comment">// 队尾-&gt; 放数据</span><br><br>    <span class="hljs-type">pthread_t</span> managerID;       <span class="hljs-comment">// 管理者线程ID</span><br>    <span class="hljs-type">pthread_t</span> *threadIDs;      <span class="hljs-comment">// 工作者线程ID</span><br>    <span class="hljs-type">int</span> minNum;                <span class="hljs-comment">// 最小线程数目</span><br>    <span class="hljs-type">int</span> maxNum;                <span class="hljs-comment">// 最大线程数目</span><br>    <span class="hljs-type">int</span> busyNum;               <span class="hljs-comment">// 忙线程个数</span><br>    <span class="hljs-type">int</span> liveNum;               <span class="hljs-comment">// 存活线程个数</span><br>    <span class="hljs-type">int</span> exitNum;               <span class="hljs-comment">// 要杀死的线程个数</span><br>    <span class="hljs-type">pthread_mutex_t</span> mutexpool; <span class="hljs-comment">// 锁整个线程池</span><br>    <span class="hljs-type">pthread_mutex_t</span> mutexBusy; <span class="hljs-comment">// 锁busyNum</span><br>    <span class="hljs-type">pthread_cond_t</span> notFull;    <span class="hljs-comment">// 任务队列是否满了</span><br>    <span class="hljs-type">pthread_cond_t</span> notEmpty;   <span class="hljs-comment">// 任务队列是否空了</span><br><br>    <span class="hljs-type">int</span> shutdown; <span class="hljs-comment">// 是不是要销毁线程池，销毁为1，不销毁为0</span><br>&#125;;<br><br><span class="hljs-function">ThreadPool *<span class="hljs-title">threadPoolCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> queueSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    ThreadPool *pool = (ThreadPool *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ThreadPool));<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc threadpool failed..\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        pool-&gt;threadIDs = (<span class="hljs-type">pthread_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_t</span>) * max);<br>        <span class="hljs-keyword">if</span> (pool-&gt;threadIDs == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc threadIDs failed..\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(pool-&gt;threadIDs, <span class="hljs-number">0</span>, max); <span class="hljs-comment">// 线程全部初始化为0，存储线程的时候，根据线程id去判断，如果是无符号整型就是已经占用了，如果是0就还没有被占用</span><br>        pool-&gt;minNum = min;<br>        pool-&gt;maxNum = max;<br>        pool-&gt;busyNum = <span class="hljs-number">0</span>;<br>        pool-&gt;liveNum = min; <span class="hljs-comment">// 和最小个数相等</span><br>        pool-&gt;exitNum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;pool-&gt;mutexpool, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            <span class="hljs-built_in">pthread_mutex_init</span>(&amp;pool-&gt;mutexBusy, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            <span class="hljs-built_in">pthread_cond_init</span>(&amp;pool-&gt;notEmpty, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            <span class="hljs-built_in">pthread_cond_init</span>(&amp;pool-&gt;notFull, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mutex or cond init failed..\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 任务队列</span><br>        pool-&gt;taskQ = (Task*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Task)*queueSize);<br>        pool-&gt;queueCapacity = queueSize;<br>        pool-&gt;queueSize = <span class="hljs-number">0</span>;<br>        pool-&gt;queueFront = <span class="hljs-number">0</span>;<br>        pool-&gt;queueRear = <span class="hljs-number">0</span>;<br><br>        pool-&gt;shutdown = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">pthread_create</span>(&amp;pool-&gt;managerID, <span class="hljs-literal">NULL</span>, manager, pool); <span class="hljs-comment">// 管理线程调用管理函数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; min; i++)<br>        &#123;<br>            <span class="hljs-built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, pool); <span class="hljs-comment">// 工作线程调用worker函数</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pool; <span class="hljs-comment">//正常执行到这里</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 如果出现问题，就释放相关的数据和资源。</span><br>    <span class="hljs-keyword">if</span>(pool &amp;&amp; pool-&gt;threadIDs)&#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;threadIDs);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pool &amp;&amp; pool-&gt;taskQ)&#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;taskQ);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pool)<br>        <span class="hljs-built_in">free</span>(pool);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    ThreadPool* pool = (ThreadPool*) arg;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool); <span class="hljs-comment">//对线程池上锁</span><br>        <span class="hljs-keyword">while</span>(pool-&gt;queueSize == <span class="hljs-number">0</span> &amp;&amp; !pool-&gt;shutdown)&#123;<br>            <span class="hljs-comment">// 阻塞工作线程</span><br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexpool);<br>            <span class="hljs-comment">// 判断是不是要销毁线程</span><br>            <span class="hljs-keyword">if</span> (pool-&gt;exitNum&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                pool-&gt;exitNum--;<br>                <span class="hljs-keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum)<br>                &#123;<br>                    pool-&gt;liveNum--;<br>                    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>                    <span class="hljs-built_in">threadExit</span>(pool);<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断线程是否被关闭了</span><br>        <span class="hljs-keyword">if</span>(pool-&gt;shutdown)&#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>            <span class="hljs-built_in">threadExit</span>(pool);<br>        &#125;<br><br>        <span class="hljs-comment">// 从任务队列中取出一个任务</span><br>        Task task;<br>        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;<br>        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;<br>        <span class="hljs-comment">// 移动头结点</span><br>        pool-&gt;queueFront = (pool-&gt;queueFront+<span class="hljs-number">1</span>)%pool-&gt;queueCapacity; <span class="hljs-comment">//当队列头指针移动到尾部的时候，可以移动到头部，形成一个循环队列。</span><br>        pool-&gt;queueSize--;<br>        <span class="hljs-comment">// 唤醒生产者</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;pool-&gt;notFull);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool); <span class="hljs-comment">// 用完以后解锁</span><br><br>        <span class="hljs-comment">// 对工作线程加一，用到专门的锁</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %ld start working...\n&quot;</span>, <span class="hljs-built_in">pthread_self</span>());<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);<br>        pool-&gt;busyNum++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);<br><br>        task.<span class="hljs-built_in">function</span>(task.arg);<br>        <span class="hljs-built_in">free</span>(task.arg);<br>        task.arg = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %ld end working...\n&quot;</span>, <span class="hljs-built_in">pthread_self</span>());<br>        <span class="hljs-comment">// 任务执行完成，--，用到专门的锁</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);<br>        pool-&gt;busyNum--;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">manager</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    ThreadPool* pool = (ThreadPool*)arg;<br>    <span class="hljs-keyword">while</span> (!pool-&gt;shutdown)<br>    &#123;<br>        <span class="hljs-comment">// 每隔3s检测一次</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br>        <br>        <span class="hljs-comment">// 取出线程池中任务的数量和当前线程的数量</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>        <span class="hljs-type">int</span> queueSize = pool-&gt;queueSize;<br>        <span class="hljs-type">int</span> liveNum = pool-&gt;liveNum;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br><br>        <span class="hljs-comment">// 取出忙线程个数。</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);<br>        <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);<br><br>        <span class="hljs-comment">// 添加线程</span><br>        <span class="hljs-comment">// 任务的个数&gt; 存活线程的个数 &amp;&amp; 存活线程个数&lt; 最大线程个数</span><br>        <span class="hljs-keyword">if</span>(queueSize&gt;liveNum &amp;&amp; liveNum&lt;pool-&gt;maxNum)&#123;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>            <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span> ; i&lt;pool-&gt;maxNum &amp;&amp; counter&lt;NUMBER &amp;&amp; pool-&gt;liveNum&lt;pool-&gt;maxNum; ++i)&#123;<br>                <span class="hljs-keyword">if</span>(pool-&gt;threadIDs[i]==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i],<span class="hljs-literal">NULL</span>,worker,pool);<br>                    counter++;<br>                    pool-&gt;liveNum++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>        &#125;<br><br>        <span class="hljs-comment">// 销毁线程</span><br>        <span class="hljs-comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span><br>        <span class="hljs-keyword">if</span>(busyNum*<span class="hljs-number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)&#123;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>            pool-&gt;exitNum = NUMBER;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>            <span class="hljs-comment">// 让工作的线程自杀</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUMBER; ++i)<br>            &#123;<br>                <span class="hljs-built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty); <span class="hljs-comment">//唤醒工作线程</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadExit</span><span class="hljs-params">(ThreadPool* pool)</span></span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid = <span class="hljs-built_in">pthread_self</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;maxNum; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool-&gt;threadIDs[i] == tid)<br>        &#123;<br>            pool-&gt;threadIDs[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 修改为0以后，方便后续判断是否可以创建新线程</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;threadExit() called, %ld exiting...\n&quot;</span>, tid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadPoolAdd</span><span class="hljs-params">(ThreadPool* pool,<span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>    <span class="hljs-keyword">while</span>(pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)&#123;<br>        <span class="hljs-comment">// 阻塞生产者线程</span><br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;pool-&gt;notFull,&amp;pool-&gt;mutexpool);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pool-&gt;shutdown)&#123;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 添加任务</span><br>    pool-&gt;taskQ[pool-&gt;queueRear].function = func;<br>    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;<br>    pool-&gt;queueRear = (pool-&gt;queueRear+<span class="hljs-number">1</span>)% pool-&gt;queueCapacity;<br>    pool-&gt;queueSize++;<br><br>    <span class="hljs-built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threadPoolBusyNum</span><span class="hljs-params">(ThreadPool* pool)</span></span>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-keyword">return</span> busyNum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threadPoolAliveNum</span><span class="hljs-params">(ThreadPool* pool)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexpool);<br>    <span class="hljs-type">int</span> aliveNum = pool-&gt;liveNum;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexpool);<br>    <span class="hljs-keyword">return</span> aliveNum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threadPoolDestroy</span><span class="hljs-params">(ThreadPool* pool)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭线程池</span><br>    pool-&gt;shutdown = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 阻塞回收管理者线程</span><br>    <span class="hljs-built_in">pthread_join</span>(pool-&gt;managerID, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 唤醒阻塞的消费者线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;liveNum; ++i)<br>    &#123;<br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放堆内存</span><br>    <span class="hljs-keyword">if</span> (pool-&gt;taskQ)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;taskQ);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pool-&gt;threadIDs)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;threadIDs);<br>    &#125;<br><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;pool-&gt;mutexpool);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;pool-&gt;notEmpty);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;pool-&gt;notFull);<br><br>    <span class="hljs-built_in">free</span>(pool);<br>    pool = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考列表：<br><a href="https://subingwen.cn/linux/threadpool/">https://subingwen.cn/linux/threadpool/</a></p>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习八(线程同步)</title>
    <link href="/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E5%85%AB(%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5)/"/>
    <url>/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E5%85%AB(%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习八-线程同步"><a href="#Linux学习八-线程同步" class="headerlink" title="Linux学习八 : 线程同步"></a>Linux学习八 : 线程同步</h1><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p><code>临界资源</code>：被多个线程共享的资源，如共享内存，共享文件，共享设备等。<br><code>临界区</code>：在多线程程序中，访问共享内存的代码段。<br>线程同步是指多个线程在并发执行过程中，为了保持数据一致性，协调和合作的对数据进行访问。</p><ul><li>互斥锁：mutex：一个线程获得互斥锁，其他线程等待。</li><li>条件变量：Condition Variable：线程发现条件不满足时，调用条件变量的等待操作，直到其他线程对条件进行通知。</li><li>读写锁：ReadWrite Lock：读可以多线程，写只能有一个写入。</li><li>自旋锁：Spin Lock：忙等待的锁机制，循环等待，直到获得锁为止。</li><li>信号量：Semaphore：计数器，用于控制同时访问某个资源的线程数量。</li></ul><p><code>死锁</code>：两个或多个以上线程（或进程）互相等待对方持有的资源而无法继续执行的现象。<br><code>死锁产生的四个必要条件</code>：</p><ul><li>互斥条件：资源不能共享，只能被一个进程使用。</li><li>请求和保持条件：一个进程至少占有一个资源，并等待获取其他进程占有的资源。<ul><li>一次申请所有资源：资源利用率低，进程饿死。</li><li>提取新的请求时，释放原来占有的资源。</li></ul></li><li>不可剥夺条件：资源只能由进程释放，不可被剥夺。<ul><li>申请不到资源时，释放自己资源。</li><li>申请不到资源时，抢占对方资源。</li></ul></li><li>循环等待条件：存在等待立案条件，每个进程都在等待下一个进程所占有的资源。<ul><li>按照资源编号顺序提出请求。</li></ul></li></ul><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁：只有一个线程能访问被保护资源。需要初始化互斥量，加锁，解锁和销毁互斥量。</p><blockquote><p>pthread_mutex_t  mutex; 申请互斥锁。<br>int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);   初始化互斥锁<br>int pthread_mutex_lock(pthread_mutex_t *mutex); 上锁<br>int pthread_mutex_trylock(pthread_mutex_t *mutex); 尝试加锁，如果没锁，加锁成功；如果已经有锁，不会阻塞，直接返回失败。<br>int pthread_mutex_unlock(pthread_mutex_t *mutex);解锁，哪个线程加锁，就要哪个线程解锁。<br>int pthread_mutex_destroy(pthread_mutex_t *mutex); 销毁互斥锁。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">10000</span>;<br><span class="hljs-type">pthread_mutex_t</span> mutex; <span class="hljs-comment">//声明互斥锁</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread_proc1</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>            count--;<br>            cout&lt;&lt;<span class="hljs-string">&quot;t1 :&quot;</span>&lt;&lt;count&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread_proc2</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>            count--;<br>            cout&lt;&lt;<span class="hljs-string">&quot;t2 :&quot;</span>&lt;&lt;count&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pthread_t</span> t1,t2;<br><br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//初始化互斥锁</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;t1,<span class="hljs-literal">NULL</span>,thread_proc1,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;t2,<span class="hljs-literal">NULL</span>,thread_proc2,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(t1,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(t2,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex); <span class="hljs-comment">//线程销毁后，再去释放互斥锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-互斥锁"><a href="#C-互斥锁" class="headerlink" title="C++互斥锁"></a>C++互斥锁</h3><blockquote><p>std::mutex：独占的互斥锁，不能递归使用<br>std::timed_mutex：带超时的独占互斥锁，不能递归使用<br>std::recursive_mutex：递归互斥锁，不带超时功能，可以使一个线程多次获取锁。<br>std::recursive_timed_mutex：带超时的递归互斥锁</p></blockquote><p><code>std::mutex</code>的常用操作：</p><blockquote><p>lock()<br>unlock()<br>trylock()</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-comment">// 互斥锁的个数和共享资源的个数相等，而与线程的个数无关。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        a+=<span class="hljs-number">1</span>;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    std::cout&lt;&lt;a&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::lock_guard：</code>C++11新增的模板类，可以简化互斥锁lock()和unlock()的写法，自动进行加锁和解锁，同时也更安全。</p><ul><li>mutex需要自己加锁解锁。</li><li>lock_guard会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock()操作而导致线程死锁。<strong>一般在局部作用域中使用</strong>，使用完即使销毁。</li><li>lock_guard使用了RAII技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a+=<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>std::recursive_mutex</code>：递归互斥锁，允许同一线程多次获得互斥锁。<br><code>std::timed_mutex</code>：超时独占互斥锁，可以用做加超时的锁操作,mutex不支持超时锁设置。</p><p><code>std::unique_lock</code>： C++ 标准库中提供的一个互斥量封装类，也可以自动进行加锁和解锁，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。</p><blockquote><p>lock()：加锁<br>try_lock()：尝试加锁，不阻塞<br>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。<br>try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)：指定时间节点，阻塞<br>unlock()：对互斥量进行解锁操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::timed_mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;<br>    <br>        <span class="hljs-function">std::unique_lock&lt;std::timed_mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx,std::defer_lock)</span></span>; <span class="hljs-comment">//不加锁，需要自己加锁</span><br>        <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>)))&#123;<br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)); <br>            a+=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    std::cout&lt;&lt;a&lt;&lt;std::endl;  <span class="hljs-comment">//3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-call-once"><a href="#std-call-once" class="headerlink" title="std::call_once"></a>std::call_once</h3><p>在某些特定情况下，某些函数只能在多线程环境下调用一次。单例设计模式是一种常见的设计模式，用于确保某个类只能创建一个实例。由于单例实例是全局唯一的，因此在多线程环境中使用单例模式时，需要考虑线程安全的问题。</p><p><code>std::call_once()来保证函数在多线程环境下只能被调用一次。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-type">static</span> std::once_flag once;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_once</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout&lt;&lt;__TIME__&lt;&lt;<span class="hljs-string">&quot; once&quot;</span>&lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_twice</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">call_once</span>(once, print_once);<br>    std::cout&lt;&lt;__TIME__&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_twice)</span></span>; <span class="hljs-comment">//线程不安全的情况下，可能会对log进行多次赋值，出现错误</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_twice)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><code>条件变量用来阻塞线程，直到某个特定条件得到满足。</code>只使用条件变量无法实现线程的同步, 必须要配合互斥锁来使用。<br><code>当一个线程需要等待某个条件满足时，它可以通过条件变量将自己阻塞，同时释放互斥锁，使其他线程可以继续执行。条件变量提供了一个可以让多个线程间同步协作的功能。这对于生产者-消费者模型很有意义。</code></p><blockquote><p>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr); 条件变量初始化<br>也可以用静态初始化进行：pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;<br>int pthread_cond_destroy(pthread_cond_t *cond); 条件变量销毁。<br>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); 等待阻塞，阻塞的过程中需要一个互斥锁参数，互斥锁让线程进入临界区，避免数据混乱。</p><ul><li>在阻塞线程时候，如果线程对互斥锁mutex上锁，那么会将这把锁打开，避免死锁。</li><li>线程解除阻塞的时候，函数内部会将这个mutex互斥锁锁上，继续访问临界区。</li></ul><p>int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); 等待超时等待。<br>int pthread_cond_signal(pthread_cond_t *cond); 唤醒单个线程。<br>int pthread_cond_broadcast(pthread_cond_t *cond); 唤醒全部线程。</p></blockquote><p><code>有了锁以后为什么还需要条件变量？</code></p><ul><li>锁和条件变量解决的不是同一个问题，锁解决的是访问临界区资源的竞争。</li><li>条件变量是为了不让线程重复性的加锁解锁。比如有两个线程，线程A和线程B都在竞争资源，但是线程B在满足一定条件的时候才需要执行，如果没有条件变量，就会出现线程B也需要不断地加锁，解锁，这样给系统带来了不必要的开销，浪费了资源。如何让线程B不再不断地加锁解锁，就需要用到条件变量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    iCount++;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>&#125;<br><br><br><span class="hljs-comment">//thread 2:</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">if</span>(iCount &gt;= <span class="hljs-number">100</span>)<br>    &#123;<br>        iCount = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>让线程B不再不断地加锁解锁，用到条件变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//thread1 :</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    iCount++;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br><br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">if</span>(iCount &gt;= <span class="hljs-number">100</span>)<br>    &#123;<br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond);<br>    &#125;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>&#125;<br><br><span class="hljs-comment">//thread2:</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">while</span>(iCount &lt; <span class="hljs-number">100</span>)<br>    &#123;<br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;iCount &gt;= 100\r\n&quot;</span>);<br>    iCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-条件变量"><a href="#C-条件变量" class="headerlink" title="C++条件变量"></a>C++条件变量</h3><p>C++中的条件变量有两种：</p><ul><li>condition_variable：需要配合std::unique_lock&lt; std::mutex&gt;进行wait操作，也就是阻塞线程的操作。</li><li>condition_variable_any：可以和任意带有lock()、unlock()语义的mutex搭配使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; g_queue;<br>std::condition_variable g_cv;<br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        g_queue.<span class="hljs-built_in">push</span>(i);<br>        g_cv.<span class="hljs-built_in">notify_one</span>();<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;task: &quot;</span>&lt;&lt;i&lt;&lt;std::endl;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">microseconds</span>(<span class="hljs-number">10</span>));<br>        <br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Customer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        g_cv.<span class="hljs-built_in">wait</span>(lock, []()&#123;<br>            <span class="hljs-keyword">return</span> !g_queue.<span class="hljs-built_in">empty</span>();<br>        &#125;);<br><br>        <span class="hljs-type">int</span> value = g_queue.<span class="hljs-built_in">front</span>();<br>        g_queue.<span class="hljs-built_in">pop</span>();<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Customer &quot;</span>&lt;&lt;value&lt;&lt;std::endl;<br>        <br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(Producer)</span></span>; <span class="hljs-comment">//线程不安全的情况下，可能会对log进行多次赋值，出现错误</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(Customer)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><code>读写锁是一种并发控制机制，允许多个线程同时读取共享资源，但只允许一个线程进行写操作。</code></p><ul><li>读操作之间不会互斥。</li><li>写操作之间会互斥。</li></ul><p>读写锁一般分为两种类型：读锁和写锁。</p><ul><li>请求读锁时，如果没有其他线程持有写锁，则可以读，否则需要等待写锁。</li><li>获取写锁时，如果没有其他线程在持有读锁或写锁，可以写，否则等待写锁和读锁都释放。</li></ul><p>读写锁的优点：</p><ol><li>多个线程可以同时读共享资源，提高了并发性能。</li><li>写操作独占资源，保证了数据的完整性和一致性。</li></ol><blockquote><p>pthread_rwlock_init ：读写锁初始化<br>pthread_rwlock_rdlock ：读加锁<br>pthread_rwlock_tryrdlock ：尝试读加锁<br>pthread_rwlock_timerdlock ：超时读加锁<br>pthread_rwlock_wrlock ：写加锁<br>pthread_rwlock_trywrlock ：尝试写加锁<br>pthread_rwlock_timewrlock ：超时写加锁<br>pthread_rwlock_unlock ：解锁（读写共用）<br>pthread_rwlock_destroy ：读写锁销毁<br>还有一些属性操作的函数：比如读优先&#x2F;写优先。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-type">pthread_rwlock_t</span> rwlock; <span class="hljs-comment">//读写锁声明</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread_proc1</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 读锁</span><br>        <span class="hljs-built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);<br>        cout&lt;&lt;<span class="hljs-string">&quot;t1 :&quot;</span>&lt;&lt;count&lt;&lt;endl;<br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread_proc2</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 写锁</span><br>        <span class="hljs-built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);<br>        count++;<br>        cout&lt;&lt;<span class="hljs-string">&quot;t2 :&quot;</span>&lt;&lt;count&lt;&lt;endl;<br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">pthread_rwlock_init</span>(&amp;rwlock,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 读写锁初始化。</span><br><br>    <span class="hljs-type">pthread_t</span> t1,t2;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;t1,<span class="hljs-literal">NULL</span>,thread_proc1,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;t2,<span class="hljs-literal">NULL</span>,thread_proc2,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(t1,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(t2,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_rwlock_destroy</span>(&amp;rwlock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><code>自旋锁是一种忙等待的锁，当线程尝试获取锁时，如果发现锁被其他线程持有，它会一直不断地进行忙等待，直到获取锁为止。</code></p><ul><li>优点：避免了进程的切换，线程会一直在一个循环中进行忙等待，直到锁被释放为止。</li><li>缺点：如果获取锁的线程长时间不释放锁，其他线程会一直忙等待消耗CPU资源。</li></ul><p>适用场景：临界区代码执行时间短，并发冲突的概率较低，线程在获取到锁之间的等待时间较短。</p><blockquote><p>pthread_spin_init ： 自旋锁初始化<br>pthread_spin_lock ： 自旋锁加锁<br>pthread_spin_trylock ： 尝试加锁<br>pthread_spin_unlock ： 解锁<br>pthread_spin_destroy ： 自旋锁销毁</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">10000</span>;<br><span class="hljs-type">pthread_spinlock_t</span> spin; <span class="hljs-comment">//声明自旋锁</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread_proc1</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">pthread_spin_lock</span>(&amp;spin);<br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>            count--;<br>            cout&lt;&lt;<span class="hljs-string">&quot;t1 :&quot;</span>&lt;&lt;count&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-built_in">pthread_spin_unlock</span>(&amp;spin);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread_proc2</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">pthread_spin_lock</span>(&amp;spin);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>            count--;<br>            cout&lt;&lt;<span class="hljs-string">&quot;t2 :&quot;</span>&lt;&lt;count&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-built_in">pthread_spin_unlock</span>(&amp;spin);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pthread_t</span> t1,t2;<br><br>    <span class="hljs-built_in">pthread_spin_init</span>(&amp;spin,<span class="hljs-number">0</span>); <span class="hljs-comment">//初始化自旋锁</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;t1,<span class="hljs-literal">NULL</span>,thread_proc1,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;t2,<span class="hljs-literal">NULL</span>,thread_proc2,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(t1,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(t2,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_spin_destroy</span>(&amp;spin); <span class="hljs-comment">//线程销毁后，再去释放自旋锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到线程的CPU使用率非常高，自旋锁一直处于自旋的状态。相比于mutex来说，非常高，所以需要根据同步类型使用锁。<br><img src="https://pic.imgdb.cn/item/66040d829f345e8d03b34676.png" alt="在这里插入图片描述"></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量维护了一个内部计数器，用于表示可用资源的数量。</p><blockquote><p>int sem_init(sem_t *sem, int pshared, unsigned int value);：初始化无名信号量，用于线程通信。<br>int sem_destroy(sem_t *sem); 销毁信号量<br>int sem_wait(sem_t *sem); 信号量等待，如果信号量&lt;0会阻塞。<br>int sem_trywait(sem_t *sem);信号量尝试等待，如果信号量&lt;0不会阻塞。<br>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); 信号量超时等待。<br>int sem_post(sem_t *sem);信号量增加。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">10000</span>;<br><span class="hljs-type">sem_t</span> sem;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread_proc1</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        count++;<br>        cout&lt;&lt;<span class="hljs-string">&quot;t1 :&quot;</span>&lt;&lt;count&lt;&lt;endl;<br>        <span class="hljs-built_in">sem_post</span>(&amp;sem);<span class="hljs-comment">// V操作，信号量+1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread_proc2</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>       <span class="hljs-built_in">sem_wait</span>(&amp;sem);<br>       <span class="hljs-comment">// sem_trywait(&amp;sem);</span><br>       cout&lt;&lt;<span class="hljs-string">&quot;t2 :&quot;</span>&lt;&lt;count&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pthread_t</span> t1,t2;<br><br>    <span class="hljs-built_in">sem_init</span>(&amp;sem,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">pthread_create</span>(&amp;t1,<span class="hljs-literal">NULL</span>,thread_proc1,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;t2,<span class="hljs-literal">NULL</span>,thread_proc2,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(t1,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(t2,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">sem_destroy</span>(&amp;sem); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考列表<br><a href="https://www.bilibili.com/video/BV14Q4y187xp/">https://www.bilibili.com/video/BV14Q4y187xp/</a><br><a href="https://subingwen.cn/linux/thread-sync/">https://subingwen.cn/linux/thread-sync/</a><br><a href="https://www.bilibili.com/video/BV1d841117SH">https://www.bilibili.com/video/BV1d841117SH</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习七(线程)</title>
    <link href="/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%B8%83(%E7%BA%BF%E7%A8%8B)/"/>
    <url>/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%B8%83(%E7%BA%BF%E7%A8%8B)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习七-线程"><a href="#Linux学习七-线程" class="headerlink" title="Linux学习七 : 线程"></a>Linux学习七 : 线程</h1><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><p><code>线程是轻量级的进程</code>：在操作系统中，将一个进程划分为多个执行单元，<strong>每个单元拥有自己的堆栈、程序计数器和资源使用情况</strong>，但<strong>共享同一进程的地址空间和文件描述符等资源</strong>，这些执行单元就是线程。<code>进程是资源分配的最小单位，线程是系统调度的最小单位。</code></p><p>线程特点：</p><ul><li>线程的创建、切换和销毁都更加高效，占用的系统资源少。</li><li>线程提供了一种并发执行的机制，使得多个任务可以在同一个进程中并行执行。</li><li>不同线程之间可以通过共享内存等机制进行通信和同步，数据共享更加便捷，且避免了进程切换的开销。</li><li>线程能够利用多核处理器的并发执行有事，提高系统的吞吐能力，一定程度下可以提升系统性能。CPU有多少个核就可以开多少个线程。</li><li>由于线程共享进程的地址空间，因此需要注意线程之间的数据竞争和同步，调度资源并发编程问题，充分考虑线程安全和并发控制，以确保程序的正确性和稳定性。</li></ul><p>线程的实现主要通过引入线程组的概念来实现。每个进程都有一个主线程，也就是创建该进程的线程，当创建新的线程时，新的线程将与主线程一起组成一个线程组。</p><p><code>多进程模型</code>：每个进程都有独立的地址空间、文件表信号表等资源。<br><code>多线程模型</code>：线程组内线程共享地址内存空间，文件表信号表等资源。</p><p><code>实现多线程的目的</code>：为了更高效的利用CPU资源，线程相比于进程，创建、切换、通信、终止成本降低。<strong>线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。<br>因此，在设计并发系统之前，一方面我们需要做好对于硬件性能的了解，另一方面需要对我们的任务有足够的认识。</strong></p><p><code>线程的缺点</code></p><ul><li>安全性差：线程相互耦合，一个线程出错会影响其他线程。</li><li>编程难度大：</li><li>调试困难</li><li>竞态条件和死锁：需要线程同步管理。</li></ul><h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><p><code>创建线程</code></p><blockquote><p>pthread_create：Linux下用于创建线程的函数，需要给线程一个处理函数，否则线程无法工作。<br>线程属性：可以在线程创建时指定的一组特性，用于控制线程的行为和特性。比如线程调度优先级，调度策略，线程栈空间大小。<br>pthread_self()：获取线程id。</p></blockquote><p><code>线程退出</code>：只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。</p><blockquote><p>#include &lt;pthread.h&gt;<br>void pthread_exit(void *retval);retval是子线程的主线程会得到该数据。如果不需要使用，指定为NULL</p></blockquote><p><code>线程回收</code>：等待一个线程结束并回收器返回值和线程资源。pthread_join()，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程。</p><blockquote><p>#include &lt;pthread.h&gt;<br>&#x2F;&#x2F; 这是一个阻塞函数, 子线程在运行这个函数就阻塞<br>&#x2F;&#x2F; 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()<br>int pthread_join(pthread_t thread, void **retval);</p></blockquote><p><code>回收子线程数据的方法：</code></p><blockquote><ul><li>用子线程栈区是不可以的，因为每个线程都有一个独立的栈区，子线程结束以后，数据不能回传给主线程。</li><li>用堆区和全局数据区，是可以的，位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但是可以共享全局数据区和堆区数据，因此在子线程退出的时候可以将传出数据存储到全局变量、静态变量或者堆内存中。</li><li>回传到主线程栈区是可以的，一般情况下主线程栈区都是最后退出的。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <span class="hljs-type">int</span> id;<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> Person_GLOBAL;<span class="hljs-comment">// 定义全局变量</span><br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">workingThread1</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> p;<br>    p.age = <span class="hljs-number">27</span>;<br>    p.name= <span class="hljs-string">&quot;liubei&quot;</span>;<br>    p.id = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">pthread_exit</span>(&amp;p);<span class="hljs-comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 代码执行不到这个位置就退出了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">workingThread2</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    Person_GLOBAL.age = <span class="hljs-number">25</span>;<br>    Person_GLOBAL.name= <span class="hljs-string">&quot;guanyu&quot;</span>;<br>    Person_GLOBAL.id = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">pthread_exit</span>(&amp;Person_GLOBAL);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">workingThread3</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>* p = (<span class="hljs-keyword">struct</span> Person*)arg;<br>    p-&gt;age = <span class="hljs-number">24</span>;<br>    p-&gt;name= <span class="hljs-string">&quot;zhangfei&quot;</span>;<br>    p-&gt;id = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">pthread_exit</span>(&amp;p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建子线程</span><br>    <span class="hljs-type">pthread_t</span> tid1;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;tid1, <span class="hljs-literal">NULL</span>, workingThread1, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">void</span>* ptr1 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span><br>    <span class="hljs-comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span><br>    <span class="hljs-built_in">pthread_join</span>(tid1, &amp;ptr1);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>* p1 = (<span class="hljs-keyword">struct</span> Person*)ptr1;<br>    cout&lt;&lt;<span class="hljs-string">&quot;线程栈返回数据：&quot;</span>&lt;&lt;p1-&gt;id&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p1-&gt;age&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p1-&gt;name&lt;&lt;endl;<br><br>    <span class="hljs-type">pthread_t</span> tid2;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;tid2, <span class="hljs-literal">NULL</span>, workingThread2, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">void</span>* ptr2 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">pthread_join</span>(tid2, &amp;ptr2);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>* p2 = (<span class="hljs-keyword">struct</span> Person*)ptr2;<br>    cout&lt;&lt;<span class="hljs-string">&quot;全局变量返回数据：&quot;</span>&lt;&lt;p2-&gt;id&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p2-&gt;age&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p2-&gt;name&lt;&lt;endl;<br><br>    <span class="hljs-type">pthread_t</span> tid3;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> p;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;tid3, <span class="hljs-literal">NULL</span>, workingThread3, &amp;p);<br>    <span class="hljs-type">void</span>* ptr3 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">pthread_join</span>(tid3, &amp;ptr3);<br>    cout&lt;&lt;<span class="hljs-string">&quot;主线程栈返回数据：&quot;</span>&lt;&lt;p.id&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p.age&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p.name&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终运行的结果中子线程栈空间的数据丢失。<br><img src="https://pic.imgdb.cn/item/66040f2d9f345e8d03c25817.png" alt="在这里插入图片描述"></p><p><code>线程分离</code>：将一个线程从它的创建线程中分离出来，使得该线程不会成为“僵尸线程”，从而避免资源泄露和内存占用的问题。不需要其他线程调用pthread_join()函数来等待其终止，但是在终止后不能再重连。</p><blockquote><p>pthread_detach(tid);线程分离。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">working</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;子线程ID: &quot;</span>&lt;&lt;<span class="hljs-built_in">pthread_self</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;参数: &quot;</span>&lt;&lt;(<span class="hljs-type">char</span>*)arg&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">char</span>* arg= <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>, working, arg);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        cerr&lt;&lt;<span class="hljs-string">&quot;pthread_create&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置子线程和主线程分离</span><br>    <span class="hljs-built_in">pthread_detach</span>(tid);<br>    <span class="hljs-comment">// 让主线程自己退出即可</span><br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">create</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>线程终止</code>：</p><ul><li>自然终止</li><li>调用exit()函数：立即终止整个进程，包括所有线程。</li><li>pthread_cancel()函数：线程取消</li><li>pthread_kill()函数：杀死线程。</li><li>pthread_exit()函数：显式退出线程</li></ul><p><code>线程取消</code>：在一个线程中杀死另一个线程，需要分两步：</p><ol><li>在线程A中调用线程取消函数pthread_cancel，指定杀死线程B，这时候线程B是死不了的。</li><li>在线程B中进程一次系统调用（从用户区切换到内核区），否则线程B可以一直运行。</li></ol><p>线程取消的类型：</p><ul><li>异步取消：立即取消线程，但是可能会出现无法清理，资源泄露的情况。</li><li>延迟取消：在取消点检查是否请求取消。如IO操作，线程等待函数等。</li></ul><blockquote><p>pthread_cancel()函数：线程取消。<br>pthread_setcanceltype()函数：设置线程取消的取消类型。</p></blockquote><h2 id="C-线程类"><a href="#C-线程类" class="headerlink" title="C++线程类"></a>C++线程类</h2><p>C++11中提供的线程类为std::thread，基于这个类创建一个新的线程非常的简单，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。作为一个类，类的构造函数，移动构造都有，但是不允许拷贝线程对象。</p><blockquote><p>std::thread t1(); 可以传线程执行函数，以及函数所需参数。<br>std::thread::id get_id() const noexcept; 获取线程ID。<br>void join(); 回收线程<br>void detch(); 线程分离<br>bool joinable() const noexcept; 用于判断主线程和子线程是否处理关联（连接）状态。<br>&#x2F;&#x2F; move (1)<br>thread&amp; operator&#x3D; (thread&amp;&amp; other) noexcept;<br>&#x2F;&#x2F; copy [deleted] (2)<br>thread&amp; operator&#x3D; (const other&amp;) &#x3D; delete; 线程中的资源是不能被复制的，因此通过&#x3D;操作符进行赋值操作最终并不会得到两个完全相同的对象。只能进行线程资源的转移，直接拷贝赋值是不被允许的。<br>static unsigned hardware_concurrency() noexcept; 获取当前计算机的CPU核数，根据这个结果在程序中创建出数量相等的线程，每个线程独自占有一个CPU核心，这些线程就不用分时复用CPU时间片，此时程序的并发效率是最高的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::thread;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;hello func&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printHW</span><span class="hljs-params">(string msg)</span></span>&#123;<br>    cout&lt;&lt;msg&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> num = thread::<span class="hljs-built_in">hardware_concurrency</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;CPU number: &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(printHW,<span class="hljs-string">&quot;Happy new year&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span>(t1.<span class="hljs-built_in">joinable</span>())&#123;<br>        t1.<span class="hljs-built_in">join</span>();<span class="hljs-comment">// 等待t1执行完成</span><br>    &#125;<br><br>    std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(&amp;A::func, a)</span></span>;<br>    <span class="hljs-keyword">if</span>(t2.<span class="hljs-built_in">joinable</span>())&#123;<br>        t2.<span class="hljs-built_in">join</span>();<span class="hljs-comment">// 等待t1执行完成</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考列表<br><a href="https://subingwen.cn/linux/thread/">https://subingwen.cn/linux/thread/</a><br><a href="https://www.bilibili.com/video/BV1Xb4y1u7gR/">https://www.bilibili.com/video/BV1Xb4y1u7gR/</a><br><a href="https://www.bilibili.com/video/BV1d841117SH">https://www.bilibili.com/video/BV1d841117SH</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习六(进程间通信)</title>
    <link href="/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E5%85%AD(%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)/"/>
    <url>/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E5%85%AD(%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习六-进程间通信"><a href="#Linux学习六-进程间通信" class="headerlink" title="Linux学习六 : 进程间通信"></a>Linux学习六 : 进程间通信</h1><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p><code>进程间通信（IPC）：指多个进程之间传输数据或共享信息的机制，在操作系统中每个进程的地址空间和资源是独立的，为了实现多个进程间的数据交换和协作，需要使用IPC机制。</code>最终结果就是进程能够访问相同的内存区域。</p><p>进程间通信的方法：</p><ul><li>管道：有名管道，无名管道。</li><li>消息队列</li><li>信号量</li><li>共享内存：内存映射实现，共享内存传递数据。</li><li>信号：通过特定信号执行处理情况。</li><li>socket：主要是网络通信中用到。</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><code>无名管道</code>：有亲缘关系的进程间单向通信。<strong>管道的本质其实就是内核中的一块内存(或者叫内核缓冲区)，这块缓冲区中的数据存储在一个环形队列中</strong>，因为管道在内核里边，因此我们不能直接对其进行任何操作。</p><ul><li>半双工，数据单向流动，要实现全双工通信，要用两个管道。</li><li>字节流通信，数据格式由用户自行定义</li><li>多用于父子进程间</li><li>管道对应的内核缓冲区大小是固定的，默认为4k</li></ul><p><code>无名管道实现原理</code>：<br>*父进程调用pipe函数会创建两个文件分别用作读和写，对应节点为pipe inode。<br>*父进程调用fork创建子进程，子进程拷贝父进程的文件表，由于父子进程文件表内容相同，指向的file相同，所以最终父子进程操作的pipe管道相同。<br>*fork函数成功后，父子进程不能同时保留读写文件描述符，<strong>需要关闭读或写文件描述符</strong>，防止父子进程同时读写引发数据错误。<br><img src="https://pic.imgdb.cn/item/66040e2f9f345e8d03b93744.png" alt="在这里插入图片描述"><br>创建无名管道进行父子进程的通信：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe_test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    ret = fork();<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        string s = <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">write</span>(fd[<span class="hljs-number">1</span>],s.<span class="hljs-built_in">c_str</span>(),s.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">read</span>(fd[<span class="hljs-number">0</span>],buf,<span class="hljs-number">1024</span>);<br>            cout&lt;&lt;buf&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">pipe_test</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>有名管道</code>：（FIFO文件）是一种特殊类型的文件，在磁盘上有实体文件, 文件类型为p ，<strong>有名管道文件大小永远为0，因为有名管道也是将数据存储到内存的缓冲区中</strong>，打开这个磁盘上的管道文件就可以得到操作有名管道的文件描述符，通过文件描述符读写管道存储在内核中的数据。</p><ul><li>可以通过名称进行识别和访问，而不仅仅依赖于文件描述符，因此相比于无名管道，有名管道可以用于没有亲缘关系的进程间通信。</li><li>可以像其他文件一样进行访问和管理，文件类型为p。</li><li>半双工通信，同时写入和读取操作，但需要多个fifo文件。</li></ul><p>有名管道的创建方式有两种：</p><ul><li>通过命令：mkfifo 文件名</li><li>通过函数：int mkfifo(const char *pathname, mode_t mode); pathname是要创建的管道的名字，mode为文件权限。<br><img src="https://pic.imgdb.cn/item/66040e4b9f345e8d03ba2349.png" alt="在这里插入图片描述"><br><code>有名管道实现原理</code>：管道创建成功以后，进程调用open打开FIFO文件，多个进程都可以打开相同的inode节点，进程间都可以看到管道内存空间，所以进程间能够正常通信。<code>多个进程同时读写一个命名管道可能会出现数据异常，所以进程调用open函数时需要指定打开标志为O_RDONLY或者O_WRONLY</code>。<br><img src="https://pic.imgdb.cn/item/66040e5e9f345e8d03baccce.png" alt="在这里插入图片描述"></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIFO_PATH <span class="hljs-string">&quot;./testfifo&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fifo_read</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-type">int</span> rfd = <span class="hljs-built_in">open</span>(FIFO_PATH, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(rfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">read</span>(rfd,buf,<span class="hljs-number">1024</span>);<br>        cout&lt;&lt;buf&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(rfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fifo_write</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">mkfifo</span>(FIFO_PATH,<span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>((ret == <span class="hljs-number">-1</span>)&amp;&amp; errno!= EEXIST)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> wfd = <span class="hljs-built_in">open</span>(FIFO_PATH, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(wfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">100</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;hello, fifo, 我在写管道...%d\n&quot;</span>, i);<br>        <span class="hljs-built_in">write</span>(wfd, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        i++;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(wfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fifo_test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ret = fork();<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fifo_read</span>();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fifo_write</span>();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">fifo_test</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>System V消息队列：允许在同一系统上运行的不同进程间进行消息传递。</p><ul><li>可以实现独立的进程间通信，不受进程的启动和结束顺序的影响。</li><li>允许多个进程同时向消息队列中写入和读取消息，实现了并发处理。</li><li>通过消息优先级机制，可以优先处理重要的消息。</li></ul><p><code>消息队列实现原理</code>：具有相同IPC命名空间的进程可以同时访问IPC命名空间相同内存。<br><img src="https://pic.imgdb.cn/item/66040e6f9f345e8d03bb6a43.png" alt="在这里插入图片描述"><br><code>IPC对象是消息队列，信号量，共享内存的父对象</code></p><ul><li>ftok函数用于产生Sytem V键值。</li><li>msgget函数用于创建或获取一个System V消息队列，返回标识ID，后续根据标识ID查找消息队列进行进程间通信。</li><li>msgsnd函数将一个消息添加到一个指定的消息队列中。msgsnd函数的参数非常重要，需要仔细查阅用法。</li><li>msgrvc函数接收缓冲区中的消息。</li><li>msgctl函数对消息队列中进行控制操作。</li></ul><blockquote><p>ipcs命令可用于查看System V IPC对象信息（消息队列，信号量，共享内存）<br>ipcs -a &#x2F;&#x2F; 查看消息队列，信号量，共享内存<br>ipcs -q &#x2F;&#x2F; 查看消息队列<br>ipcmk主要用于创建IPC对象信息。<br>ipcmk -Q 创建消息队列<br>ipcrm -q 删除消息队列</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 打开两个终端进行读写即可看到消息队列的交互</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">message</span> &#123;<br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">100</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>&#123;<br><br>    <span class="hljs-type">int</span> mode = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-type">key_t</span> key = <span class="hljs-number">1234</span>;<span class="hljs-comment">//也可以用ftok</span><br>    <span class="hljs-type">int</span> id = <span class="hljs-built_in">msgget</span>(key,<span class="hljs-number">0644</span>|IPC_CREAT); <span class="hljs-comment">//通过key值创建消息队列</span><br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(mode == <span class="hljs-number">0</span>)&#123;<br>            message msg;<br>            msg.mtype = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">msgrcv</span>(id, &amp;msg, <span class="hljs-built_in">sizeof</span>(msg), msg.mtype, <span class="hljs-number">0</span>); <span class="hljs-comment">// 接收消息</span><br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;msgrcv&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cout&lt;&lt;<span class="hljs-string">&quot; type: &quot;</span>&lt;&lt;msg.mtype &lt;&lt;<span class="hljs-string">&quot; mtext: &quot;</span>&lt;&lt;msg.mtext&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            message msg;<br>            msg.mtype = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>            <span class="hljs-built_in">strcpy</span>(msg.mtext, <span class="hljs-string">&quot;Hello Message Queue&quot;</span>); <span class="hljs-comment">//可以手动输入</span><br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">msgsnd</span>(id,&amp;msg,<span class="hljs-built_in">sizeof</span>(msg),<span class="hljs-number">0</span>); <span class="hljs-comment">// 发送消息</span><br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;msgsnd&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">msgctl</span>(id,IPC_RMID,<span class="hljs-number">0</span>); <span class="hljs-comment">// 通过id删除消息队列</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>POSIX消息队列</code>：POSIX消息队列是一种基于文件的消息队列，system v进程间通信实现方式不能和文件兼容，Linux一切皆文件，所以选择posix进程间通信方式会更好些。<br><img src="https://pic.imgdb.cn/item/66040e869f345e8d03bc1c64.png" alt="在这里插入图片描述"><br>POSIX消息队列是基于mqueue文件系统实现，POSIX消息队列其实就是mqueue文件系统的一个inode节点。<br>mount | grep “mqueue” 查看mqueue文件系统挂载点，挂在路径为&#x2F;dev&#x2F;mqueue。<br>POSIX消息队列底层实现为mqueue inode节点，<strong>基于红黑树存储信息</strong>。<br><img src="https://pic.imgdb.cn/item/66040e939f345e8d03bca643.png" alt="在这里插入图片描述"></p><blockquote><p>mq_open：打开或创建一个消息队列<br>mq_send：将消息太耐到消息队列，如果消息队列已满，则阻塞、<br>mq_receive：接收消息队列中的消息。<br>mq_notify：消息队列有通知的系统调用，可以用于进程发送通知，告诉它有新的消息到达了消息队列。<br>mq_cloas：关闭一个消息队列。<br>mq_unlink：删除一个消息队列，新使用一个消息队列，删除旧的。</p></blockquote><p><code>POSIX消息队列编译的时候要加上 -lrt</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 消息队列，用mq_notify多线程的方式去读数据</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mqueue.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST_STRING <span class="hljs-string">&quot;123456&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">do_notify</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_proc</span><span class="hljs-params">(<span class="hljs-type">sigval_t</span> val)</span></span>;<br><br><span class="hljs-comment">// 处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_proc</span><span class="hljs-params">(<span class="hljs-type">sigval_t</span> val)</span></span>&#123;<br>    <span class="hljs-type">int</span> fd = val.sival_int; <span class="hljs-comment">//进程收到通知后，注册信息失效，需要重新注册</span><br>    <span class="hljs-built_in">do_notify</span>(fd);<br>    <span class="hljs-type">char</span> rbuf[<span class="hljs-number">2048</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prio = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">mq_receive</span>(fd,rbuf,<span class="hljs-number">2048</span>,&amp;prio);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span> )&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mq_receive&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;ret: &quot;</span>&lt;&lt;ret &lt;&lt;<span class="hljs-string">&quot; prio: &quot;</span>&lt;&lt;prio&lt;&lt;<span class="hljs-string">&quot; rbuf: &quot;</span>&lt;&lt;rbuf&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">// mq_notify多线程的方式去读数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">do_notify</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigevent</span> ev;<br>    ev.sigev_value.sival_int = fd;<br>    ev.sigev_notify = SIGEV_THREAD; <span class="hljs-comment">// 线程</span><br>    ev.sigev_notify_function = test_proc; <span class="hljs-comment">//绑定函数</span><br>    ev.sigev_notify_attributes = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">mq_notify</span>(fd,&amp;ev);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span> )&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mq_notify&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>&#123;<br><br>    <span class="hljs-type">int</span> mode = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">if</span>(mode == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">mq_unlink</span>(<span class="hljs-string">&quot;/posixMq1&quot;</span>); <span class="hljs-comment">// 删除之前的消息队列，如果消息队列有更新，不清除的话，会占用</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mq_attr</span> attr; <span class="hljs-comment">//设置mq属性</span><br>    attr.mq_flags = <span class="hljs-number">0</span>;<br>    attr.mq_maxmsg = <span class="hljs-number">10</span>;<br>    attr.mq_msgsize = <span class="hljs-number">1500</span>; <br><br>    <span class="hljs-type">mqd_t</span> fd = <span class="hljs-built_in">mq_open</span>(<span class="hljs-string">&quot;/posixMq1&quot;</span>, O_RDWR|O_CREAT, <span class="hljs-number">0664</span>, &amp;attr);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span> )&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mq_open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(mode==<span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">do_notify</span>(fd); <span class="hljs-comment">//完成注册</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(mode == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>            <span class="hljs-type">char</span> rbuf[<span class="hljs-number">2048</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prio = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">mq_receive</span>(fd,rbuf,<span class="hljs-number">2048</span>,&amp;prio);<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span> )&#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mq_receive&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cout&lt;&lt;<span class="hljs-string">&quot;ret: &quot;</span>&lt;&lt;ret &lt;&lt;<span class="hljs-string">&quot; prio: &quot;</span>&lt;&lt;prio&lt;&lt;<span class="hljs-string">&quot; rbuf: &quot;</span>&lt;&lt;rbuf&lt;&lt;endl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">mq_send</span>(fd,TEST_STRING,<span class="hljs-built_in">sizeof</span>(TEST_STRING),<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span> )&#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mq_send&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>System V 信号量（System V Semaphores）和 POSIX 信号量（POSIX Semaphores）都是用于多进程或多线程之间进行进程同步和互斥的机制。</p><p><code>System V 信号量是一种在系统级别上维护的计数器，用于控制对共享资源的访问。它使用三个基本操作来操作信号量：创建、初始化和执行 P（proberen）和 V（verhogen）操作。P 操作用于申请资源，如果资源不可用，则进程会等待。V 操作用于释放资源，允许其他进程继续访问该资源。System V 信号量可以在不同进程间共享，并且可以持久化存储在系统中。</code></p><ul><li>P操作：等待操作或者减操作，用于申请资源，当信号量的值大于0时，将其减一，当信号量的值等于0时，进程将被阻塞。</li><li>V操作：释放操作或加操作，用于释放资源，将信号量的值加一，并唤醒等待的进程。</li></ul><p>实现原理：具有相同IPC命名空间的进程能够同时访问IPC命名空间相同内存空间，命名空间内维护信号量，和消息队列大同小异。<br><img src="https://pic.imgdb.cn/item/66040eb49f345e8d03bdd670.png" alt="在这里插入图片描述"></p><blockquote><p>semget：创建或打开一个信号量集<br>semop：对信号量进行操作，semval：信号量值。<br>semctl：对一个已经存在的信号量集值进行各种操作，比如获取信号量集值的信息，设置信号量集的值，删除信号量等。<br>ipcs-a：查看消息队列，信号量，共享内存<br>ipcs-s：查看信号量<br>ipcmk -S 2 -p 0644 &#x2F;&#x2F;创建信号量，权限为0644<br>ipcrm -s 6 &#x2F;&#x2F;删除标识ID 6的信号量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">semun</span> &#123;<br>    <span class="hljs-type">int</span> val;                <span class="hljs-comment">// 用于 SETVAL 操作，设置信号量的初始值</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">semid_ds</span> *buf;    <span class="hljs-comment">// 用于 IPC_STAT 和 IPC_SET 操作，获取和设置信号量的状态信息</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *array;   <span class="hljs-comment">// 用于 GETALL 和 SETALL 操作，获取和设置信号量的值数组</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">seminfo</span> *__buf;   <span class="hljs-comment">// 用于 IPC_INFO 操作，获取系统的信号量信息</span><br>    <span class="hljs-type">void</span> *__pad;<br>&#125;;<br><br><span class="hljs-comment">// 初始化信号量,用setval命令</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_init_value</span><span class="hljs-params">(<span class="hljs-type">int</span> id,<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> value)</span></span>&#123;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">semun</span> un;<br>    un.val = value;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">semctl</span>(id,num,SETVAL,un);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semctl SETVAL&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;sem init value:&quot;</span>&lt;&lt;value&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除信号量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_del_sem</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">semun</span> un;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">semctl</span>(id,<span class="hljs-number">0</span>,IPC_RMID,un)==<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semctl IPC_RMID&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取信号量值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_get_value</span><span class="hljs-params">(<span class="hljs-type">int</span> id,<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">semun</span> un;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">semctl</span>(id,num,GETVAL,un);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semctl GETVAL&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;sem get value:&quot;</span>&lt;&lt;ret&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_p</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> buf;<br>    buf.sem_num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 信号量编号</span><br>    buf.sem_op = <span class="hljs-number">-1</span>; <span class="hljs-comment">// P操作代表符号</span><br>    buf.sem_flg |= SEM_UNDO;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">semop</span>(id,&amp;buf,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semop p&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_w</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> buf;<br>    buf.sem_num = <span class="hljs-number">0</span>; <span class="hljs-comment">//信号量编号</span><br>    buf.sem_op = <span class="hljs-number">0</span>; <span class="hljs-comment">// w操作代表符号</span><br>    buf.sem_flg |= SEM_UNDO; <span class="hljs-comment">//系统退出前未释放信号量，系统自动释放</span><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">semop</span>(id,&amp;buf,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semop w&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 释放资源</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_v</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> buf;<br>    buf.sem_num = <span class="hljs-number">0</span>; <span class="hljs-comment">//信号量编号</span><br>    buf.sem_op = <span class="hljs-number">1</span>; <span class="hljs-comment">// v操作代表符号</span><br>    buf.sem_flg |= SEM_UNDO; <span class="hljs-comment">//系统退出前未释放信号量，系统自动释放</span><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">semop</span>(id,&amp;buf,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semop v&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>&#123;<br>    <span class="hljs-type">int</span> op = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> value = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]); <span class="hljs-comment">//信号量的值初始化为value</span><br><br>    <span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;./system_v_msg&quot;</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 产生键值</span><br>    <span class="hljs-keyword">if</span>(key == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftok&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> id = <span class="hljs-built_in">semget</span>(key,<span class="hljs-number">5</span>,<span class="hljs-number">0644</span>|IPC_CREAT); <span class="hljs-comment">//创建信号量</span><br>    cout&lt;&lt;id&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">if</span>(value&gt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">sem_init_value</span>(id,<span class="hljs-number">0</span>,value);<br>    &#125;<br>    <span class="hljs-built_in">sem_get_value</span>(id,<span class="hljs-number">0</span>);<br><br><br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-comment">// 申请资源 P操作</span><br>        <span class="hljs-built_in">sem_p</span>(id);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// wait</span><br>        <span class="hljs-built_in">sem_w</span>(id);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 释放资源 V操作</span><br>        <span class="hljs-built_in">sem_v</span>(id);<br>    &#125;<br><br>    <span class="hljs-built_in">sem_get_value</span>(id,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sem_del_sem</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>POSIX信号量</code>：<br>*POSIX 信号量是与 System V 信号量相似，但使用更简单的 API。编译的时候需要链接 -pthread<br>*POSIX 信号量也是计数器，但它使用两个基本操作来操作信号量：初始化和执行 wait 和 post 操作。wait 操作类似于 P 操作，用于申请资源并等待，而 post 操作类似于 V 操作，用于释放资源。</p><ul><li>POSIX信号量有两种类型：命名信号量和无名信号量，分别用于进程和线程的通信。命名信号量是用tmp文件来实现，无名信号量用全局变量实现。</li><li>POSIX信号量由tmpfs文件系统和mmap内存映射共同实现，sem_open函数会创建一个tmpfs文件，然后通过mmap函数将文件进行内存映射，mmap函数调用成功后，将虚拟地址以sem_t*的形式返回给应用层。<br><img src="https://pic.imgdb.cn/item/66040ec69f345e8d03be6769.png" alt="在这里插入图片描述"><br><code>为什么无名信号量只能用于线程中?</code> 使用无名信号量一般会定义一个全局变量，别的进程是无法访问的，只有线程能用。</li></ul><blockquote><p>sem_open：创建或打开一个命名的信号量的系统调用。命名信号量（用于进程间通信）。<br>sem_init：初始化一个无名信号量。（用于线程间通信）。<br>sem_close：关闭一个打开的信号量。<br>sem_unlink：删除一个已命名的信号量。</p></blockquote><p><code>命名信号量</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> mode = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-type">sem_t</span> *sem= <span class="hljs-built_in">sem_open</span>(<span class="hljs-string">&quot;/posixSem&quot;</span>,O_RDWR|O_CREAT, <span class="hljs-number">0664</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(sem == SEM_FAILED)&#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;SEM_FAILED&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(mode==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">sem_wait</span>(sem); <span class="hljs-comment">// P</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;sem--&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">sem_post</span>(sem); <span class="hljs-comment">// V</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;sem++&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭信号量</span><br>    <span class="hljs-built_in">sem_close</span>(sem);<br>    <span class="hljs-built_in">sem_unlink</span>(<span class="hljs-string">&quot;/posixSem&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>无名信号量</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">sem_t</span> sem;<br><br>    <span class="hljs-comment">// 初始化信号量，第二个参数为0表示信号量在进程内共享，否则在进程间共享</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_init</span>(&amp;sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to initialize semaphore\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 以一定的方式使用信号量，如：</span><br>    <span class="hljs-comment">// sem_wait(&amp;sem)  // 等待信号量</span><br>    <span class="hljs-comment">// sem_post(&amp;sem)  // 发送信号量</span><br><br>    <span class="hljs-comment">// 销毁信号量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_destroy</span>(&amp;sem) == <span class="hljs-number">-1</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to destroy semaphore\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p><code>SystemV 内存映射</code>：内存映射是一种将文件系统中的文件映射到进程内存空间的技术。可以像操作内存一样操作文件，而不需要读写操作，可以提高文件的读写效率，减少IO操作，提高系统性能。</p><blockquote><p>#include &lt;sys&#x2F;mman.h&gt;<br>&#x2F;&#x2F; 创建内存映射区<br>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);<br>&#x2F;&#x2F; 解除内存映射<br>int munmap(void *addr, size_t length);</p></blockquote><p><code>共享内存不同于内存映射区，它不属于任何进程，并且不受进程生命周期的影响。</code></p><ul><li>共享内存不同于内存映射区，它不属于任何进程，并且不受进程生命周期的影响。</li><li>通过调用Linux提供的系统函数就可得到这块共享内存。使用之前需要让进程和共享内存进行关联，得到共享内存的起始地址之后就可以直接进行读写操作了，进程也可以和这块共享内存解除关联, 解除关联之后就不能操作这块共享内存了。</li><li><code>在所有进程间通信的方式中共享内存的效率是最高的。</code><br><img src="https://pic.imgdb.cn/item/66040ede9f345e8d03bf4878.png" alt="在这里插入图片描述"><blockquote><p>shmget：创建或获取共享内存<br>shmat：与共享内存做内存映射的函数<br>shmdt：将共享内存与当前进程分离。<br>shmctl：对共享内存段进行操作，如创建、删除获取和修改属性</p></blockquote></li></ul><blockquote><p>ipcs -m 查看共享内存<br>ipcmk - M 4096 共享内存为4096字节<br>ipcrm -m 2 删除标识为2的共享内存。</p></blockquote><p><code>内存映射区和共享内存的区别</code>：</p><ul><li>共享内存只需要一块共享内存区就可以进行进程间通信，内存映射区位于每个进程的虚拟地址空间中，需要关联磁盘文件才能实现进程间数据通信。</li><li>共享内存效率更高，内存映射区需要文件数据同步，效率较低。</li><li>共享内存独立于进程，内存映射区属于进程。</li><li>突发情况下，内存映射区可以数据同步到文件中，共享内存不可以，因为共享内存在内存中。</li></ul><p><code>SystemV 共享内存</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> mode = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">key_t</span> shmkey = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;./system_v_shm&quot;</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 产生键值，这个名字一定要和程序名字一样。。</span><br>    <span class="hljs-keyword">if</span>(shmkey == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftok&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 键值 共享内存大小 权限</span><br>    <span class="hljs-type">int</span> shmid = <span class="hljs-built_in">shmget</span>(shmkey,<span class="hljs-number">1024</span>,<span class="hljs-number">0644</span>|IPC_CREAT);<br>    <span class="hljs-type">void</span>* addr = <span class="hljs-built_in">shmat</span>(shmid,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(addr == (<span class="hljs-type">void</span>*)<span class="hljs-number">-1</span>)&#123;<br>        cerr&lt;&lt;<span class="hljs-string">&quot;shmat&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(mode==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">char</span> rbuf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">memcpy</span>(rbuf,addr,<span class="hljs-number">1024</span>);<br>            cout&lt;&lt;rbuf&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">char</span> wbuf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">sprintf</span>(wbuf,<span class="hljs-string">&quot;%d&quot;</span>,i++);<br>            <span class="hljs-built_in">memset</span>(addr,<span class="hljs-number">0</span>,<span class="hljs-number">1024</span>);<span class="hljs-comment">//清空</span><br>            <span class="hljs-built_in">memcpy</span>(addr,wbuf,<span class="hljs-built_in">strlen</span>(wbuf));<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">shmctl</span>(shmid,IPC_RMID,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//删除共享内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>POSIX共享内存</code>：也是通过mmap函数实现，编译的时候需要加一个rt的库，-lrt。</p><blockquote><p>shm_open函数创建一个共享内存对象。<br>shm_unlink关闭共享内存。<br>ftruncate函数设置共享内存大小。<br>mmap函数将共享内存映射到进程的地址空间中<br><img src="https://pic.imgdb.cn/item/66040eec9f345e8d03bfd423.png" alt="在这里插入图片描述"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>        <span class="hljs-comment">/* For mode constants */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>           <span class="hljs-comment">/* For O_* constants */</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHM_PATH <span class="hljs-string">&quot;./system_v_shm&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> mode = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">shm_open</span>(SHM_PATH,O_RDWR|O_CREAT,<span class="hljs-number">0644</span>); <span class="hljs-comment">//打开或创建共享内存</span><br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;shm_open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">ftruncate</span>(fd,<span class="hljs-number">4096</span>); <span class="hljs-comment">//设置共享内存大小</span><br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftruncate&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">void</span>* addr = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">4096</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="hljs-number">0</span>); <span class="hljs-comment">// 内存映射</span><br>    <span class="hljs-keyword">if</span>(addr == (<span class="hljs-type">void</span>*)<span class="hljs-number">-1</span>)&#123;<br>        cerr&lt;&lt;<span class="hljs-string">&quot;mmap&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(mode==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//读内存</span><br>            <span class="hljs-type">char</span> rbuf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">memcpy</span>(rbuf,addr,<span class="hljs-number">1024</span>);<br>            cout&lt;&lt;rbuf&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">char</span> wbuf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">sprintf</span>(wbuf,<span class="hljs-string">&quot;%d&quot;</span>,i++);<br>            <span class="hljs-built_in">memset</span>(addr,<span class="hljs-number">0</span>,<span class="hljs-number">1024</span>);<span class="hljs-comment">//清空</span><br>            <span class="hljs-built_in">memcpy</span>(addr,wbuf,<span class="hljs-built_in">strlen</span>(wbuf));<br>        &#125;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">munmap</span>(addr,<span class="hljs-number">4096</span>); <span class="hljs-comment">//解除内存映射</span><br>    <span class="hljs-built_in">shm_unlink</span>(SHM_PATH);<span class="hljs-comment">// 删除内存映射</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>Linux内核中实现信号的关键是信号处理函数和信号传递，每个进程都有一个信号来表示该进程对不同信号的处理情况。<br>当一个进程向另一个进程发送信号时，内核会将信号添加到目标进程的信号队列中。<br><img src="https://pic.imgdb.cn/item/66040efe9f345e8d03c08525.png" alt="在这里插入图片描述"></p><blockquote><p>信号产生：可以由多种事件触发，如硬件中断，软件异常，用户自定义信号灯。产生信号以后就会进行信号传递，处理，终止。<br>Linux每个进程都会维护一张信号表，信号表记录了每个信号和信号处理方法，用户调用signal或sigaction函数可以修改函数处理方法。</p></blockquote><blockquote><p>signal函数：捕捉产生的信号，并将信号的处理函数设置为handler<br>sigaction：捕捉产生的信号，注册和处理信号处理器<br>SIGCHLD 信号：子进程退出，暂停或暂停恢复运行的时候，会给父进程一个SIGCHLD信号。</p></blockquote><p>Linux信号的三种状态：产生，未决，递达。</p><blockquote><p>kill：杀死进程的信号<br>raise：给当前进程发送指定的信号<br>abort：给当前进程发送一个固定信号 (SIGABRT)，杀死当前进程。<br>alarm：定时器，单词定时信号，完成时发射一个信号。<br>settimer：周期性触发信号。</p></blockquote><blockquote><p>信号集函数：<br>sigprocmask：将信号加到阻塞信号集 or 解除 or 覆盖<br>sigpending:读取未决信号集。</p></blockquote><p>参考列表<br><a href="https://www.bilibili.com/video/BV1ob4y1u7ZL/">https://www.bilibili.com/video/BV1ob4y1u7ZL/</a><br><a href="https://subingwen.cn/linux/pipe/">https://subingwen.cn/linux/pipe/</a><br><a href="https://zhuanlan.zhihu.com/p/672264623">https://zhuanlan.zhihu.com/p/672264623</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习五(进程)</title>
    <link href="/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%BA%94(%E8%BF%9B%E7%A8%8B)/"/>
    <url>/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%BA%94(%E8%BF%9B%E7%A8%8B)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习五-进程"><a href="#Linux学习五-进程" class="headerlink" title="Linux学习五 : 进程"></a>Linux学习五 : 进程</h1><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p><code>虚拟地址空间</code>：虚拟内存将物理内存抽象为地址空间，每个进程都有各自地址空间。地址空间中页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。<br>虚拟地址空间的大小也由操作系统决定，32位的操作系统虚拟地址空间的大小为 2^32 字节，也就是4G，64位的操作系统虚拟地址空间大小为2 ^64 字节。</p><ul><li>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</li><li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</li></ul><p><code>从操作系统层级上看，虚拟地址空间主要分为两个部分内核区和用户区。</code><br>内核空间在3-4G在今后陪你过，驻留在内存中，是操作系统的一部分。系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。<br><img src="https://pic.imgdb.cn/item/66040fb29f345e8d03c771c9.png" alt="在这里插入图片描述"></p><ul><li>保留区：未赋予物理地址。NULL指向这块地址。</li><li>代码段：通常存放CPU指令和函数。</li><li>数据段：存放已初始化且初值不为0的全局变量和静态变量。数据段属于静态内存分配(静态存储区)，可读可写。</li><li>.bss段: 未初始化以及初始为0的全局变量和静态变量，操作系统会将这些未初始化变量初始化为0</li><li>堆：new出来的，需要释放。</li><li>内存映射区：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</li><li>栈：存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址“向下生长”，分配的内存是连续的。</li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>Linux中一切都是文件，需要操作文件描述符进行读写操作。<br>Linux下进程启动就会得到一个对应的虚拟地址空间，进程控制块PCB中包含一个文件描述符表，用于存储文件描述符。</p><ul><li>每一个进程对应的文件描述符表能够存储的打开的文件数是有限制的, 默认为1024个，这个默认值是可以修改的，支持打开的最大文件数据取决于操作系统的硬件配置。</li><li>当一个进程被启动之后，内核PCB的文件描述符表中就已经分配了三个文件描述符（标准输入stdin，标准输出stdout，标准错误stderr），这三个文件描述符对应的都是当前启动这个进程的终端文件。</li><li>文件描述符表中不同的文件描述符可以对应同一个磁盘文件。</li></ul><blockquote><p>open&#x2F;close 可以打开关闭文件，open还可以创建新的文件。<br>read 函数用于读取文件内部数据，在通过 open 打开文件的时候需要指定读权限。<br>write 函数用于将数据写入到文件内部，在通过 open 打开文件的时候需要指定写权限。<br>系统函数 lseek 的功能是比较强大的, 我们既可以通过这个函数移动文件指针, 也可以通过这个函数进行文件的拓展。</p></blockquote><blockquote><p>file命令可以查看文件信息。<br>stat命令显示文件或目录的详细属性信息包括文件系统状态，比ls命令输出的信息更详细。<br>dup函数的作用是复制文件描述符，这样就有多个文件描述符可以指向同一个文件了。可以在进程中创建多个对同一文件的引用，可以对文件进行读取写入等操作。<br>dup2() 函数是 dup() 函数的加强版，基于dup2() 既可以进行文件描述符的复制, 也可以进行文件描述符的重定向。文件描述符重定向就是改变已经分配的文件描述符关联的磁盘文件。<br>fcntl() 是一个变参函数, 并且是多功能函数，可以通过这个函数实现文件描述符的复制和获取&#x2F;设置已打开的文件属性。</p></blockquote><blockquote><p>opendir(), readdir(), closedir()。 readdir() 函数遍历目录中的文件信息。<br>scandir()函数进行目录的遍历（只遍历指定目录，不进入到子目录中进行递归遍历）。</p></blockquote><p><code>文件同步</code>：Linux中，文件系统通常使用缓存区来提高文件读写性能，当程序对文件进行读写操作时，数据首先会被写入到内核的缓冲区中，而不是直接写入磁盘，这样可以减少磁盘IO的次数，提高文件读写的效率。但是如果出现意外崩溃或断电，还未写入磁盘的数据将会丢失，导致数据的不一致性或丢失，这时候就需要用文件同步来确保数据的持久性和一致性。<br>文件同步需要用到的函数：</p><blockquote><p>fsync：单个文件，同步数据，同步元数据（文件加上属性，如时间，大小等）<br>fdatasync：单个文件，同步数据，不同步元数据<br>sync：所有文件，同步数据，同步元数据</p></blockquote><p><code>文本文件和二进制文件</code>：文本文件按照ASCII码编码，二进制文件按照十六进制编码。二进制文件比较稳定，不容易出错。</p><blockquote><p>fopen ： 标准IO打开文件。<br>fread：标准IO读取二进制文件。<br>fwrite：标准IO写二进制文件。</p></blockquote><p><code>缓存</code><br>标准IO（fread，fwrite）引入了缓存的概念，为了减少系统调用，提高IO性能。标准IO比文件IO多了一个缓存的流程。</p><blockquote><p>全缓存：数据量达到一定大小（4096字节）或遇到文件结束符时，缓冲区被刷新，数据才会被写入到目标设备（如终端或文件）。当打开文件后，如果文件与终端设备无关，则默认是全缓冲模式。<br>行缓存：包含换行符时会立即刷新。<br>无缓存：每次机械能IO操作时，都会立即刷新。</p></blockquote><p><img src="https://pic.imgdb.cn/item/66040fda9f345e8d03c906a1.png" alt="图源https://www.bilibili.com/video/BV1rN411W7eD/?spm_id_from=333.999.0.0&amp;vd_source=a4ddf2ef7da26e74ca075b2059607bd6"></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol><li>程序是磁盘上的可执行文件，只占用磁盘空间，是一个静态概念。</li><li>进程是被执行的程序，不占用磁盘空间，需要消耗系统的内存，CPU资源，每个进程都有一个自己的虚拟地址空间，是一个动态概念。</li><li>进程是操作系统进行资源分配和管理的基本单位，每个进程都有自己的独立空间，包含代码、数据和堆栈等。</li><li>环境变量是操作系统中用来存储特定信息的动态值，通常被用于配置程序运行所需的各种信息，如系统路径，语言设置，临时文件设置等。</li></ol><p><code>并行和并发</code></p><blockquote><p>CPU在某个时间节点只能处理一个任务，但是操作系统都支持多任务的，<strong>CPU会给每个进程被分配一个时间段</strong>，进程得到这个时间片之后才可以运行，<strong>使各个程序从表面上看是同时进行的</strong>。如果在时间片结束时进程还在运行，CPU的使用权将被收回，该进程将会被中断挂起等待下一个时间片。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换，这样就可以避免CPU资源的浪费。</p></blockquote><blockquote><p>在我们使用的计算机中启动的多个程序，<strong>从宏观上看是同时运行的，从微观上看由于CPU一次只能处理一个进程，所有它们是轮流执行的，只不过切换速度太快，我们感觉不到罢了</strong>，因此CPU的核数越多计算机的处理效率越高。</p></blockquote><p>并发：并发的同时进行是一个假象，针对一个硬件资源，通过计算机CPU时间片的快速切换，使得程序表面看起来像是一起执行的。<br>并行：多进程同时运行时真实存在的，可以在同一时刻运行多个进程。</p><blockquote><p>进程控制块：PCB - 进程控制块（Processing Control Block），Linux内核的进程控制块本质上是一个叫做 task_struct的结构体。在这个结构体中记录了进程运行相关的一些信息</p></blockquote><p><code>进程一共有五种状态分别为：创建态，就绪态，运行态，阻塞态(挂起态)，退出态(终止态)其中创建态和退出态维持的时间是非常短的，稍纵即逝。</code></p><ul><li>就绪态：进程被创建出来了，有运行的资格但是还没有运行，需要抢CPU时间片，得到CPU时间片，进程开始运行，从就绪态转换为运行态。进程的CPU时间片用完了, 再次失去CPU, 从运行态转换为就绪态。</li><li>运行态：运行态不会一直持续，进程的CPU时间片用完之后, 再次失去CPU，从运行态转换为就绪态，只要进程还没有退出，就会在就绪态和运行态之间不停的切换。</li><li>阻塞态：进程被强制放弃CPU，并且没有抢夺CPU时间片的资格，比如: 在程序中调用了某些函数（比如: sleep()），进程又运行态转换为阻塞态（挂起态），当某些条件被满足了（比如：slee() 睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。</li></ul><p><code>ps aux 查看进程信息 kill 杀死进程</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs powershell">liuchang@DESKTOP<span class="hljs-literal">-LIUCHANG</span>:~/codetest<span class="hljs-variable">$</span> <span class="hljs-built_in">ps</span> aux<br>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT <span class="hljs-built_in">START</span>   TIME COMMAND<br>root         <span class="hljs-number">1</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>    <span class="hljs-number">916</span>   <span class="hljs-number">544</span> ?        <span class="hljs-built_in">Sl</span>   Dec18   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /init<br>root     <span class="hljs-number">24651</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>    <span class="hljs-number">916</span>    <span class="hljs-number">92</span> ?        Ss   <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /init<br>root     <span class="hljs-number">24652</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>    <span class="hljs-number">916</span>    <span class="hljs-number">92</span> ?        S    <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /init<br>liuchang <span class="hljs-number">24653</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">4636</span>   <span class="hljs-number">828</span> pts/<span class="hljs-number">0</span>    Ss+  <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> sh <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;<span class="hljs-variable">$VSCODE_WSL_EXT_LOCATION</span>/scripts/wslServer.sh&quot;</span> b7886d7461186a5eac768481578c1d7ca80e2d21 stable code<span class="hljs-literal">-server</span> .vscode<span class="hljs-literal">-server</span> <span class="hljs-literal">--host</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-literal">--port</span>=<span class="hljs-number">0</span> <span class="hljs-literal">--connecti</span><br>liuchang <span class="hljs-number">24654</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">4636</span>   <span class="hljs-number">876</span> pts/<span class="hljs-number">0</span>    S+   <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> sh /mnt/c/Users/Liuchang/.vscode/extensions/ms<span class="hljs-literal">-vscode-remote</span>.remote<span class="hljs-literal">-wsl-0</span>.<span class="hljs-number">77.0</span>/scripts/wslServer.sh b7886d7461186a5eac768481578c1d7ca80e2d21 stable code<span class="hljs-literal">-server</span> .vsco<br>liuchang <span class="hljs-number">24659</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">4636</span>   <span class="hljs-number">864</span> pts/<span class="hljs-number">0</span>    S+   <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> sh /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/bin/code<span class="hljs-literal">-server</span> <span class="hljs-literal">--host</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-literal">--port</span>=<span class="hljs-number">0</span> <span class="hljs-literal">--connection-token</span>=<span class="hljs-number">1794849578</span><span class="hljs-literal">-1708241527-4087</span><br>liuchang <span class="hljs-number">24663</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">951772</span> <span class="hljs-number">77072</span> pts/<span class="hljs-number">0</span>    <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">03</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/node /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/out/server<br>liuchang <span class="hljs-number">24674</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">658924</span> <span class="hljs-number">52708</span> pts/<span class="hljs-number">0</span>    Rl+  <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">04</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/node /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/out/bootst<br>liuchang <span class="hljs-number">24734</span>  <span class="hljs-number">0.9</span>  <span class="hljs-number">0.1</span> <span class="hljs-number">11538640</span> <span class="hljs-number">166668</span> pts/<span class="hljs-number">0</span> <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">1</span>:<span class="hljs-number">31</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/node /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/out/bootst<br>liuchang <span class="hljs-number">24758</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">717340</span> <span class="hljs-number">44276</span> pts/<span class="hljs-number">0</span>    <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/node /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/out/bootst<br>liuchang <span class="hljs-number">24771</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">23076</span>  <span class="hljs-number">5092</span> pts/<span class="hljs-number">4</span>    Ss   <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /bin/bash <span class="hljs-literal">--init-file</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/out/vs/workbench/contrib/terminal/browser/media/shellIntegration<span class="hljs-literal">-bas</span><br>liuchang <span class="hljs-number">24790</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">89636</span> <span class="hljs-number">23652</span> pts/<span class="hljs-number">0</span>    <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">03</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/extensions/ms<span class="hljs-literal">-vscode</span>.cpptools<span class="hljs-literal">-1</span>.<span class="hljs-number">19.1</span><span class="hljs-literal">-linux-x64</span>/bin/cpptools<br>liuchang <span class="hljs-number">24911</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">4269724</span> <span class="hljs-number">14372</span> pts/<span class="hljs-number">0</span>   <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">10</span>:<span class="hljs-number">58</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/extensions/ms<span class="hljs-literal">-vscode</span>.cpptools<span class="hljs-literal">-1</span>.<span class="hljs-number">19.1</span><span class="hljs-literal">-linux-x64</span>/bin/cpptools<span class="hljs-literal">-srv</span> <span class="hljs-number">24790</span> &#123;<span class="hljs-number">4</span>FDAC924<span class="hljs-literal">-C29C-4EC1-A9E5-E1E1D23C8266</span>&#125;<br>root     <span class="hljs-number">24959</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>    <span class="hljs-number">916</span>    <span class="hljs-number">92</span> ?        Ss   <span class="hljs-number">12</span>:<span class="hljs-number">17</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /init<br>root     <span class="hljs-number">24960</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>    <span class="hljs-number">916</span>    <span class="hljs-number">92</span> ?        S    <span class="hljs-number">12</span>:<span class="hljs-number">17</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /init<br>liuchang <span class="hljs-number">24961</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">596084</span> <span class="hljs-number">37636</span> pts/<span class="hljs-number">2</span>    Ssl+ <span class="hljs-number">12</span>:<span class="hljs-number">17</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/node <span class="hljs-literal">-e</span>  const net = require(<span class="hljs-string">&#x27;net&#x27;</span>); process.stdin.pause(); const client = net.createConne<br>root     <span class="hljs-number">24968</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>    <span class="hljs-number">916</span>    <span class="hljs-number">92</span> ?        Ss   <span class="hljs-number">12</span>:<span class="hljs-number">17</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /init<br>root     <span class="hljs-number">24969</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>    <span class="hljs-number">916</span>    <span class="hljs-number">92</span> ?        S    <span class="hljs-number">12</span>:<span class="hljs-number">17</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /init<br>liuchang <span class="hljs-number">24970</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">594684</span> <span class="hljs-number">37320</span> pts/<span class="hljs-number">1</span>    Ssl+ <span class="hljs-number">12</span>:<span class="hljs-number">17</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /home/liuchang/.vscode<span class="hljs-literal">-server</span>/bin/b7886d7461186a5eac768481578c1d7ca80e2d21/node <span class="hljs-literal">-e</span>  const net = require(<span class="hljs-string">&#x27;net&#x27;</span>); process.stdin.pause(); const client = net.createConne<br>liuchang <span class="hljs-number">31668</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">37848</span>  <span class="hljs-number">3392</span> pts/<span class="hljs-number">4</span>    <span class="hljs-built_in">R</span>+   <span class="hljs-number">13</span>:<span class="hljs-number">32</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> <span class="hljs-built_in">ps</span> aux<br></code></pre></td></tr></table></figure><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><ol><li>Linux中进程ID为 pid_t 类型，其本质是一个正整数。<blockquote><p>getpid：获取当前进程的ID<br>getppid：获取父进程的ID<br>fork：创建一个新的进程</p></blockquote></li></ol><p><code>fork函数</code></p><ul><li>fork创建子进程，每个进程都对应一个属于自己的虚拟地址空间，子进程的地址空间是基于父进程的地址空间拷贝出来的，虽然是拷贝但是两个地址空间中存储的信息不可能是完全相同的。<ul><li><pre><code class="hljs">fork调用成功后，父子进程的返回值不同，父进程返回值大于0，子进程的返回值等于0。</code></pre></li><li>exec族函数可以将进程中执行的函数和数据进行替换。</li><li><strong>父子进程中是不能通过全局变量实现数据交互的，因为每个进程都有自己的地址空间，两个同名全局变量存储在不同的虚拟地址空间中，二者没有任何关联性。如果要进行进程间通信需要使用：管道，共享内存，本地套接字，内存映射区，消息队列等方式。</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> number = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cout&lt;&lt;<span class="hljs-string">&quot;创建子进程之前numeber = &quot;</span>&lt;&lt;number&lt;&lt;endl;<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    cout&lt;&lt;<span class="hljs-string">&quot;当前进程fork()返回值 &quot;</span>&lt;&lt;pid&lt;&lt;endl;<br><br>    <span class="hljs-comment">//如果是父进程</span><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是父进程, pid = %d, number = %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>(), ++number); <span class="hljs-comment">//11</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;父进程的父进程(终端进程), pid = %d\n&quot;</span>, <span class="hljs-built_in">getppid</span>());<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        number += <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是子进程, pid = %d, number = %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>(), number); <span class="hljs-comment">//110</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程的父进程, pid = %d\n&quot;</span>, <span class="hljs-built_in">getppid</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>父子进程虚拟地址空间：</p><ul><li>各自拥有独立的虚拟地址空间</li><li>父子进程共享代码段（只读）</li><li>采用写时拷贝计算创建子进程虚拟地址空间：写时拷贝指只创建虚拟地址空间，不为子进程分配实际的内存，父进程和子进程之间共享相同的物理内存页面。当子进程或父进程对虚拟地址空间对应的内存进行更改时才会分配实际内存。<ul><li>节省内存开销</li><li>提高创建进程效率</li></ul></li></ul></blockquote><blockquote><p>结束进程：<code>exit()或者_exit()函数,函数的参数相当于退出码</code></p></blockquote><blockquote><p><strong>孤儿进程</strong>：父进程由于某种原因先退出了，子进程还在运行，这时候这个子进程就可以被称之为孤儿进程。当检测到某一个进程变成了孤儿进程，这时候系统中就会有一个固定的进程领养这个孤儿进程。<br><code>系统为什么要领养这个孤儿进程呢？</code>在子进程退出的时候, 进程中的用户区可以自己释放, 但是进程内核区的pcb资源自己无法释放，必须要由父进程来释放子进程的pcb资源，孤儿进程被领养之后，操作系统释放资源，这样可以避免系统资源的浪费。</p></blockquote><blockquote><p><code>僵尸进程</code>：已经终止执行的进程，父进程没有它的回收资源，用户区资源已经被释放了，只是还占用着一些内核资源（PCB）。</p><ul><li>进程资源表浪费</li><li>父进程资源泄露</li><li>进程通信异常</li><li>系统性能下降。</li></ul><p>如何避免僵尸进程？使用wait()或waitpid()系统调用来等待子进程的退出，并释放相关资源，来避免僵尸进程产生。</p><ul><li>wait()为阻塞方式。如果没有子进程退出, 函数会一直阻塞等待, 当检测到子进程退出了, 该函数阻塞解除回收子进程资源。这个函数被调用一次, 只能回收一个子进程的资源，如果有多个子进程需要资源回收, 函数需要被调用多次。</li></ul></blockquote><blockquote><ul><li>waitpid()是非阻塞方式。通过该函数可以控制回收子进程资源的方式是阻塞还是非阻塞，另外还可以通过该函数进行精准打击，可以精确指定回收某个或者某一类或者是全部子进程资源。</li></ul></blockquote><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><blockquote><p>守护进程是一种在系统后台运行的特殊进程，独立的提供服务或执行任务，无需与用户交互，系统启动时自动启动，具有稳定性和长时间运行的能力。<br>守护进程PPID &#x3D; 1，没有控制终端。<br>创建守护进程的过程：</p><ol><li>创建子进程, 让父进程退出，子进程没有任何职务, 目的是让子进程最终变成一个会话, 最终就会得到守护进程。</li><li>通过子进程创建新的会话，调用函数 setsid()，脱离控制终端。</li><li>子进程调用fork成功，子进程调用exit(0)终止。由孙进程来充当守护进程，防止子进程成为会话首进程出现异常。</li><li>改变当前进程的工作目录 (可选项, 不是必须要做的)。</li><li>重新设置文件的掩码 (可选项, 不是必须要做的)。</li><li>关闭&#x2F;重定向文件描述符 (不做也可以）</li><li>孙进程忽略SIGCHLD信号</li><li>根据实际需求在守护进程中执行某些特定的操作</li></ol></blockquote><p>参考列表<br><a href="https://subingwen.cn/linux/file-descriptor/">https://subingwen.cn/linux/file-descriptor/</a><br><a href="https://space.bilibili.com/397638507/">https://space.bilibili.com/397638507/</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL 泛型编程学习</title>
    <link href="/2024/03/26/STL%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/26/STL%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="STL-泛型编程学习"><a href="#STL-泛型编程学习" class="headerlink" title="STL 泛型编程学习"></a>STL 泛型编程学习</h1><h2 id="STL标准库六大部件"><a href="#STL标准库六大部件" class="headerlink" title="STL标准库六大部件"></a>STL标准库六大部件</h2><p><code>面向对象编程，将数据和函数放在一个类里面，但是STL将数据（容器）和函数（算法）进行了分离，所以两者在基础观念上就不一样。</code></p><ol><li>容器：各种数据结构。</li><li>分配器：进行空间配置与管理。</li><li>算法：数据处理方法，如sort，search等。</li><li>迭代器：好比一种泛化的指针，作为数据和函数之间的桥梁。stl容器都有自己的专属迭代器。</li><li>适配器：三种。</li><li>仿函数：类似函数。<br><img src="https://pic.imgdb.cn/item/6604102f9f345e8d03cc528a.png" alt="在这里插入图片描述"></li></ol><hr><p>序列容器：</p><ul><li>Array ：固定大小数组</li><li>Vector：可扩容数组</li><li>Deque：双端数组</li><li>List：双链表，环状</li><li>Forward-List：单链表</li></ul><p>关联容器：</p><ul><li>set&#x2F;multiset：红黑树：高度平衡二叉树</li><li>map&#x2F;multimap：红黑树</li><li>unorderedset&#x2F;unorderedmultiset：hash表，开链式方法解决冲突</li><li>unorderedmap&#x2F;unorderedmultimap：hash表</li></ul><p><code>C++ STL标准库使用模板编程完成的</code></p><ol><li>面向对象编程：数据和函数操作放在一个类里面。</li><li>模板编程：将数据和函数分开。为了适配各种数据类型，操作符重载，函数模板，占据非常重要性。</li></ol><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><code>函数模板：一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表，此通用函数即为函数模板</code><br><code>模板函数：为函数模板传参，根据实际传入的参数类型生成的一个重载函数即为模板函数，它是函数模板的一次实例化。</code><br><code>当函数重载与模板函数冲突的时候，优先调用普通函数，因为普通函数在编译期间就生成了，模板函数是运行时生成的，先到先得。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><br><span class="hljs-comment">// 函数模板：交换两个变量</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MySwap</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span>&#123;<br>    T temp = a;<br>    a=b;<br>    b= temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span>&lt;&lt; b&lt;&lt;endl;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">double</span> aa = <span class="hljs-number">10.2</span>;<br>    <span class="hljs-type">double</span> bb = <span class="hljs-number">20.1</span>;<br>    <span class="hljs-built_in">MyPrint</span>(a,b);<br>    <span class="hljs-built_in">MyPrint</span>(aa,bb);<br>    <span class="hljs-built_in">MySwap</span>(a,b);<br>    <span class="hljs-built_in">MySwap</span>(aa,bb);<br>    cout&lt;&lt;<span class="hljs-string">&quot;======已经完成交换======&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">MyPrint</span>(a,b);<br>    <span class="hljs-built_in">MyPrint</span>(aa,bb);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::ostream;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> image;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> real,<span class="hljs-type">double</span> image):<span class="hljs-built_in">real</span>(real),<span class="hljs-built_in">image</span>(image)&#123;&#125;<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">this</span>-&gt;real+other.real, <span class="hljs-keyword">this</span>-&gt;image+other.image);<br>    &#125;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Complex&amp; p);  <span class="hljs-comment">//声明operator&lt;&lt;为友元函数，可以访问私有成员</span><br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="hljs-type">const</span> Complex&amp; other)&#123;<br>    cout&lt;&lt;other.real &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt;other.image&lt;&lt;<span class="hljs-string">&quot;i&quot;</span>;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1.0f</span>,<span class="hljs-number">2.2f</span>)</span></span>;<br>    <span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2.0f</span>,<span class="hljs-number">3.2f</span>)</span></span>;<br>    Complex c3=c1+c2;<br>    cout&lt;&lt;c3&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="右值引用与移动构造"><a href="#右值引用与移动构造" class="headerlink" title="右值引用与移动构造"></a>右值引用与移动构造</h2><p><code>移动语义能提高复制对象性能</code>：移动构造在进行复制构造的时候，只需要把指针指向原数据，然后把原数据的指针置空，再设置数据大小。相比复制构造要去动态分配内存、再递归调用每个元素的复制构造函数的速度快得多。<br><code>右值引用是C++语法层面表示移动语义的机制：std::move()可以把任意类型转为右值引用，右值引用不过是另一个类型，没有那么神秘，当参数类型为右值引用时，函数移动它的资源，即为“移动语义”。在汇编代码的层面来看，左值或右值引用的representation都是一个内存地址，如同指针一般；而在C++语法层面，通过区分两种引用类型，程序员能更好地利用右值。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec_orange = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">42</span>, <span class="hljs-number">23</span>, <span class="hljs-number">7</span>, <span class="hljs-number">13</span> &#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec_red = std::<span class="hljs-built_in">move</span>(vec_orange); <span class="hljs-comment">//移动</span><br></code></pre></td></tr></table></figure><p>移动语义意味着把对象持有的资源或内容转移给另一个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_vector</span><br>&#123;<br>    <span class="hljs-type">int</span>* data_;<br>    <span class="hljs-type">size_t</span> size_;<br>    <span class="hljs-type">size_t</span> capacity_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 复制构造函数</span><br>    <span class="hljs-built_in">my_vector</span>(<span class="hljs-type">const</span> my_vector&amp; oth) :<br>        <span class="hljs-built_in">size_</span>(oth.size_), <br>        <span class="hljs-built_in">capacity_</span>(oth.capacity_)<br>    &#123;<br>        data_ = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * size_));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size_; ++i) &#123;<br>            data_[i] = oth.data_[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-comment">// std::exchange(obj, new_val)的作用是返回obj的旧值，并把new_val赋值给obj</span><br>    <span class="hljs-comment">// 在移动oth的内容后，要把它置于一个有效状态。</span><br>    <span class="hljs-built_in">my_vector</span>(my_vector&amp;&amp; oth) :<br>        <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">exchange</span>(oth.data_, <span class="hljs-literal">nullptr</span>)),<br>        <span class="hljs-built_in">size_</span>(std::<span class="hljs-built_in">exchange</span>(oth.size_, <span class="hljs-number">0</span>)), <br>        <span class="hljs-built_in">capacity_</span>(std::<span class="hljs-built_in">exchange</span>(oth.capacity_, <span class="hljs-number">0</span>))<br>    &#123;&#125;    <br>&#125;;<br></code></pre></td></tr></table></figure><p>C++智能指针std::unique_ptr，不可复制，只能移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_unique_ptr</span><br>&#123;<br>    T* ptr_;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">my_unique_ptr</span>(my_unique_ptr&amp;&amp; oth) :<br>        <span class="hljs-built_in">ptr_</span>(std::<span class="hljs-built_in">exchange</span>(oth.ptr_, <span class="hljs-literal">nullptr</span>)) &#123;&#125;<br><br>    <span class="hljs-comment">// 移动赋值函数</span><br>    my_unique_ptr&amp; <span class="hljs-keyword">operator</span>=(my_unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-keyword">if</span> (ptr_) &#123; <span class="hljs-comment">// 释放当前拥有的指针</span><br>                <span class="hljs-keyword">delete</span> ptr_;<br>            &#125;<br>            ptr_ = std::<span class="hljs-built_in">exchange</span>(rhs.ptr_, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 夺取rhs的指针</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 禁用复制构造函数、复制赋值函数</span><br>    <span class="hljs-built_in">my_unique_ptr</span>(<span class="hljs-type">const</span> my_unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    my_unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> my_unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="空间配置器allocator"><a href="#空间配置器allocator" class="headerlink" title="空间配置器allocator"></a>空间配置器allocator</h2><ol><li>SGI STL 的每一个容器都已经指定缺省的空间配置器是 alloc，标准的allocator只是在做简单的封装，效率不高，在插入比较小的元素类型的时候，实际上会浪费很多的空间。</li><li>为了提高效率，SGI STL在对象的生成和释放过程中，对象构造和析构由std负责，但是内存的申请与释放，由SGI STL负责。（GNU 2.9版本）</li><li>SGI的设计原则：<br> a. 向 system heap 要求空间，也就是堆空间。<br> b. 考虑多线程 (multi-threads) 状态。<br> c. 考虑内存不足时的应变措施。<br> d. 考虑过多“小型区块”可能造成的内存碎片 (fragment) 问题。使用两级空间配置器。</li><li>两级空间配置器：<br> a. 当配置区空间大小超过 128bytes 时，称为足够大，使用第一级配置器，直接使用 malloc() 和 free()。处理内存不足的情况。<br> b. 当配置区块不大于 128bytes 时，为了降低额外负担，直接使用第二级配置器，采用复杂的 memory pool 处理方式。维护16个链表，内存池以malloc配置而得。</li><li>二级配置器的内存池：每次配置一块内存，并维护对应的自由链表，负责空间配置和回收，内存链表上内存大小是8的倍数，共16个。</li><li><strong>GNU4.9版本以后的allocator</strong>，反而用成了普通的new和delete。</li></ol><h2 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h2><ol><li>为什么需要Iterator？ 因为算法和容器之间的处理过程需要迭代器起到一个润滑的作用。</li><li>例如，vector的print和list的print算法，中间需要执行的步骤就是往后走，如果不用迭代器，print算法需要针对vector进行不同的设计，因为vector可以随机访存，可以直接读取内存的下一块地址，但是list不可以，需要用指针进行操作，为了使list也可以用++这个符号，就要使用迭代器完成这个功能。</li><li>当算法变的复杂的时候，需要迭代器完成更多的数据格式，移动方式等等问题的时候，迭代器就需要具备五个必须得条件，完成特性萃取，告诉算法当前数据的迭代器特性是怎么样的，算法从而得出一个最优化的方案。</li></ol><p><code>下面的代码可以单独打印数组和链表</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 实现一个简单的双向循环List</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List_Node</span>&#123;<br>    List_Node&lt;T&gt;* prev;<br>    List_Node&lt;T&gt;* next;<br>    T val;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyList</span>&#123;<br>    <span class="hljs-keyword">typedef</span> List_Node&lt;T&gt;* pointer;<br>    <span class="hljs-built_in">MyList</span>()&#123;<br>        node = <span class="hljs-keyword">new</span> List_Node&lt;T&gt;;<br>        node-&gt;next = node;<br>        node-&gt;prev = node;<br>    &#125;<br><br>    <span class="hljs-function">pointer <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> node-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function">pointer <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(pointer position, T val)</span></span>&#123;<br>        pointer tmp = <span class="hljs-keyword">new</span> List_Node&lt;T&gt;;<br>        tmp-&gt;val = val;<br>        tmp-&gt;next = position-&gt;next;<br>        tmp-&gt;prev = position;<br>        position-&gt;next-&gt;prev = tmp;<br>        position-&gt;next = tmp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(pointer position)</span></span>&#123;<br>        position-&gt;next-&gt;prev = position-&gt;prev;<br>        position-&gt;prev-&gt;next = position-&gt;next;<br>        <span class="hljs-keyword">delete</span> position;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T val)</span></span>&#123;<br>        <span class="hljs-built_in">insert</span>(node-&gt;prev, val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">erase</span>(node-&gt;prev);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    pointer node; <span class="hljs-comment">//双向循环链表，代表链表尾节点</span><br>&#125;;<br><br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVec</span><span class="hljs-params">(T begin, T end)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(begin!=end)&#123;<br>        cout&lt;&lt;*begin&lt;&lt;endl;<br>        begin++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(T begin, T end)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(begin!=end)&#123;<br>        cout&lt;&lt;begin-&gt;val&lt;&lt;endl;<br>        begin=begin-&gt;next;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">printVec</span>(v,v+<span class="hljs-number">5</span>);<br><br>    MyList&lt;<span class="hljs-type">int</span>&gt; list;<br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    list.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">printList</span>(list.<span class="hljs-built_in">begin</span>(),list.<span class="hljs-built_in">end</span>());<br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">printList</span>(list.<span class="hljs-built_in">begin</span>(),list.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>想要一个函数既能打印数组，又能打印链表，这个时候就要用到迭代器</code><br><code>迭代器就是连接容器和算法的桥梁: 1.链表和数组就是容器 2.打印函数就可以理解为算法。他们的连接方式是不同的。迭代器就在它们中间加了一个中间层。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List_Node</span>&#123;<br>    List_Node&lt;T&gt;* prev;<br>    List_Node&lt;T&gt;* next;<br>    T val;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List_iterator</span>&#123;<br>    <span class="hljs-keyword">typedef</span> List_iterator&lt;T&gt; iterator;<br>    <span class="hljs-keyword">typedef</span> T value;<br>    <span class="hljs-keyword">typedef</span> T&amp; reference;<br>    List_Node&lt;T&gt;* node;<br><br>    <span class="hljs-built_in">List_iterator</span>():<span class="hljs-built_in">node</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">List_iterator</span>(List_Node&lt;T&gt;* node):<span class="hljs-built_in">node</span>(node)&#123;&#125;<br><br>    <span class="hljs-comment">// 前缀++ ++i</span><br>    iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        node = node-&gt;next;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 后缀++ i++ 不能加引用</span><br>    iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        iterator tmp=*<span class="hljs-keyword">this</span>;<br>        node = node-&gt;next;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    iterator&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        node = node-&gt;prev;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    iterator&amp; <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        iterator tmp=*<span class="hljs-keyword">this</span>;<br>        node = node-&gt;prev;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (iterator&amp; other)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;node == other-&gt;node;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!= (iterator&amp; other)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;node != other-&gt;node;<br>    &#125;<br><br>    iterator* <span class="hljs-keyword">operator</span>-&gt; ()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    reference <span class="hljs-keyword">operator</span>*()&#123;<br>        <span class="hljs-keyword">return</span> node-&gt;val;<br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-comment">// 实现一个简单的双向循环List</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyList</span>&#123;<br>    <span class="hljs-keyword">typedef</span> List_Node&lt;T&gt;* pointer;<br>    <span class="hljs-keyword">typedef</span> List_iterator&lt;T&gt; iterator;<br>    <span class="hljs-built_in">MyList</span>()&#123;<br>        node = <span class="hljs-keyword">new</span> List_Node&lt;T&gt;;<br>        node-&gt;next = node;<br>        node-&gt;prev = node;<br>    &#125;<br><br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> node-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator position, T val)</span></span>&#123;<br>        pointer tmp = <span class="hljs-keyword">new</span> List_Node&lt;T&gt;;<br>        tmp-&gt;val = val;<br>        tmp-&gt;next = position.node-&gt;next;<br>        tmp-&gt;prev = position.node;<br>        position.node-&gt;next-&gt;prev = tmp;<br>        position.node-&gt;next = tmp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(iterator position)</span></span>&#123;<br>        position.node-&gt;next-&gt;prev = position.node-&gt;prev;<br>        position.node-&gt;prev-&gt;next = position.node-&gt;next;<br>        <span class="hljs-keyword">delete</span> position.node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T val)</span></span>&#123;<br>        <span class="hljs-built_in">insert</span>(--<span class="hljs-built_in">end</span>(), val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">erase</span>(--<span class="hljs-built_in">end</span>());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    pointer node; <span class="hljs-comment">//双向循环链表，代表链表尾节点</span><br>&#125;;<br><br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printContainer</span><span class="hljs-params">(T begin, T end)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(begin!=end)&#123;<br>        cout&lt;&lt;*begin&lt;&lt;endl;<br>        ++begin;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">printContainer</span>(v,v+<span class="hljs-number">5</span>);<br><br>    MyList&lt;<span class="hljs-type">int</span>&gt; list;<br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    list.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">printContainer</span>(list.<span class="hljs-built_in">begin</span>(),list.<span class="hljs-built_in">end</span>());<br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">printContainer</span>(list.<span class="hljs-built_in">begin</span>(),list.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="type-traits-类型萃取"><a href="#type-traits-类型萃取" class="headerlink" title="type traits 类型萃取"></a>type traits 类型萃取</h2><ol><li>迭代器是算法与容器之间的桥梁，如果算法需要知道操作的容器里面的数据类型？</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;:: <span class="hljs-function">iterator</span><br><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">(vec.begin(), vec.end())</span></span>; <span class="hljs-comment">// 怎么判断数据类型？</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>算法需要迭代器提供的东西，由萃取器负责获取，还是一种中间层思想</strong>：萃取需要的5种数据类型：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">ptrdiff_t</span>   difference_type;<br>   <span class="hljs-keyword">typedef</span> std::bidirectional_iterator_tag iterator_category;<br>   <span class="hljs-keyword">typedef</span> _Tpvalue_type;<br>   <span class="hljs-keyword">typedef</span> _Tp*pointer;<br>   <span class="hljs-keyword">typedef</span> _Tp&amp;reference;<br></code></pre></td></tr></table></figure><p>iterator_category：迭代器的分类，指它的移动性质，表示迭代器的类型（如输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器等）。这个信息可以方便算法采用最佳的移动方式。<br>value_type：迭代器指向的值类型。告诉算法是int 还是 string？<br>difference_type：迭代器之间的距离类型，通常使用ptrdiff_t。是inter？还是<br>pointer：指向value_type的指针类型。<br>reference：value_type的引用类型。</p><ol start="3"><li>萃取机：中间层：统一指针和Iterator class的特性问题。</li></ol><h2 id="可以扩容的动态数组vector"><a href="#可以扩容的动态数组vector" class="headerlink" title="可以扩容的动态数组vector"></a>可以扩容的动态数组vector</h2><p>vector插入的方法：C++11之后，会直接调用emplace_back();</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 运行到下面</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function">      <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; __x)</span> <span class="hljs-comment">//添加左值时，这个函数会被调用，</span></span><br><span class="hljs-function">      </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage)<br>  &#123;<br>    _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish,<br>     __x); <span class="hljs-comment">//_Alloc_traits::construct完成的，它通常会调用元素类型的复制构造函数。</span><br>    ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>  &#125;<br><span class="hljs-keyword">else</span><br>  _M_realloc_insert(<span class="hljs-built_in">end</span>(), __x);<br>      &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L <span class="hljs-comment">//C++11及以后的版本，push_back提供了一个接受右值引用参数的重载版本。</span></span><br>      <span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function">      <span class="hljs-title">push_back</span><span class="hljs-params">(value_type&amp;&amp; __x)</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(__x)); &#125;<br>      <span class="hljs-comment">//push_back会调用emplace_back，并将右值引用传递给它。在emplace_back内部，元素会被直接在vector的内存中构造，使用的是元素类型的移动构造函数。</span><br>      <span class="hljs-comment">//对于可移动的对象，可以避免复制构造函数的调用，而是利用移动构造函数来构造新元素，通常这会更高效，因为它可以转移资源而不是复制资源。</span><br>&#125;<br><br><br>emplace_back代码：<br><br>vector&lt;_Tp, _Alloc&gt;::<br>      <span class="hljs-built_in">emplace_back</span>(_Args&amp;&amp;... __args)<br>      &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage)<br>  &#123;<br>    _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish,<br>     std::forward&lt;_Args&gt;(__args)...);<br>    ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>  &#125;<br><span class="hljs-keyword">else</span><br>  _M_realloc_insert(<span class="hljs-built_in">end</span>(), std::forward&lt;_Args&gt;(__args)...);<br><br>可以看到这里在元素个数小于vector容量的时候，直接在尾部进行插入，否则就会调用realloc进行扩容。<br>而 _M_realloc_insert中会调用_M_check_len函数进行容量计算：<br><span class="hljs-type">const</span> size_type __len =_M_check_len(<span class="hljs-built_in">size_type</span>(<span class="hljs-number">1</span>), <span class="hljs-string">&quot;vector::_M_realloc_insert&quot;</span>);<br><br>size_type<br>      _M_check_len(size_type __n, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* __s) <span class="hljs-type">const</span><br>      &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">max_size</span>() - <span class="hljs-built_in">size</span>() &lt; __n)<br>  __throw_length_error(__N(__s));<br><br><span class="hljs-type">const</span> size_type __len = <span class="hljs-built_in">size</span>() + std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">size</span>(), __n); <span class="hljs-comment">// 这里就是若扩容两倍还不够，就把插入的内容大小加上原来大小。</span><br><span class="hljs-keyword">return</span> (__len &lt; <span class="hljs-built_in">size</span>() || __len &gt; <span class="hljs-built_in">max_size</span>()) ? <span class="hljs-built_in">max_size</span>() : __len;<br>      &#125;<br> <br>扩容之后进行拷贝<br><br></code></pre></td></tr></table></figure><p>vector的扩容机制：</p><ul><li>有的是1.5倍扩容</li><li>有的是2倍扩容，但是它这个扩容的过程并不是绝对的，如果原本是五个，但是后面要插入20个，扩容到10个也不够，就扩容到25个，刚好满足这次添加20个的需要。</li></ul><p><code>vector的迭代器就是一个指针。</code></p><h2 id="双端开口的容器deque"><a href="#双端开口的容器deque" class="headerlink" title="双端开口的容器deque"></a>双端开口的容器deque</h2><ol><li>stack和queue基于deque进行实现的。</li><li>deque两端开口，可以push_front push_back()；连续容器，支持随机访问内存。</li><li>deque由一段一段定量的连续空间构成，串接在deque控制中心上，维护其整体连续的假象，控制中心是一个vector，增长按照普通的vector增长方式进行。</li><li>deuque本身就有40个字节。</li><li>deque做了大量的运算符重载去完成，模拟一种连续的假象。要特别注意边界区的考虑。<br><img src="https://pic.imgdb.cn/item/6604104e9f345e8d03cd8b40.png" alt="在这里插入图片描述"></li><li>stack 堆，queue 队列：底层都是deque。都不提供遍历，因为没有迭代器。</li><li>优先队列： 默认采用大根堆排列，可以按照优先级进行输出。</li></ol><h2 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set&#x2F;Map"></a>Set&#x2F;Map</h2><ol><li>二叉搜索树：节点值大于左子树每个节点的值，小于右子树每个节点的值。</li><li>平衡二叉搜索树：保证树的深度为O(logN)。任何节点的左右子树高度相差最多为1.</li><li>红黑树是一种广泛使用的平衡二叉搜索树：<blockquote><p>每个节点都有颜色，非黑即红。<br>根节点为黑。<br>父子两节点不能同时为红。<br>任意节点到NULL的任何路径，所含黑节点数必须相同。</p></blockquote></li><li>set和map底层用的红黑树，插入的时间复杂度是logN。</li><li>set的key必须独一无二，multiset的key可以重复。set的迭代器是const类型，不允许改变内容。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Identity&lt;value_type&gt;,<br>       key_compare, _Key_alloc_type&gt; _Rep_type;<br>      _Rep_type _M_t;  <span class="hljs-comment">// Red-black tree representing set.</span><br></code></pre></td></tr></table></figure><h2 id="unordered-set-unordered-map"><a href="#unordered-set-unordered-map" class="headerlink" title="unordered_set&#x2F;unordered_map"></a>unordered_set&#x2F;unordered_map</h2><ol><li>底层采用hash表，采用开链式方法解决冲突。</li></ol><p>参考列表<br><a href="https://www.bilibili.com/video/BV1Ga41177x8">https://www.bilibili.com/video/BV1Ga41177x8</a><br><a href="https://zhuanlan.zhihu.com/p/347977300">https://zhuanlan.zhihu.com/p/347977300</a><br><a href="https://www.bilibili.com/video/BV1pG4y197GW">https://www.bilibili.com/video/BV1pG4y197GW</a></p>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习四(GDB)</title>
    <link href="/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E5%9B%9B(GDB)/"/>
    <url>/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E5%9B%9B(GDB)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习四-GDB"><a href="#Linux学习四-GDB" class="headerlink" title="Linux学习四 : GDB"></a>Linux学习四 : GDB</h1><p><code>在细节上，GDB调试工具更加强大</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>sum+=i;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">long</span> result =<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>    result+=i;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;result[1-50] =&quot;</span> &lt;&lt;result&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;result[1-60] =&quot;</span> &lt;&lt;<span class="hljs-built_in">func</span>(<span class="hljs-number">60</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>若要调试，在编译的过程中要加上-g。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">CC = g++ <span class="hljs-literal">-std</span>=c++<span class="hljs-number">14</span><br>CFLAGS = <span class="hljs-literal">-g</span> <span class="hljs-literal">-Wall</span><br><br>main:<br><span class="hljs-variable">$</span>(CC) <span class="hljs-variable">$</span>(CFLAGS) <span class="hljs-literal">-o</span> main main.cpp<br><br>.PHONY:clean<br>clean:<br><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> main *.o<br></code></pre></td></tr></table></figure><ol start="2"><li>启动gdb进程, 指定需要gdb调试的应用程序名称。<blockquote><p>gdb main</p><ol><li>set args .. 可以设置参数 show args 查看设置的命令行参数</li><li>l l(小写L)命令相当于list，从第一行开始例出原码。</li><li>直接回车表示，重复上一次命令.</li><li>打断点：break 行数，或者函数名，代表函数入口。</li><li>info break 查看断点信息。</li></ol></blockquote></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs powershell">liuchang@DESKTOP<span class="hljs-literal">-LIUCHANG</span>:~/codetest<span class="hljs-variable">$</span> gdb main<br>GNU gdb (Ubuntu <span class="hljs-number">8.1</span>.<span class="hljs-number">1</span><span class="hljs-literal">-0ubuntu1</span>) <span class="hljs-number">8.1</span>.<span class="hljs-number">1</span><br>Copyright (C) <span class="hljs-number">2018</span> Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version <span class="hljs-number">3</span> or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  <span class="hljs-built_in">Type</span> <span class="hljs-string">&quot;show copying&quot;</span><br>and <span class="hljs-string">&quot;show warranty&quot;</span> <span class="hljs-keyword">for</span> details.<br>This GDB was configured as <span class="hljs-string">&quot;x86_64-linux-gnu&quot;</span>.<br><span class="hljs-built_in">Type</span> <span class="hljs-string">&quot;show configuration&quot;</span> <span class="hljs-keyword">for</span> configuration details.<br><span class="hljs-keyword">For</span> bug reporting instructions, please see:<br>&lt;http://www.gnu.org/software/gdb/bugs/&gt;.<br>Find the GDB manual and other documentation resources online at:<br>&lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br><span class="hljs-keyword">For</span> help, <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span>.<br><span class="hljs-built_in">Type</span> <span class="hljs-string">&quot;apropos word&quot;</span> to search <span class="hljs-keyword">for</span> commands related to <span class="hljs-string">&quot;word&quot;</span>...<br>Reading symbols from main...done.<br>(gdb) l<br><span class="hljs-number">101</span><br><span class="hljs-number">102</span>     <span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-number">103</span>     <span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-number">104</span>     <span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-number">105</span><br><span class="hljs-number">106</span>     int func(int n)&#123;<br><span class="hljs-number">107</span>             int sum = <span class="hljs-number">0</span>;<br><span class="hljs-number">108</span>             <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-number">109</span>                     sum+=i;<br><span class="hljs-number">110</span>             &#125;<br>(gdb) l<br><span class="hljs-number">111</span>             <span class="hljs-keyword">return</span> sum;<br><span class="hljs-number">112</span>     &#125;<br><span class="hljs-number">113</span><br><span class="hljs-number">114</span>     int main()&#123;<br><span class="hljs-number">115</span>             long result =<span class="hljs-number">0</span>;<br><span class="hljs-number">116</span>             <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br><span class="hljs-number">117</span>             result+=i;<br><span class="hljs-number">118</span>         &#125;<br><span class="hljs-number">119</span>         cout&lt;&lt;<span class="hljs-string">&quot;result[1-50] =&quot;</span> &lt;&lt;result&lt;&lt;endl;<br><span class="hljs-number">120</span>         cout&lt;&lt;<span class="hljs-string">&quot;result[1-60] =&quot;</span> &lt;&lt;func(<span class="hljs-number">60</span>)&lt;&lt;endl;<br>(gdb) l<br><span class="hljs-number">121</span>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">122</span>     &#125;(gdb) <br>Line number <span class="hljs-number">123</span> out of range; main.cpp has <span class="hljs-number">122</span> lines.<br>(gdb) <span class="hljs-keyword">break</span> <span class="hljs-number">115</span><br>Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x991: file main.cpp, line <span class="hljs-number">115</span>.<br>(gdb) <span class="hljs-keyword">break</span> func<br>Breakpoint <span class="hljs-number">2</span> at <span class="hljs-number">0</span>x961: file main.cpp, line <span class="hljs-number">107</span>.<br>(gdb) info <span class="hljs-keyword">break</span> <br>Num     <span class="hljs-built_in">Type</span>           Disp Enb Address            What<br><span class="hljs-number">1</span>       breakpoint     keep y   <span class="hljs-number">0</span>x0000000000000991 <span class="hljs-keyword">in</span> main() at main.cpp:<span class="hljs-number">115</span><br><span class="hljs-number">2</span>       breakpoint     keep y   <span class="hljs-number">0</span>x0000000000000961 <span class="hljs-keyword">in</span> func(int) at main.cpp:<span class="hljs-number">107</span><br></code></pre></td></tr></table></figure><blockquote><ol start="6"><li>r 运行程序 r是run的缩写。会在断点处挺住</li><li>n单条执行语句，next命令简写。</li><li>c 继续执行程序，continue命令简写。</li><li>p打印变量的值，print命令简写。</li></ol></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(gdb) <span class="hljs-built_in">r</span><br>Starting program: /home/liuchang/codetest/main <br><br>Breakpoint <span class="hljs-number">1</span>, main () at main.cpp:<span class="hljs-number">115</span><br><span class="hljs-number">115</span>             long result =<span class="hljs-number">0</span>;<br>(gdb) n<br><span class="hljs-number">116</span>             <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>(gdb) n<br><span class="hljs-number">117</span>             result+=i;<br>(gdb) n<br><span class="hljs-number">116</span>             <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>(gdb) n<br><span class="hljs-number">117</span>             result+=i;<br>(gdb) c<br>Continuing.<br>result[<span class="hljs-number">1</span>-<span class="hljs-number">50</span>] =<span class="hljs-number">1275</span><br><br>Breakpoint <span class="hljs-number">2</span>, func (n=<span class="hljs-number">60</span>) at main.cpp:<span class="hljs-number">107</span><br><span class="hljs-number">107</span>             int sum = <span class="hljs-number">0</span>;<br>(gdb) n<br><span class="hljs-number">108</span>             <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>(gdb) p i<br><span class="hljs-variable">$1</span> = <span class="hljs-number">0</span><br>(gdb) n<br><span class="hljs-number">109</span>                     sum+=i;<br>(gdb) n<br><span class="hljs-number">108</span>             <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>(gdb) p i<br><span class="hljs-variable">$2</span> = <span class="hljs-number">1</span><br>(gdb) n<br><span class="hljs-number">109</span>                     sum+=i;<br>(gdb) n<br><span class="hljs-number">108</span>             <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>(gdb) p i<br><span class="hljs-variable">$3</span> = <span class="hljs-number">2</span><br>(gdb) <br></code></pre></td></tr></table></figure><blockquote><ol start="10"><li>bt 查看堆栈</li><li>finish退出函数</li><li>q退出gdb</li></ol></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(gdb) bt <br><span class="hljs-comment">#0  func (n=60) at main.cpp:109</span><br><span class="hljs-comment">#1  0x0000000008000a0f in main () at main.cpp:120</span><br>(gdb) finish<br>Run till <span class="hljs-keyword">exit</span> from <span class="hljs-comment">#0  func (n=60) at main.cpp:109</span><br><span class="hljs-number">0</span>x0000000008000a0f <span class="hljs-keyword">in</span> main () at main.cpp:<span class="hljs-number">120</span><br><span class="hljs-number">120</span>         cout&lt;&lt;<span class="hljs-string">&quot;result[1-60] =&quot;</span> &lt;&lt;func(<span class="hljs-number">60</span>)&lt;&lt;endl;<br>Value returned is <span class="hljs-variable">$5</span> = <span class="hljs-number">1830</span><br>(gdb) c<br>Continuing.<br>result[<span class="hljs-number">1</span>-<span class="hljs-number">60</span>] =<span class="hljs-number">1830</span><br>[<span class="hljs-type">Inferior</span> <span class="hljs-number">1</span> (<span class="hljs-type">process</span> <span class="hljs-number">26871</span>) <span class="hljs-type">exited</span> <span class="hljs-type">normally</span>]<br>(gdb) q<br></code></pre></td></tr></table></figure><hr><p><code>使用gdb</code></p><ul><li>如果没有-g，将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。</li><li><strong>启动GDB的方法</strong>：<ul><li>gdb program ：程序一般在当前目录下。</li><li>gdb program.core ： 用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。</li><li>gdb program PID：那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</li></ul></li></ul><p>GDB启动时，可以加一些GDB的启动开关，一般比较常用的就是符号表 -s -c coredump的core文件，-d 添加一个源文件的路径。</p><h2 id="gdb的常用命令"><a href="#gdb的常用命令" class="headerlink" title="gdb的常用命令"></a>gdb的常用命令</h2><blockquote><p>b break的缩写，加断点。<br>info break [n]  查看断点<br>l  list 缩写查看源码<br>c continue缩写，恢复运行。<br><strong>step命令可以缩写为s</strong>, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。<br><strong>n next缩写，单步跟踪程序</strong>。next命令和step命令功能是相似的，只是在使用next调试程序的时候不会进入到函数体内部。<br>p print缩写，可以查看变量值。<br>p file::variable 某文件中的变量<br>p function::variable 全局变量<br>p *array@len 查看数组内容。<br>p&#x2F;x 十六进制格式显示变量。其他格式的变量也有。<br>display i 变量自动显示。<br>whatis para 查看para的类型<br>finish 运行程序，直到当前程序函数完成，并打印函数返回时的堆栈地址和返回值及参数值等信息。<br>until 或 u 运行程序直到结束循环结构。<br>info agrs 查看函数名和参数值<br>info locals 打印当前函数中所有局部变量及其值<br>info line查看源代码内存地址<br>disassemble func 可以查看函数func的汇编代码。<br>set listsize n 设置一次显示源代码的行数。<br>q quit的缩写，退出gdb。</p></blockquote><blockquote><p>set args 可指定运行时参数。如：set args 10 20 30 40 50<br>show args 命令可以查看设置好的运行参数。<br>path dir 可设定程序的运行路径。<br>show paths<br>cd &#x2F; pwd<br>run &gt; outfile重定向输出</p></blockquote><blockquote><p>tty命令可以指写输入输出的终端设备。如：tty &#x2F;dev&#x2F;ttyb</p></blockquote><p><code>调试已经运行的程序</code><br>两种方法：<br>1、在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用<strong>gdb program PID</strong>格式挂接正在运行的程序。<br>2、先用gdb program关联上源代码，并进行gdb，在gdb中用<strong>attach命令</strong>来挂接进程的PID。并用<strong>detach来取消挂接</strong>的进程。</p><p><code>暂停/恢复程序</code><br>在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可以使用c或是continue命令。</p><blockquote><p>break设置断点：</p><ol><li><strong>break function</strong> ：在函数入口处断点。</li><li><strong>break linenum</strong>：在行号处断点。</li><li>break +&#x2F;- offset：在当前偏移量行挺住</li><li><strong>break filename:linenum</strong> 在源文件filename的linenum行处停住</li><li>break filename:function 在源文件filename的function函数的入口处停住。</li><li>break *address 在程序运行的内存地址处停住。</li><li>break命令没有参数时，表示在下一条指令处停住。</li><li><strong>break … if condition</strong>：condition表示条件，在条件成立时停住。比如在循环境体中，可以设置break if i&#x3D;100，表示当i为100时停住程序。</li></ol></blockquote><blockquote><p>watch 设置观察点，观察表达式是否发生变化<br>catchpoint 设置捕捉点，如：载入共享库（动态链接库）或是C++的异常。</p></blockquote><p><code>维护断点</code></p><blockquote><p>clear delete 删除断点。<br>disable 停止使用断点 enable 继续使用<br>condition 设置断点停止条件。<br>ignore 忽视断点。<br><code>在断点处使用</code> commands ：可以在断点处加上命令处理语句。<br>break function 告诉断点在哪个重载函数处加断点。</p></blockquote><p><code>设置变量值</code><br>在调试程序的时候, 我们需要在某个变量等于某个特殊值的时候查看程序的运行状态, 但是通过程序运行让变量等于这个值又非常困难, 这种情况下就可以在 gdb 中直接对这个变量进行值的设置, 或者是在单步调试的时候通过设置循环因子的值直接跳出某个循环, 值设置的命令格式为: <strong>set var 变量名&#x3D;值</strong>。</p><p><code>线程</code><br>如果程序是多线程的话，可以定义断点是否在所有的线程上，或是在某个特定的线程。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">break</span> &lt;linespec&gt; thread &lt;threadno&gt;<br><span class="hljs-keyword">break</span> &lt;linespec&gt; thread &lt;threadno&gt; <span class="hljs-keyword">if</span> ...<br></code></pre></td></tr></table></figure><p>linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，ID是GDB分配的，可以通过“info threads”命令来查看正在运行程序中的线程信息。如果不指定thread &lt; threadno &gt;则表示你的断点设在所有线程上面，还可以为某线程指定断点条件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(gdb) <span class="hljs-keyword">break</span> frik.c:<span class="hljs-number">13</span> thread <span class="hljs-number">28</span> <span class="hljs-keyword">if</span> bartab &gt; lim<br></code></pre></td></tr></table></figure><p><code>栈信息</code></p><blockquote><p>bt 查看栈信息<br>bt n 查看栈顶n层信息<br>bt -n 表示栈底下n层的栈信息<br>frame n 切换栈<br>up n 栈向上移动<br>down n 栈向下移动<br>info frame&#x2F;f 打印栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</p></blockquote><p>搜索源代码：字符串的正则表达式。<br>search<br>forward-search<br>向前搜索<br>reverse-search 全部搜索。</p><p><code>改变程序的执行</code></p><blockquote><p>print x&#x3D;4  修改被调试程序运行时的变量值，将x的值改为4.<br>jump line 跳转到第line行执行。</p></blockquote><h2 id="如何使用gdb调试coredump文件？"><a href="#如何使用gdb调试coredump文件？" class="headerlink" title="如何使用gdb调试coredump文件？"></a>如何使用gdb调试coredump文件？</h2><ol><li>coredump文件是核心转储文件。进程运行时，突然崩溃的那一瞬间，<strong>进程在内存中的一个快照，会把此刻内存，寄存器状态，运行堆栈等信息转储保存到一个文件里面</strong>。肯呢个产生，可能不产生。</li><li>开启coredump：默认的coredump功能是关闭的，用ulimit -c 查看，如果输出为0，则表示异常终止的时候不会产生core dump文件。</li><li>ulimit -c unlimited 开启coredump功能，但是这个功能是临时的。</li><li>设置完成以后可以用ulimit -a 查看是否设置成功。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br>int main()&#123;<br>    int* ptr = NULL;<br>    *ptr = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>产生core 文件以后：<br><img src="https://pic.imgdb.cn/item/66040f759f345e8d03c517ad.png" alt="在这里插入图片描述"><br>使用core进行调试。</p><p><code>程序崩溃产生不了core dump文件怎么办？</code><br>关注core file size大小，如果是0，需要设置一下，不然无法生成core dump文件。一般设置为unlimited。</p><p><code>gdb exe core 的顺序去执行程序调试coredump文件</code><br><img src="https://pic.imgdb.cn/item/66040f849f345e8d03c5b1a0.png" alt="在这里插入图片描述"><br>调试过程：</p><ol><li>查看调用堆栈，寻找崩溃原因。</li><li>根据崩溃点，查找代码分析原因。</li><li>修复bug。<br>这里因为代码比较简单，直接指出了错误的执行函数main函数，指针设置出现段错误。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;cstring&gt;</span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br>void func(char* ptr)&#123;<br>    strcpy(ptr,<span class="hljs-string">&quot;test code ...&quot;</span>);<br>&#125;<br><br>int main()&#123;<br>    char* ptr = NULL;<br>    func(ptr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行，产生coredump文件。<br><img src="https://pic.imgdb.cn/item/66040f919f345e8d03c62f52.png" alt="在这里插入图片描述"><br>查看到是func函数中的问题，ptr是一个空指针。</p><h2 id="如何使用gdb调试多线程程序？"><a href="#如何使用gdb调试多线程程序？" class="headerlink" title="如何使用gdb调试多线程程序？"></a>如何使用gdb调试多线程程序？</h2><ol><li>首先编写一个多线程简单测试样例。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">thread_entry_funcA</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">500</span>;i++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;[thread_entry_funcA]: &quot;</span>&lt;&lt;i&lt;&lt;endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">thread_entry_funcB</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">500</span>;i++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;[thread_entry_funcB]: &quot;</span>&lt;&lt;i&lt;&lt;endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">pthread_t</span> tidA,tidB;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tidA,<span class="hljs-literal">NULL</span>,thread_entry_funcA,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    ret = <span class="hljs-built_in">pthread_create</span>(&amp;tidB,<span class="hljs-literal">NULL</span>,thread_entry_funcB,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pthread_join</span>(tidA,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(tidB,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在运行的时候，打开另一个终端查看运行线程信息。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">liuchang@DESKTOP<span class="hljs-literal">-LIUCHANG</span>:~/codetest<span class="hljs-variable">$</span> <span class="hljs-built_in">ps</span> aux | grep main<br>liuchang   <span class="hljs-number">234</span>  <span class="hljs-number">0.1</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">952340</span> <span class="hljs-number">71772</span> pts/<span class="hljs-number">2</span>    <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">16</span>:<span class="hljs-number">49</span>   <span class="hljs-number">0</span>:<span class="hljs-number">03</span> /home/liuchang<br>liuchang  <span class="hljs-number">2162</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">98104</span>  <span class="hljs-number">1852</span> pts/<span class="hljs-number">6</span>    Tl   <span class="hljs-number">17</span>:<span class="hljs-number">30</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> ./main<br>liuchang  <span class="hljs-number">2225</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">98104</span>  <span class="hljs-number">1884</span> pts/<span class="hljs-number">6</span>    <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">17</span>:<span class="hljs-number">30</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> ./main<br>liuchang  <span class="hljs-number">4682</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">14904</span>  <span class="hljs-number">1096</span> pts/<span class="hljs-number">5</span>    S+   <span class="hljs-number">17</span>:<span class="hljs-number">37</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> grep <span class="hljs-literal">--color</span>=auto main<br>liuchang@DESKTOP<span class="hljs-literal">-LIUCHANG</span>:~/codetest<span class="hljs-variable">$</span> pstack <span class="hljs-number">2162</span><br><br><span class="hljs-number">2162</span>: ./main<br>pstack: Input/output error<br>failed to read target.<br></code></pre></td></tr></table></figure><p><code>pstack无法查看，命令无法使用，vim一个新的pstack文件出来，将下面代码拷贝进去，之后运行拷贝，sudo cp pstack /usr/bin，之后pstack就可以正常使用了。</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#!/bin/sh</span><br><br><span class="hljs-keyword">if</span> test <span class="hljs-variable">$</span><span class="hljs-comment"># -ne 1; then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: `basename <span class="hljs-variable">$0</span> .sh` &lt;process-id&gt;&quot;</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">2</span><br>    <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br>fi<br><br><span class="hljs-keyword">if</span> test ! <span class="hljs-literal">-r</span> /proc/<span class="hljs-variable">$1</span>; then<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Process <span class="hljs-variable">$1</span> not found.&quot;</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">2</span><br>    <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br>fi<br><br><span class="hljs-comment"># GDB doesn&#x27;t allow &quot;thread apply all bt&quot; when the process isn&#x27;t</span><br><span class="hljs-comment"># threaded; need to peek at the process to determine if that or the</span><br><span class="hljs-comment"># simpler &quot;bt&quot; should be used.</span><br><br>backtrace=<span class="hljs-string">&quot;bt&quot;</span><br><span class="hljs-keyword">if</span> test <span class="hljs-literal">-d</span> /proc/<span class="hljs-variable">$1</span>/task ; then<br>    <span class="hljs-comment"># Newer kernel; has a task/ directory.</span><br>    <span class="hljs-keyword">if</span> test `/bin/<span class="hljs-built_in">ls</span> /proc/<span class="hljs-variable">$1</span>/task | /usr/bin/wc <span class="hljs-literal">-l</span>` <span class="hljs-operator">-gt</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>&gt;/dev/null ; then<br>backtrace=<span class="hljs-string">&quot;thread apply all bt&quot;</span><br>    fi<br>elif test <span class="hljs-operator">-f</span> /proc/<span class="hljs-variable">$1</span>/maps ; then<br>    <span class="hljs-comment"># Older kernel; go by it loading libpthread.</span><br>    <span class="hljs-keyword">if</span> /bin/grep <span class="hljs-literal">-e</span> libpthread /proc/<span class="hljs-variable">$1</span>/maps &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> ; then<br>backtrace=<span class="hljs-string">&quot;thread apply all bt&quot;</span><br>    fi<br>fi<br><br>GDB=<span class="hljs-variable">$</span>&#123;GDB:-/usr/bin/gdb&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$GDB</span> <span class="hljs-literal">-nx</span> <span class="hljs-literal">--quiet</span> <span class="hljs-literal">--batch</span> <span class="hljs-literal">--readnever</span> &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>; then<br>    readnever=<span class="hljs-literal">--readnever</span><br><span class="hljs-keyword">else</span><br>    readnever=<br>fi<br><br><span class="hljs-comment"># Run GDB, strip out unwanted noise.</span><br><span class="hljs-variable">$GDB</span> <span class="hljs-literal">--quiet</span> <span class="hljs-variable">$readnever</span> <span class="hljs-literal">-nx</span> /proc/<span class="hljs-variable">$1</span>/exe <span class="hljs-variable">$1</span> &lt;&lt;EOF <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | <br><span class="hljs-built_in">set</span> width <span class="hljs-number">0</span><br><span class="hljs-built_in">set</span> height <span class="hljs-number">0</span><br><span class="hljs-built_in">set</span> pagination no<br><span class="hljs-variable">$backtrace</span><br>EOF<br>/bin/sed <span class="hljs-literal">-n</span> \<br>    <span class="hljs-literal">-e</span> <span class="hljs-string">&#x27;s/^\((gdb) \)*//&#x27;</span> \<br>    <span class="hljs-literal">-e</span> <span class="hljs-string">&#x27;/^#/p&#x27;</span> \<br>    <span class="hljs-literal">-e</span> <span class="hljs-string">&#x27;/^Thread/p&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs powershell">liuchang@DESKTOP<span class="hljs-literal">-LIUCHANG</span>:~/codetest<span class="hljs-variable">$</span> <span class="hljs-built_in">ps</span> aux | grep main<br>liuchang   <span class="hljs-number">234</span>  <span class="hljs-number">0.1</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">953252</span> <span class="hljs-number">73580</span> pts/<span class="hljs-number">2</span>    <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">16</span>:<span class="hljs-number">49</span>   <span class="hljs-number">0</span>:<span class="hljs-number">04</span> /home<br>liuchang  <span class="hljs-number">2162</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">98104</span>  <span class="hljs-number">1852</span> pts/<span class="hljs-number">6</span>    Tl   <span class="hljs-number">17</span>:<span class="hljs-number">30</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> ./main<br>liuchang  <span class="hljs-number">5255</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">98104</span>  <span class="hljs-number">1956</span> pts/<span class="hljs-number">6</span>    Tl   <span class="hljs-number">17</span>:<span class="hljs-number">39</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> ./main<br>liuchang  <span class="hljs-number">5892</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">98104</span>  <span class="hljs-number">1948</span> pts/<span class="hljs-number">6</span>    <span class="hljs-built_in">Sl</span>+  <span class="hljs-number">17</span>:<span class="hljs-number">47</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> ./main<br>liuchang  <span class="hljs-number">6055</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">14904</span>  <span class="hljs-number">1088</span> pts/<span class="hljs-number">5</span>    S+   <span class="hljs-number">17</span>:<span class="hljs-number">47</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> grep <span class="hljs-literal">--color</span>=auto main<br><br>liuchang@DESKTOP<span class="hljs-literal">-LIUCHANG</span>:~/codetest<span class="hljs-variable">$</span> pstack <span class="hljs-number">5892</span><br>Thread <span class="hljs-number">3</span> (Thread <span class="hljs-number">0</span>x7fa009552700 (LWP <span class="hljs-number">5894</span>)):<br><span class="hljs-comment">#0  0x00007fa00a3ee680 in nanosleep () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="hljs-comment">#1  0x0000559d9fe02020 in ?? ()</span><br><span class="hljs-comment">#2  0x00007fa00a80e65b in std::ostream::put(char) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="hljs-comment">#3  0x0000000000000001 in ?? ()</span><br><span class="hljs-comment">#4  0xffffffffffffff60 in ?? ()</span><br><span class="hljs-comment">#5  0x0000000000000000 in ?? ()</span><br>Thread <span class="hljs-number">2</span> (Thread <span class="hljs-number">0</span>x7fa009d53700 (LWP <span class="hljs-number">5893</span>)):<br><span class="hljs-comment">#0  0x00007fa00a3ee680 in nanosleep () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="hljs-comment">#1  0x0000559d9fe02020 in ?? ()</span><br><span class="hljs-comment">#2  0x00007fa00a80e65b in std::ostream::put(char) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="hljs-comment">#3  0x0000000000000001 in ?? ()</span><br><span class="hljs-comment">#4  0xffffffffffffff60 in ?? ()</span><br><span class="hljs-comment">#5  0x0000000000000000 in ?? ()</span><br>Thread <span class="hljs-number">1</span> (Thread <span class="hljs-number">0</span>x7fa00aebd740 (LWP <span class="hljs-number">5892</span>)):<br><span class="hljs-comment">#0  0x00007fa00aa8cd2d in __pthread_timedjoin_ex () from /lib/x86_64-linux-gnu/libpthread.so.0 #主线程pthreadjoin</span><br><span class="hljs-comment">#1  0x0000000000001000 in ?? ()</span><br><span class="hljs-comment">#2  0x0000000000000000 in ?? ()</span><br></code></pre></td></tr></table></figure><p><code>多线程程序的调试：查看线程信息，切换线程，切换到某一层堆栈</code></p><ul><li>gdb打上断点，并且执行之后，info threads查看线程信息。</li><li>t 加线程id，切换线程。</li><li>bt 查看堆栈</li><li>f 加堆栈编号，切换到具体堆栈。</li><li>p 查看想查看的变量信息</li><li>n 不仅使当前线程执行一步，其他线程也会执行一部分。(怎么让线程A执行的时候，线程B不要执行？调度器锁)</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(gdb) info threads<br>  Id   Target Id         Frame <br>  <span class="hljs-number">1</span>    Thread <span class="hljs-number">0</span>x7ffff7fe8740 (LWP <span class="hljs-number">27863</span>) <span class="hljs-string">&quot;main&quot;</span> clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:<span class="hljs-number">78</span><br>* <span class="hljs-number">2</span>    Thread <span class="hljs-number">0</span>x7ffff6e83700 (LWP <span class="hljs-number">27867</span>) <span class="hljs-string">&quot;main&quot;</span> thread_entry_funcA (arg=<span class="hljs-number">0</span>x0) at main.cpp:<span class="hljs-number">12</span><br>  <span class="hljs-number">3</span>    Thread <span class="hljs-number">0</span>x7ffff6682700 (LWP <span class="hljs-number">27868</span>) <span class="hljs-string">&quot;main&quot;</span> clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:<span class="hljs-number">78</span><br>(gdb) t <span class="hljs-number">1</span><br>[<span class="hljs-type">Switching</span> <span class="hljs-type">to</span> <span class="hljs-type">thread</span> <span class="hljs-number">1</span> (<span class="hljs-type">Thread</span> <span class="hljs-number">0</span><span class="hljs-type">x7ffff7fe8740</span> (<span class="hljs-type">LWP</span> <span class="hljs-number">27863</span>))]<br><span class="hljs-comment">#0  clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:78</span><br><span class="hljs-number">78</span>      ../sysdeps/unix/sysv/linux/x86_64/clone.S: No such file or directory.<br>(gdb) t <span class="hljs-number">2</span>t<br>Invalid thread ID: <span class="hljs-number">2</span>t<br>(gdb) t <span class="hljs-number">2</span>t<span class="hljs-string">&#x27;</span><br><span class="hljs-string">Invalid thread ID: 2t&#x27;</span><br>(gdb) t <span class="hljs-number">2</span><br>[<span class="hljs-type">Switching</span> <span class="hljs-type">to</span> <span class="hljs-type">thread</span> <span class="hljs-number">2</span> (<span class="hljs-type">Thread</span> <span class="hljs-number">0</span><span class="hljs-type">x7ffff6e83700</span> (<span class="hljs-type">LWP</span> <span class="hljs-number">27867</span>))]<br><span class="hljs-comment">#0  thread_entry_funcA (arg=0x0) at main.cpp:12</span><br><span class="hljs-number">12</span>              cout&lt;&lt;<span class="hljs-string">&quot;[thread_entry_funcA]: &quot;</span>&lt;&lt;i&lt;&lt;endl;<br>(gdb) bt<br><span class="hljs-comment">#0  thread_entry_funcA (arg=0x0) at main.cpp:12</span><br><span class="hljs-comment">#1  0x00007ffff7bbb6db in start_thread (arg=0x7ffff6e83700) at pthread_create.c:463</span><br><span class="hljs-comment">#2  0x00007ffff755b61f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br>(gdb) f <span class="hljs-number">0</span><br><span class="hljs-comment">#0  thread_entry_funcA (arg=0x0) at main.cpp:12</span><br><span class="hljs-number">12</span>              cout&lt;&lt;<span class="hljs-string">&quot;[thread_entry_funcA]: &quot;</span>&lt;&lt;i&lt;&lt;endl;<br>(gdb) p i<br><span class="hljs-variable">$1</span> = <span class="hljs-number">0</span><br>(gdb) n<br>[<span class="hljs-type">Switching</span> <span class="hljs-type">to</span> <span class="hljs-type">Thread</span> <span class="hljs-number">0</span><span class="hljs-type">x7ffff6682700</span> (<span class="hljs-type">LWP</span> <span class="hljs-number">27868</span>)]<br><br>Thread <span class="hljs-number">3</span> <span class="hljs-string">&quot;main&quot;</span> hit Breakpoint <span class="hljs-number">2</span>, thread_entry_funcB (arg=<span class="hljs-number">0</span>x0) at main.cpp:<span class="hljs-number">20</span><br><span class="hljs-number">20</span>              cout&lt;&lt;<span class="hljs-string">&quot;[thread_entry_funcB]: &quot;</span>&lt;&lt;i&lt;&lt;endl;<br>(gdb) info threads<br>  Id   Target Id         Frame <br>  <span class="hljs-number">1</span>    Thread <span class="hljs-number">0</span>x7ffff7fe8740 (LWP <span class="hljs-number">27863</span>) <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-number">0</span>x00007ffff7bbcd2d <span class="hljs-keyword">in</span> __GI___pthread_timedjoin_ex (threadid=<span class="hljs-number">140737335801600</span>, thread_return=<span class="hljs-number">0</span>x0, abstime=<span class="hljs-number">0</span>x0, block=&lt;optimized out&gt;) at pthread_join_common.c:<span class="hljs-number">89</span><br>  <span class="hljs-number">2</span>    Thread <span class="hljs-number">0</span>x7ffff6e83700 (LWP <span class="hljs-number">27867</span>) <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-number">0</span>x0000555555400b04 <span class="hljs-keyword">in</span> thread_entry_funcA (arg=<span class="hljs-number">0</span>x0) at main.cpp:<span class="hljs-number">12</span><br>* <span class="hljs-number">3</span>    Thread <span class="hljs-number">0</span>x7ffff6682700 (LWP <span class="hljs-number">27868</span>) <span class="hljs-string">&quot;main&quot;</span> thread_entry_funcB (arg=<span class="hljs-number">0</span>x0) at main.cpp:<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><code>调度器锁模式：只有线程创建之后的暂停效果才有效</code></p><blockquote><p>调试时除了当前线程在运行，想要规定其他线程的运行情况，可以使用set scheduler-locking [mode] 命令来进行设置。</p><ol><li>set scheduler-locking  off：不锁定任何线程，所有线程都可以继续执行。</li><li>set scheduler-locking on：只有当前线程可以执行，其他线程暂停。</li><li>set scheduler-locking step：<br> *  当单步执行某一线程时，其它线程不会执行，同时保证在调试过程中当前线程不会发生改变。但如果该模式下执行 continue、until、finish 命令，则其它线程也会执行，并且如果某一线程执行过程遇到断点，则 GDB 调试器会将该线程作为当前线程。<code>centos好像是可以执行的，但是ubuntu不会执行</code><br> * 但如果在该模式下执行continue，until，finish命令，其他线程也会执行，并且如果某一线程执行过程中遇到断点，则GDB调试器会将该线程作为当前线程。</li></ol></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(gdb) b <span class="hljs-number">12</span><br>Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>xaf6: file main.cpp, line <span class="hljs-number">12</span>.<br>(gdb) b <span class="hljs-number">20</span><br>Breakpoint <span class="hljs-number">2</span> at <span class="hljs-number">0</span>xb61: file main.cpp, line <span class="hljs-number">20</span>.<br>(gdb) info b<br>Num     <span class="hljs-built_in">Type</span>           Disp Enb Address            What<br><span class="hljs-number">1</span>       breakpoint     keep y   <span class="hljs-number">0</span>x0000000000000af6 <span class="hljs-keyword">in</span> thread_entry_funcA(void*) at main.cpp:<span class="hljs-number">12</span><br><span class="hljs-number">2</span>       breakpoint     keep y   <span class="hljs-number">0</span>x0000000000000b61 <span class="hljs-keyword">in</span> thread_entry_funcB(void*) at main.cpp:<span class="hljs-number">20</span><br>(gdb) <span class="hljs-built_in">r</span><br>Starting program: /home/liuchang/codetest/main <br>[<span class="hljs-type">Thread</span> <span class="hljs-type">debugging</span> <span class="hljs-type">using</span> <span class="hljs-type">libthread_db</span> <span class="hljs-type">enabled</span>]<br><span class="hljs-keyword">Using</span> host libthread_db library <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.<br>[<span class="hljs-type">New</span> <span class="hljs-type">Thread</span> <span class="hljs-number">0</span><span class="hljs-type">x7ffff6e83700</span> (<span class="hljs-type">LWP</span> <span class="hljs-number">835</span>)]<br>[<span class="hljs-type">New</span> <span class="hljs-type">Thread</span> <span class="hljs-number">0</span><span class="hljs-type">x7ffff6682700</span> (<span class="hljs-type">LWP</span> <span class="hljs-number">836</span>)]<br>[<span class="hljs-type">Switching</span> <span class="hljs-type">to</span> <span class="hljs-type">Thread</span> <span class="hljs-number">0</span><span class="hljs-type">x7ffff6e83700</span> (<span class="hljs-type">LWP</span> <span class="hljs-number">835</span>)]<br><br>Thread <span class="hljs-number">2</span> <span class="hljs-string">&quot;main&quot;</span> hit Breakpoint <span class="hljs-number">1</span>, thread_entry_funcA (arg=<span class="hljs-number">0</span>x0) at main.cpp:<span class="hljs-number">12</span><br><span class="hljs-number">12</span>              cout&lt;&lt;<span class="hljs-string">&quot;[thread_entry_funcA]: &quot;</span>&lt;&lt;i&lt;&lt;endl;<br>(gdb) info threads<br>  Id   Target Id         Frame <br>  <span class="hljs-number">1</span>    Thread <span class="hljs-number">0</span>x7ffff7fe8740 (LWP <span class="hljs-number">831</span>) <span class="hljs-string">&quot;main&quot;</span> clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:<span class="hljs-number">78</span><br>* <span class="hljs-number">2</span>    Thread <span class="hljs-number">0</span>x7ffff6e83700 (LWP <span class="hljs-number">835</span>) <span class="hljs-string">&quot;main&quot;</span> thread_entry_funcA (arg=<span class="hljs-number">0</span>x0) at main.cpp:<span class="hljs-number">12</span><br>  <span class="hljs-number">3</span>    Thread <span class="hljs-number">0</span>x7ffff6682700 (LWP <span class="hljs-number">836</span>) <span class="hljs-string">&quot;main&quot;</span> thread_entry_funcB (arg=<span class="hljs-number">0</span>x0) at main.cpp:<span class="hljs-number">20</span><br>(gdb) bt<br><span class="hljs-comment">#0  thread_entry_funcA (arg=0x0) at main.cpp:12</span><br><span class="hljs-comment">#1  0x00007ffff7bbb6db in start_thread (arg=0x7ffff6e83700) at pthread_create.c:463</span><br><span class="hljs-comment">#2  0x00007ffff755b61f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br>(gdb) f <span class="hljs-number">0</span><br><span class="hljs-comment">#0  thread_entry_funcA (arg=0x0) at main.cpp:12</span><br><span class="hljs-number">12</span>              cout&lt;&lt;<span class="hljs-string">&quot;[thread_entry_funcA]: &quot;</span>&lt;&lt;i&lt;&lt;endl;<br>(gdb) n  <span class="hljs-comment">#想要执行线程A，但是发现线程切换到了线程B</span><br>[<span class="hljs-type">Switching</span> <span class="hljs-type">to</span> <span class="hljs-type">Thread</span> <span class="hljs-number">0</span><span class="hljs-type">x7ffff6682700</span> (<span class="hljs-type">LWP</span> <span class="hljs-number">836</span>)]<br><br>Thread <span class="hljs-number">3</span> <span class="hljs-string">&quot;main&quot;</span> hit Breakpoint <span class="hljs-number">2</span>, thread_entry_funcB (arg=<span class="hljs-number">0</span>x0) at main.cpp:<span class="hljs-number">20</span><br><span class="hljs-number">20</span>              cout&lt;&lt;<span class="hljs-string">&quot;[thread_entry_funcB]: &quot;</span>&lt;&lt;i&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>参考列表：<br><a href="https://haoel.blog.csdn.net/article/details/2879">https://haoel.blog.csdn.net/article/details/2879</a><br><a href="https://subingwen.cn/linux/gdb/">https://subingwen.cn/linux/gdb/</a><br><a href="https://www.bilibili.com/video/BV1mp4y1A7Ss">https://www.bilibili.com/video/BV1mp4y1A7Ss</a><br><a href="https://blog.csdn.net/u010164190/article/details/111059283">https://blog.csdn.net/u010164190/article/details/111059283</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习三(Makefile)</title>
    <link href="/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%B8%89(Makefile)/"/>
    <url>/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%B8%89(Makefile)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习三-Makefile"><a href="#Linux学习三-Makefile" class="headerlink" title="Linux学习三 : Makefile"></a>Linux学习三 : Makefile</h1><p><code>make是一个命令工具，是一个解释makefile中指令的命令工具</code></p><p>make工具在构造项目的时候需要加载一个叫做makefile的文件，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p><p>makefile的好处就是可以自动化部编译，一旦写好，只需要执行make指令，整个工程就可以自动编译。</p><p>makefile文件有两种命名方式 makefile 和 Makefile，<strong>构建项目的时候在哪个目录下执行构建命令 make这个目录下的 makefile 文件就会别加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中</strong>。</p><hr><h2 id="Makefile的语法规则"><a href="#Makefile的语法规则" class="headerlink" title="Makefile的语法规则"></a>Makefile的语法规则</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">target1,target2...: depend1, depend2, ...<br>command<br>......<br>......<br></code></pre></td></tr></table></figure><p>每条规则由三个部分组成分别是目标(target), 依赖(depend)和命令(command)。<br><strong>命令(command)</strong>: 当前这条规则的动作，一般情况下这个动作就是一个 shell 命令。<br>*例如：通过某个命令编译文件、生成库文件、进入目录等。<br>*动作可以是多个，每个命令前必须有一个Tab缩进并且独占占一行。</p><p><strong>依赖(depend)</strong>: 规则所必需的依赖条件，在规则的命令中可以使用这些依赖。</p><ul><li>例如：生成可执行文件的目标文件（*.o）可以作为依赖使用。</li><li>如果规则的命令中不需要任何依赖，那么规则的依赖可以为空。</li><li>当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则之间的嵌套。</li><li>依赖可以根据要执行的命令的实际需求, 指定很多个。</li></ul><p><strong>目标(target)<strong>： 规则中的目标，这个目标和规则中的命令是对应的。<br>*通过执行规则中的命令，可以生成一个和目标同名的文件。<br>*规则中可以有多个命令, 因此可以通过这多条命令来生成多个目标, 所有目标也可以有很多个。<br>*通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被称为</strong>伪目标</strong>。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app</span><br><span class="hljs-comment">################# 例1 #################</span><br>app:a.c b.c c.c<br>gcc a.c b.c c.c <span class="hljs-literal">-o</span> app<br><br><br><span class="hljs-comment">################# 例2 #################</span><br><span class="hljs-comment"># 有多个目标, 多个依赖, 多个命令</span><br>app,app1:a.c b.c c.c d.c<br>gcc a.c b.c <span class="hljs-literal">-o</span> app<br>gcc c.c d.c <span class="hljs-literal">-o</span> app1<br><br><br><span class="hljs-comment">################# 例3 #################</span><br><span class="hljs-comment"># 规则之间的嵌套：app的生成，需要a.o b.o c.o首先生成。</span><br>app:a.o b.o c.o<br>gcc a.o b.o c.o <span class="hljs-literal">-o</span> app<br><span class="hljs-comment"># a.o 是第一条规则中的依赖</span><br>a.o:a.c<br>gcc <span class="hljs-literal">-c</span> a.c<br><span class="hljs-comment"># b.o 是第一条规则中的依赖</span><br>b.o:b.c<br>gcc <span class="hljs-literal">-c</span> b.c<br><span class="hljs-comment"># c.o 是第一条规则中的依赖</span><br>c.o:c.c<br>gcc <span class="hljs-literal">-c</span> c.c<br></code></pre></td></tr></table></figure><p><code>规则的执行</code></p><p>在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。但是如果依赖不存在的话，就不会执行。需要先将依赖生成出来，就可以在makefile中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。</p><p>这样，makefile中的某一条规则在需要的时候，就会被其他的规则调用，直到makefile中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。</p><p><code>规则的嵌套</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># makefile</span><br><span class="hljs-comment"># 规则之间的嵌套</span><br><span class="hljs-comment"># 规则1</span><br>app:a.o b.o c.o<br>gcc a.o b.o c.o <span class="hljs-literal">-o</span> app<br><span class="hljs-comment"># 规则2</span><br>a.o:a.c<br>gcc <span class="hljs-literal">-c</span> a.c<br><span class="hljs-comment"># 规则3</span><br>b.o:b.c<br>gcc <span class="hljs-literal">-c</span> b.c<br><span class="hljs-comment"># 规则4</span><br>c.o:c.c<br>gcc <span class="hljs-literal">-c</span> c.c<br></code></pre></td></tr></table></figure><p>当依赖不存在的时候，make就是查找其他的规则，看哪一条规则是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。因此规则2， 规则3， 规则4里的命令会相继被执行，当规则1中依赖全部被生成之后对应的命令也就被执行了，因此规则1的目标被生成，make工作结束。</p><blockquote><p>如果想要执行makefile中非第一条的命令，就要在make后面加上具体的命令，比如 make c.o 单独执行规则4。</p></blockquote><p><code>make判断是否进行编译</code></p><ul><li>make进行编译的时候，如果目标的时间戳&gt;依赖的时间戳，就不再进行编译，因为依赖没有更新，也就不会生成新的目标。</li><li>当目标的时间戳&lt;依赖的时间戳，证明需要更新，依赖变化了。</li><li>目标不存在，那么肯定更新。</li></ul><blockquote><p>根据上文的描述, 先执行 make 命令，基于这个 makefile 编译这几个源文件生成对应的目标文件。然后再修改例子中的 a.c, 再次通过make编译这几个源文件，那么这个时候先执行规则2更新目标文件a.o， 然后再执行规则1更新目标文件app，其余的规则是不会被执行的。</p></blockquote><blockquote><p>make有时候并不会完全依赖makefile，会进行自动推导，比如: 使用命令 make 编译扩展名为.c 的 C 语言文件的时候，源文件的编译规则不用明确给出。这是因为 make 进行编译的时候会使用一个默认的编译规则，按照默认规则完成对.c文件的编译，生成对应的.o 文件。它使用命令cc -c来编译.c 源文件。</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>makefile中的变量分为三种：自定义变量，预定义变量和自动变量。</p><blockquote><p>自定义变量：用 Makefile 进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。定义变量后用$符号将变量取出。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">CC = g++ <span class="hljs-literal">-std</span>=c++<span class="hljs-number">14</span><br>CFLAGS = <span class="hljs-literal">-g</span> <span class="hljs-literal">-Wall</span><br><br>main:<br><span class="hljs-variable">$</span>(CC) <span class="hljs-variable">$</span>(CFLAGS) <span class="hljs-literal">-o</span> main main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 这是一个规则，里边使用了自定义变量</span><br>obj=add.o  div.o  main.o  mult.o  sub.o<br>target=calc<br><span class="hljs-variable">$</span>(target):<span class="hljs-variable">$</span>(obj)<br>        gcc  <span class="hljs-variable">$</span>(obj) <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span>(target)<br></code></pre></td></tr></table></figure><blockquote><p>预定义变量：在 Makefile 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的。<br><img src="https://pic.imgdb.cn/item/66040f549f345e8d03c3d56b.png" alt="在这里插入图片描述"></p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 这是一个规则，里边使用了自定义变量和预定义变量</span><br>obj=add.o  div.o  main.o  mult.o  sub.o<br>target=calc<br>CFLAGS=<span class="hljs-literal">-O3</span> <span class="hljs-comment"># 代码优化</span><br><span class="hljs-variable">$</span>(target):<span class="hljs-variable">$</span>(obj)<br>        <span class="hljs-variable">$</span>(CC)  <span class="hljs-variable">$</span>(obj) <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span>(target) <span class="hljs-variable">$</span>(CFLAGS)<br></code></pre></td></tr></table></figure><blockquote><p>自动变量：Makefile 中的规则语句中经常会出现目标文件和依赖文件，自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span>*表示目标文件的名称，不包含目标文件的扩展名<br><span class="hljs-variable">$</span>+表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 包含重复的依赖文件<br><span class="hljs-variable">$</span>&lt;表示依赖项中第一个依赖文件的名称<br><span class="hljs-variable">$</span>?依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开<br><span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>表示目标文件的名称，包含文件扩展名<br><span class="hljs-variable">$</span>^依赖项中，所有不重复的依赖文件，这些文件之间以空格分开<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 这是一个规则，里边使用了自定义变量</span><br><span class="hljs-comment"># 使用自动变量, 替换相关的内容</span><br>calc:add.o  div.o  main.o  mult.o  sub.o<br>gcc <span class="hljs-variable">$</span>^ <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span> <span class="hljs-comment"># 自动变量只能在规则的命令中使用</span><br><br></code></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配将一系列的相同操作整理成一个模板，所有类似的操作都通过模板去匹配 makefile 会因此而精简不少，只是可读性会有所下降。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 模式匹配 -&gt; 通过一个公式, 代表若干个满足条件的规则</span><br><span class="hljs-comment"># 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, % 是一个通配符, 匹配的是文件名</span><br>%.o:%.c<br>gcc <span class="hljs-variable">$</span>&lt; <span class="hljs-literal">-c</span>  <span class="hljs-comment"># 单独只有一个的时候就会用$&lt;自动变量</span><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>makefile的函数主要是为了方便的获取返回值，写法是这样的： $(函数名 参数1, 参数2, 参数3, …)。<br><strong>wildcard函数</strong>：获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔</span><br><span class="hljs-variable">$</span>(wildcard PATTERN...)<br>参数:指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c<br>得到的若干个文件的文件列表， 文件名之间使用空格间隔<br>示例：<span class="hljs-variable">$</span>(wildcard *.c ./sub/*.c)<br>返回值格式: a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c<br>中间的参数可以更多，以空格分开就可以了。<br></code></pre></td></tr></table></figure><p><strong>patsubst函数</strong>：按照指定的模式替换指定的文件名的后缀。有三个参数, 参数之间使用逗号间隔。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 有三个参数, 参数之间使用 逗号间隔</span><br><span class="hljs-variable">$</span>(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)<br><br>pattern: 这是一个模式字符串, 需要指定出要被替换的文件名中的后缀是什么，一般用%加后缀<br>replacement: 这是一个模式字符串, 指定参数pattern中的后缀最终要被替换为什么，通常也是%加后缀<br>text: 该参数中存储这要被替换的原始数据<br>返回值为替换后的字符串。<br><br>src = a.cpp b.cpp c.cpp e.cpp<br><span class="hljs-comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span><br>obj = <span class="hljs-variable">$</span>(patsubst %.cpp, %.o, <span class="hljs-variable">$</span>(src)) <br><span class="hljs-comment"># obj 的值为: a.o b.o c.o e.o</span><br><br></code></pre></td></tr></table></figure><p>makefile编写：一步一步编写makefile文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 项目目录结构</span><br>.<br>├── add.c<br>├── div.c<br>├── head.h<br>├── main.c<br>├── mult.c<br>└── sub.c<br><span class="hljs-comment"># 需要编写makefile对该项目进行自动化编译</span><br></code></pre></td></tr></table></figure><p>版本1：最简单版本：书写简单，但只要依赖中的某一个源文件被修改，所有的源文件都需要被重新编译，太耗时、效率低。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">calc:add.c  div.c  main.c  mult.c  sub.c<br>        gcc add.c  div.c  main.c  mult.c  sub.c <span class="hljs-literal">-o</span> calc<br></code></pre></td></tr></table></figure><p>版本2：修改哪一个源文件, 哪个源文件被重新编译, 不修改就不重新编译。但是代码冗余。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 默认所有的依赖都不存在, 需要使用其他规则生成这些依赖</span><br><span class="hljs-comment"># 因为 add.o 被更新, 需要使用最新的依赖, 生成最新的目标</span><br>calc:add.o  div.o  main.o  mult.o  sub.o<br>        gcc  add.o  div.o  main.o  mult.o  sub.o <span class="hljs-literal">-o</span> calc<br><br><span class="hljs-comment"># 如果修改了add.c, add.o 被重新生成</span><br>add.o:add.c<br>        gcc add.c <span class="hljs-literal">-c</span><br><br>div.o:div.c<br>        gcc div.c <span class="hljs-literal">-c</span><br><br>main.o:main.c<br>        gcc main.c <span class="hljs-literal">-c</span><br><br>sub.o:sub.c<br>        gcc sub.c <span class="hljs-literal">-c</span><br><br>mult.o:mult.c<br>        gcc mult.c <span class="hljs-literal">-c</span><br></code></pre></td></tr></table></figure><p>版本3：降低冗余，使用变量和模式匹配。代码相对简洁，但是变量obj的值需要手动写出来，如果需要编译的项目文件很多，都用手写出来不现实。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 添加自定义变量 </span><br>obj=add.o  div.o  main.o  mult.o  sub.o<br>target=calc<br><br><span class="hljs-variable">$</span>(target):<span class="hljs-variable">$</span>(obj)<br>        gcc <span class="hljs-variable">$</span>(obj)  <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span>(target)<br><br>%.o:%.c<br>        gcc <span class="hljs-variable">$</span>&lt; <span class="hljs-literal">-c</span><br></code></pre></td></tr></table></figure><p>版本4：在makefile中使用函数。解决了自动加载项目文件的问题，解放了双手，但没有文件删除的功能，不能删除项目编译过程中生成的目标文件（*.o）和可执行程序。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 添加自定义变量 </span><br><span class="hljs-comment"># 使用函数搜索当前目录下的源文件 .c</span><br>src=<span class="hljs-variable">$</span>(wildcard *.c)<br><span class="hljs-comment"># 将源文件的后缀替换为 .o</span><br><span class="hljs-comment"># % 匹配的内容是不能被替换的, 需要替换的是第一个参数中的后缀, 替换为第二个参数中指定的后缀</span><br><span class="hljs-comment"># obj=$(patsubst %.cpp, %.o, $(src)) 将src中的关键字 .cpp 替换为 .o</span><br>obj=<span class="hljs-variable">$</span>(patsubst %.c, %.o, <span class="hljs-variable">$</span>(src))<br>target=calc<br><br><span class="hljs-variable">$</span>(target):<span class="hljs-variable">$</span>(obj)<br>        gcc <span class="hljs-variable">$</span>(obj)  <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span>(target)<br><br>%.o:%.c<br>        gcc <span class="hljs-variable">$</span>&lt; <span class="hljs-literal">-c</span><br></code></pre></td></tr></table></figure><p>版本5：在makefile文件中添加新的规则用于删除生成的目标文件（*.o）和可执行程序。可以用make clean删除不需要的文件和程序。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 添加自定义变量 </span><br><span class="hljs-comment"># 使用函数搜索当前目录下的源文件 .c</span><br>src=<span class="hljs-variable">$</span>(wildcard *.c)<br><span class="hljs-comment"># 将源文件的后缀替换为 .o</span><br>obj=<span class="hljs-variable">$</span>(patsubst %.c, %.o, <span class="hljs-variable">$</span>(src))<br>target=calc<br><span class="hljs-comment"># obj 的值 xxx.o xxx.o xxx.o xx.o</span><br><span class="hljs-variable">$</span>(target):<span class="hljs-variable">$</span>(obj)<br>        gcc <span class="hljs-variable">$</span>(obj)  <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span>(target)<br><br>%.o:%.c<br>        gcc <span class="hljs-variable">$</span>&lt; <span class="hljs-literal">-c</span><br><br><span class="hljs-comment"># 添加规则, 删除生成文件 *.o 可执行程序</span><br><span class="hljs-comment"># 这个规则比较特殊, clean根本不会生成, 这是一个伪目标</span><br>clean:<br>        <span class="hljs-built_in">rm</span> <span class="hljs-variable">$</span>(obj) <span class="hljs-variable">$</span>(target)<br><br></code></pre></td></tr></table></figure><p>版本6：在makefile中将clean声明为一个伪目标，在 makefile 中声明一个伪目标需要使用 .PHONY 关键字, 声明方式为: .PHONY:伪文件名称。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 添加自定义变量 </span><br><span class="hljs-comment"># 使用函数搜索当前目录下的源文件 .c</span><br>src=<span class="hljs-variable">$</span>(wildcard *.c)<br><span class="hljs-comment"># 将源文件的后缀替换为 .o</span><br>obj=<span class="hljs-variable">$</span>(patsubst %.c, %.o, <span class="hljs-variable">$</span>(src))<br>target=calc<br><br><span class="hljs-variable">$</span>(target):<span class="hljs-variable">$</span>(obj)<br>        gcc <span class="hljs-variable">$</span>(obj)  <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span>(target)<br><br>%.o:%.c<br>        gcc <span class="hljs-variable">$</span>&lt; <span class="hljs-literal">-c</span><br><br><span class="hljs-comment"># 添加规则, 删除生成文件 *.o 可执行程序</span><br><span class="hljs-comment"># 声明clean为伪文件</span><br>.PHONY:clean<br>clean:<br>        <span class="hljs-comment"># shell命令前的 - 表示强制这个指令执行, 如果执行失败也不会终止</span><br>        <span class="hljs-literal">-rm</span> <span class="hljs-variable">$</span>(obj) <span class="hljs-variable">$</span>(target) <br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello, 我是测试字符串&quot;</span><br></code></pre></td></tr></table></figure><p><code>较复杂结构的makefile编写</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 目录结构</span><br>.<br>├── include<br>│   └── head.h==&gt; 头文件, 声明了加减乘除四个函数<br>├── main.c==&gt; 测试程序, 调用了head.h中的函数<br>└── src<br>    ├── add.c==&gt; 加法运算<br>    ├── div.c==&gt; 除法运算<br>    ├── mult.c  ==&gt; 乘法运算<br>    └── sub.c   ==&gt; 减法运算<br><br><br><span class="hljs-comment"># 最终的目标名 app</span><br>target = app<br><span class="hljs-comment"># 搜索当前项目目录下的源文件</span><br>src=<span class="hljs-variable">$</span>(wildcard *.c ./src/*.c)<br><span class="hljs-comment"># 将文件的后缀替换掉 .c -&gt; .o</span><br>obj=<span class="hljs-variable">$</span>(patsubst %.c, %.o, <span class="hljs-variable">$</span>(src))<br><span class="hljs-comment"># 头文件目录</span><br>include=./include<br><br><span class="hljs-comment"># 第一条规则</span><br><span class="hljs-comment"># 依赖中都是 xx.o yy.o zz.o</span><br><span class="hljs-comment"># gcc命令执行的是链接操作</span><br><span class="hljs-variable">$</span>(target):<span class="hljs-variable">$</span>(obj)<br>        gcc <span class="hljs-variable">$</span>^ <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span><br><br><span class="hljs-comment"># 模式匹配规则</span><br><span class="hljs-comment"># 执行汇编操作, 前两步: 预处理, 编译是自动完成</span><br>%.o:%.c<br>        gcc <span class="hljs-variable">$</span>&lt; <span class="hljs-literal">-c</span> <span class="hljs-literal">-I</span> <span class="hljs-variable">$</span>(include) <span class="hljs-literal">-o</span> <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span><br><br><span class="hljs-comment"># 添加一个清除文件的规则</span><br>.PHONY:clean<br><br>clean:<br>        <span class="hljs-literal">-rm</span> <span class="hljs-variable">$</span>(obj) <span class="hljs-variable">$</span>(target) <span class="hljs-operator">-f</span><br><br></code></pre></td></tr></table></figure><hr><p>参考列表：</p><p><a href="https://blog.csdn.net/haoel/article/details/2886">https://blog.csdn.net/haoel/article/details/2886</a><br><a href="https://subingwen.cn/">https://subingwen.cn/</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习二(GCC/静态库动态库)</title>
    <link href="/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%BA%8C(GCC%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93)/"/>
    <url>/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%BA%8C(GCC%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习二-GCC-静态库动态库"><a href="#Linux学习二-GCC-静态库动态库" class="headerlink" title="Linux学习二 : GCC&#x2F;静态库动态库"></a>Linux学习二 : GCC&#x2F;静态库动态库</h1><h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><p><code>GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写，包含 gcc、g++ 等编译器。</code><br>代码变成可执行程序的四步：预编译，编译，汇编，链接。<br>假设已经编写好name.c源文件。</p><blockquote><p>预编译：主要进行三件事：展开头文件，宏替换，去掉注释行。<strong>得到.i文件</strong>。使用到的参数为-E<br>gcc -E name.c -o name.i</p></blockquote><blockquote><p>编译：编译器的对文件进行编译，得到汇编文件。<strong>得到.s文件</strong>。使用到的参数为-S<br>gcc -S name.i -o name.s</p></blockquote><blockquote><p>汇编：对汇编文件进行进行汇编，会生成相应的二进制目标文件，<strong>得到.o文件</strong>。使用到的参数为 -c<br>gcc -c name.s -o name.o</p></blockquote><blockquote><p>链接：调用链接器对程序需要调用的库进行链接, 最终得到一个可执行的二进制文件。<strong>还是.o文件</strong>。不需要参数<br>gcc name.o -o name.exe</p></blockquote><p>一步完成：gcc name.c -o name.exe<br><code>-o 是为了指定生成的文件名</code></p><p><code>-I 可以重新指定头文件路径</code></p><blockquote><p>gcc name.c -o name.exe -I&#x2F;testhead #将头文件路径指定到&#x2F;testhead下</p></blockquote><p><code>多文件编译</code></p><blockquote><p>gcc -o name name.c main.c</p></blockquote><p><code>GCC和G++的主要区别</code></p><blockquote><ol><li>对于 .c和.cpp文件，gcc分别当做c和cpp文件编译，g++则统一当做cpp文件编译</li><li>使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL</li><li>gcc在编译C文件时，可使用的预定义宏是比较少的</li></ol></blockquote><h1 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h1><blockquote><p>使用库：一般有两个目的，一个是为了使程序更加简洁不需要在项目中维护太多的源文件，另一方面是为了源代码保密。当我们拿到了库文件（动态库、静态库）之后要想使用还必须有这些库中提供的API函数的声明，也就是头文件，把这些都添加到项目中。</p></blockquote><p><img src="https://pic.imgdb.cn/item/66040d9f9f345e8d03b44600.png" alt="在这里插入图片描述"></p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><blockquote><p>静态库：<strong>在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中</strong>。因此对应的链接方式称为<strong>静态链接</strong>。静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o&#x2F;.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。</p><ol><li>静态库对函数库的链接是放在编译时期完成的。</li><li>程序在运行时与函数库再无瓜葛，移植方便。（这里的移植方便指的是.exe移植方便）</li><li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li></ol></blockquote><p>创建静态库的过程：Linux下使用ar工具、Windows下vs使用lib.exe，将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。<br><img src="https://pic.imgdb.cn/item/66040dd99f345e8d03b61e53.png" alt="在这里插入图片描述"><br><code>生成静态库：</code>先对源文件进行汇编操作 (使用参数 -c) 得到二进制格式的目标文件 (.o 格式), 然后在通过 ar工具将目标文件打包就可以得到静态库文件。</p><ol><li>创建需要链接的头文件和.cpp文件。</li><li>对.cpp文件进行汇编，得到.o文件。<strong>注意带参数-c</strong>，否则直接编译为可执行文件。</li><li>通过ar工具将目标文件打包成.a静态库文件：Linux静态库命名规范，必须是”lib[your_library_name].a”：lib为前缀，中间是静态库名，扩展名为.a。<blockquote><p>ar工具的三个参数</p><ol><li>c：创建一个库</li><li>s：创建目标索引，能加快库的创建事件</li><li>r：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。</li></ol></blockquote></li><li>使用静态库：将.a库文件和对应的头文件给使用者，得到静态库进行调用的时候，调用程序编译的时候：<blockquote><p><code>-L: 指定库所在的目录(相对或者绝对路径)</code><br><code>-l: (小写L) 指定库的名字, 掐头(lib)去尾(.a) </code><br><img src="https://pic.imgdb.cn/item/66040dec9f345e8d03b6c9c2.png" alt="在这里插入图片描述"></p></blockquote></li></ol><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p><strong>静态库已经可以代码复用，为什么还要用动态库？</strong></p><ol><li>空间浪费，会存在多份拷贝，如果有多个程序需要调用该链接文件的话。</li><li>静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户，可能是一个很小的改动，却导致整个程序重新下载，全部更新。</li></ol><blockquote><p><code>动态库：</code></p><ol><li>动态库在程序编译时并不会被连接到目标代码中，而是<strong>在程序运行时才被载入</strong>。</li><li>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。可以实现进程之间的资源共享。</li><li>动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</li></ol></blockquote><p>Window与Linux执行文件格式不同，在创建动态库的时候有一些差异。</p><ul><li>在Windows系统下的执行文件格式是PE格式，动态库需要一个DllMain函数做出初始化的入口，通常在导出函数的声明时需要有_declspec(dllexport)关键字。</li><li>Linux下gcc编译的执行文件默认是ELF格式，不需要初始化入口，亦不需要函数做特别的声明，编写比较方便。</li></ul><p>与创建静态库不同的是，不需要打包工具（ar、lib.exe），直接使用编译器即可创建动态库。</p><p>动态库的命名规则：<br>在Linux中动态库以lib作为前缀, 以.so作为后缀, 中间是库的名字自己指定即可, 即: libxxx.so<br>在Windows中动态库一般以lib作为前缀, 以dll作为后缀, 中间是库的名字需要自己指定, 即: libxxx.dll</p><blockquote><p>生成动态库:</p><ol><li>生成目标文件，此时要加编译器选项-fpic，使得 gcc 生成的代码是与位置无关的，也就是使用相对位置。</li><li>生成动态库，此时要加链接器选项-shared，告诉编译器生成一个动态链接库。两步可以合为一步。<br>g++ -fPIC -shared -o libdynmath.so DynamicMath.cpp</li><li>使用库的时候，在编译的时候需要指定库相关的信息: 库的路径 -L和 库的名字 -l（小写L）。<img src="https://pic.imgdb.cn/item/66040dfc9f345e8d03b75cfe.png" alt="在这里插入图片描述"></li><li>直接使用无法加载动态库：需要解决动态库无法加载问题。</li></ol></blockquote><p>静态库的加载：链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。</p><p><strong>动态库的加载</strong>：</p><ul><li>虽然指定了库路径(使用参数 -L ), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。</li><li>同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。</li><li>可执行程序被执行起来之后:<ul><li>程序执行的时候会先检测需要的动态库是否可以被加载，加载不到就会提示上边的错误信息</li><li>当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载</li><li>动态库的检测和内存加载操作都是由<strong>动态链接器</strong>来完成的。</li></ul></li></ul><p>动态链接器检索动态库的顺序：</p><ol><li>可执行文件内部的 DT_RPATH 段</li><li>系统的环境变量 LD_LIBRARY_PATH</li><li>系统动态库的缓存文件 &#x2F;etc&#x2F;ld.so.cache</li><li>存储动态库&#x2F;静态库的系统目录 &#x2F;lib&#x2F;, &#x2F;usr&#x2F;lib等</li></ol><p><strong><code>为了让动态链接器找到动态库：三个方法</code></strong></p><p>方案1: 将库路径添加到环境变量 LD_LIBRARY_PATH 中，找到相关的配置文件</p><ul><li>用户级别: ~&#x2F;.bashrc —&gt; 设置对当前用户有效</li><li>系统级别: &#x2F;etc&#x2F;profile —&gt; 设置对所有用户有效<br>添加配置路径：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">export LD_LIBRARY_PATH =<span class="hljs-variable">$LD_LIBRARY_PATH</span> :动态库的绝对路径<br></code></pre></td></tr></table></figure><p>方案2: 更新 &#x2F;etc&#x2F;ld.so.cache 文件</p><ul><li>找到动态库所在的绝对路径（不包括库的名字）比如：&#x2F;home&#x2F;robin&#x2F;Library&#x2F;。</li><li>修改 &#x2F;etc&#x2F;ld.so.conf 这个文件，添加上面的语句。</li><li>更新 &#x2F;etc&#x2F;ld.so.conf中的数据到 &#x2F;etc&#x2F;ld.so.cache 中</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 必须使用管理员权限执行这个命令</span><br><span class="hljs-variable">$</span> sudo ldconfig   <br></code></pre></td></tr></table></figure><p>方案3: 拷贝动态库文件到系统库目录 &#x2F;lib&#x2F; 或者 &#x2F;usr&#x2F;lib 中 (或者将库的软链接文件放进去)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 库拷贝</span><br>sudo <span class="hljs-built_in">cp</span> /xxx/xxx/libxxx.so /usr/lib<br><br><span class="hljs-comment"># 创建软连接</span><br>sudo ln <span class="hljs-literal">-s</span> /xxx/xxx/libxxx.so /usr/lib/libxxx.so<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/66040e189f345e8d03b86470.png" alt="在这里插入图片描述"><br>动态库与静态库的优缺点：<br>静态库：<br>*静态库被打包到应用程序中加载速度快。<br>*发布程序无需提供静态库，移植方便。<br>*相同的库文件数据可能在内存中被加载多份, 消耗系统资源，浪费内存。<br>*库文件更新需要重新编译项目文件, 生成新的可执行程序, 浪费时间。</p><p>动态库：</p><ul><li>可实现不同进程间的资源共享</li><li>动态库升级简单, 只需要替换库文件, 无需重新编译应用程序。</li><li>程序猿可以控制何时加载动态库, 不调用库函数动态库不会被加载。</li><li>加载速度比静态库慢, 以现在计算机的性能可以忽略。</li><li><strong>发布程序需要提供依赖的动态库</strong>。</li></ul><p>参考列表：</p><ol><li><a href="https://www.cnblogs.com/skynet/p/3372855.html%EF%BC%9A">https://www.cnblogs.com/skynet/p/3372855.html：</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习一(基础知识与命令)</title>
    <link href="/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%B8%80(%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%91%BD%E4%BB%A4)/"/>
    <url>/2024/03/26/Linux%E5%AD%A6%E4%B9%A0%E4%B8%80(%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%91%BD%E4%BB%A4)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习一-基础知识与命令"><a href="#Linux学习一-基础知识与命令" class="headerlink" title="Linux学习一 : 基础知识与命令"></a>Linux学习一 : 基础知识与命令</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><code>Linux基础知识</code></p><blockquote><p>Linux是一个基于文件的操作系统。<br>操作系统需要和硬件进行交互, 对应Linux来说这些硬件都是文件，比如: 操作系统会将 硬盘, 鼠标, 键盘, 显示屏等抽象成一个设备文件来进行管理。</p></blockquote><blockquote><p>Linux内核：<br>Linux有用户态和内核态两个空间，内核空间是linux的主要部分。Linux内核的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。</p></blockquote><blockquote><p><strong>系统调用接口</strong>：system call Interface：SCI层提供了某些机制执行从用户空间到内核的函数调用。<br><strong>进程管理</strong>：指的是系统对进程的多种状态之间转换的策略。Linux 下的进程调度有 3 种策略：</p><ol><li>SCHED_OTHER（分时调度策略（默认），是用于针对普通进程的时间片轮转调度策略。）</li><li>SCHED_FIFO（实时调度策略，是针对运行的实时性要求比较高、运行时间短的进程调度策略）</li><li>SCHED_RR（实时调度策略，是针对实时性要求比较高、运行时间比较长的进程调度策略。）</li></ol></blockquote><p><strong>内存管理</strong>：</p><ul><li>内存管理是多个进程间的内存共享策略。</li><li>在Linux中，内存管理主要说的是虚拟内存。虚拟内存可以让进程拥有比实际物理内存更大的内存，可以是实际内存的很多倍。</li><li>每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。</li><li>Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。</li><li>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。</li></ul><p><strong>虚拟文件系统</strong>：虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。在 Linux 下支持多种文件系统，如 ext、ext2、minix、umsdos、msdos、vfat、ntfs、proc、smb、ncp、iso9660、sysv、hpfs、affs 等。目前 Linux 下最常用的文件格式是 ext2 和 ext3。</p><p><strong>网络堆栈</strong>：网络堆栈在设计上遵循模拟协议本身的分层体系结构。</p><ul><li>Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。</li><li>TCP 上面是 socket 层，它是通过 SCI 进行调用的。</li><li>socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。</li><li>从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。</li></ul><p><strong>设备驱动程序</strong>：Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。</p><p>**<code>进程间通信</code>**：Linux 操作系统支持多进程，进程之间需要进行数据的交流才能完成控制、协同工作等功能，Linux 的进程间通信是从 UNIX 系统继承过来的。Linux 下的进程间的通信方式主要有管道、信号、消息队列、共享内存和套接字等方法。</p><p><code>命令解析器</code></p><blockquote><p>bash : 命令解析器需要依次搜索 PATH中的各个目录, 检查这些目录中是否有用户输入的指令。找不到的时候输出command not found。<br>有普通用户和root用户的区分。<br><strong>Tab键补全命令</strong>，由于很定shell命令的开头字母是相同的, 在这种情况下, 按一次Tab是不会自动补齐的，我们可以<strong>连续按两次Tab键，在当前终端中就可以显示出所有匹配成功的shell命令</strong>。</p></blockquote><h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><blockquote><p>cd ：切换工作目录<br>ls：显示文件 ls -a 还可以显示隐藏文件， ls -l 显示详细信息，主要看文件时间和权限。rwx：读&#x2F;写&#x2F;执行<br>创建目录:mkdir<br>删除目录：rmdir<br>rm可以删除文件，也可以删除目录，rm -r 递归删除 -f强制删除文件， rm -rf 可以强制删除文件或目录。<br>cp：拷贝<br>mv：移动文件： 移动文件到上一级：mv file ..&#x2F;<br>cat：查看文件内容<br>more：可以用翻屏的方式查看内容，比cat高级一点。<br>head：查看文件头部的若干信息<br>tail：查看文件尾部的若干信息。<br>链接分两种类型: 软连接和硬链接。软连接相当于windows中的快捷方式，硬链接文件并不会进行拷贝，只是多出一个新的文件名并且硬链接计数会加1。<br>chmod：修改文件权限，用的也挺多的，.sh文件刚建立的时候不能直接运行，需要添加chmod +x run.sh，加上执行权限。<br>chown：修改文件所有者，基本没用过<br>tree：显示树状目录<br>pwd：pwd命令用户当前所在的工作目录, 没有参数, 直接执行该命令即可<br>touch：创建新的空文件。<br>which命令可以查看要执行的命令所在的实际路径, 命令解析器工作的时候也会搜索这个目录。<br> 可以用输出输入重定向进行文件内容的输入和输出。</p></blockquote><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><p>linux是多用户系统，有的时候需要进行用户切换，用su或者su-。su只切换用户, 当前的工作目录不会变化, 但是使用 su -不仅会切换用户也会切换工作目录, 工作目录切换为当前用户的家目录。</p><blockquote><p>添加新用户需要使用adduser&#x2F;useradd命令来完成。<br>userdle命令才能删除用户在系统中的用户ID和所属组ID等相关信息，但是需要注意的是在某些Linux版本中用户虽然被删除了， 但是它的家目录却没有被删除，需要我们手动将其删除。<br>groupadd添加用户组, 使用 groupdel删除用户组。<br>passwd 修改密码</p></blockquote><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><blockquote><p>tar 涉及参数：<br>c：创建压缩文件<br>z: 使用gzip的方式进行文件压缩<br>j: 使用bzip2的方式进行文件压缩<br>v: 压缩过程中显示压缩信息, 可以省略不写<br>f: 指定压缩包的名字<br><img src="https://pic.imgdb.cn/item/66040ff79f345e8d03ca2abf.png" alt="在这里插入图片描述"></p></blockquote><p>解压缩</p><blockquote><p>怎么压缩就怎么解压缩，只不过c换成x<br>后缀多加上 -C文件名，可以将文件解压到指定的文件夹下。<br><img src="https://pic.imgdb.cn/item/660410039f345e8d03caa747.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>zip需要自己安装，挺好用，用的时候搜一下。</p></blockquote><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><blockquote><p>find：根据文件的属性, 查找对应的磁盘文件。<br>find模糊查询的时候，用到两个符号，*和?，  *可以匹配多个字符，?匹配单个字符。<br>find 搜索路径 - type 文件类型，可以指定文件类型进行搜索。<br>find 搜索的路径 -size [+|-]文件大小 ，可以指定文件大小进行搜索。<br>-maxdepth: 最多搜索到第多少层目录<br>-mindepth: 至少从第多少层开始搜索<br>可以同时执行多个操作、<br>-<strong>exec 是find的参数, 可以在exec参数后添加其他需要被执行的shell命令</strong>。find 添加了 exec 参数之后, 命令的尾部需要加一个后缀 {} ;, 注意 {}和\之间需要有一个空格。<br>find 路径 参数 参数值 -exec shell命令2 {} \ ;<br><strong>在find 中 使用 xargs 关键字我们就可以使用管道</strong>。<br><img src="https://pic.imgdb.cn/item/660410119f345e8d03cb2abb.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>grep 命令用于查找文件里符合条件的字符串。<br>-r: 如果需要搜索目录中的文件内容, 需要进行递归操作, 必须指定该参数<br>-i: 对应要搜索的关键字, <strong>忽略字符大小写的差别</strong>.<br>-n: 在显示符合样式的那一行之前，标示出该行的列数编号<br><img src="https://pic.imgdb.cn/item/6604101f9f345e8d03cbad26.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>locate：简化版的find, 使用这个命令我们可以根据文件名搜索本地的磁盘文件, 但是locate的效率比find要高很多。原因在于它不搜索具体目录，而是搜索一个本地的数据库文件，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer学习二</title>
    <link href="/2024/03/26/C++%20Primer%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <url>/2024/03/26/C++%20Primer%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer学习二"><a href="#C-Primer学习二" class="headerlink" title="C++ Primer学习二"></a>C++ Primer学习二</h1><h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><blockquote><p>rule of three：定义了其中一个，剩下的几个都要定义</p><ol><li>copy constructor</li><li>copy assign operator </li><li>destructor</li></ol></blockquote><blockquote><p>rule of five：定义了其中一个，剩下的几个都要定义</p><ol><li>copy constructor</li><li>copy assign operator </li><li>destructor</li><li>move constructor</li><li>move assign operator</li></ol></blockquote><p><code>深拷贝与浅拷贝</code><br>    a. 浅拷贝：简单的赋值拷贝操作。浅拷贝带来的问题就是堆区的内存重复释放。要利用深拷贝解决。<br>    b. 深拷贝：在堆区重新申请空间，进行拷贝操作。<br><img src="https://pic.imgdb.cn/item/66040c7b9f345e8d03aa2fa0.png" alt="在这里插入图片描述"><br><code>编译器会默认生成拷贝构造函数，但是如果类里面有动态申请的内存空间，那么一定要自定义拷贝构造函数，用深拷贝去解决浅拷贝带来的问题，并且拷贝构造函数/类中重载赋值运算符一定要使用索引，因为不用索引的话，去调用对象的时候会首先调用一次拷贝构造，造成死循环</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">类似实现一种资源管理的方式，应该从哪里考虑：<br>构造函数初始化，拷贝构造++，析构函数--，如果减到<span class="hljs-number">0</span>，直接<span class="hljs-keyword">delete</span>掉。<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* resource_;<br>    <span class="hljs-type">size_t</span>* count_;<br><br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> resource):<span class="hljs-built_in">resource_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> (resource))&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;in constructor&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">this</span>-&gt;count_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp; foo)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;resource_ = foo.resource_;<br>        <span class="hljs-keyword">this</span>-&gt;count_ = foo.count_;<br>        *(<span class="hljs-keyword">this</span>-&gt;count_)+=<span class="hljs-number">1</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;update this-&gt;count &quot;</span> &lt;&lt;*(<span class="hljs-keyword">this</span>-&gt;count_)&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Foo</span>()&#123;<br>        *(<span class="hljs-keyword">this</span>-&gt;count_) -=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(*(<span class="hljs-keyword">this</span>-&gt;count_)  ==<span class="hljs-number">0</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;do destructor&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;count_;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;resource_;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">foo1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">Foo <span class="hljs-title">foo2</span><span class="hljs-params">(foo1)</span></span>;<br>    <span class="hljs-function">Foo <span class="hljs-title">foo3</span><span class="hljs-params">(foo2)</span></span>;<br>    <span class="hljs-function">Foo <span class="hljs-title">foo4</span><span class="hljs-params">(foo3)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;how many count &quot;</span> &lt;&lt;*(foo2.count_)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出结果<br>in constructor<br>update <span class="hljs-keyword">this</span>-&gt;count <span class="hljs-number">2</span><br>update <span class="hljs-keyword">this</span>-&gt;count <span class="hljs-number">3</span><br>update <span class="hljs-keyword">this</span>-&gt;count <span class="hljs-number">4</span><br>how many count <span class="hljs-number">4</span><br><span class="hljs-keyword">do</span> destructor<br><br></code></pre></td></tr></table></figure><p><code>移动构造</code></p><ol><li>右值：右值可以偷过来<br> a. 容易消失，没有名字，不可修改。<br> b. 没有其他的人在使用。</li><li>如果有移动构造，移动来源的资源一定要释放掉。</li></ol><blockquote><p>运算符重载<br> a. + - &#x2F; * 运算符重载：定义新的运算规则<br>    b. 左移运算符重载：定义输出方式，一定要定义成友元函数，没法用隐式转换<br>    c. 递增运算符重载：实现自己的数据类型。<br>    d. 赋值运算符重载：进行赋值，注意深浅拷贝。重载赋值符号，也是放置浅拷贝的重要一项。<br>    e. 关系运算符重载：让两个自定义对象进行对比操作。<br>    f. 函数调用重载：仿函数，定义类似函数的行为，比较自由。</p></blockquote><p><code>拷贝构造函数和拷贝赋值运算符的调用时机：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">namespace</span> _nmp2_2&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">A</span>():<span class="hljs-built_in">m_caa</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">m_cab</span>(<span class="hljs-number">0</span>)&#123;&#125;; <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; tmp)&#123; <span class="hljs-comment">// 拷贝构造</span><br>            <span class="hljs-keyword">this</span>-&gt;m_caa = tmp.m_caa;<br>            <span class="hljs-keyword">this</span>-&gt;m_cab = tmp.m_cab;<br>        &#125;<br>        A&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> A&amp; tmp)&#123; <span class="hljs-comment">//拷贝赋值运算符</span><br>            m_caa = tmp.m_caa;<br>            m_cab = tmp.m_cab;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> m_caa;<br>        <span class="hljs-type">int</span> m_cab;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    _nmp2_2::A oba;<br>    oba.m_caa = <span class="hljs-number">10</span>;<br>    oba.m_cab = <span class="hljs-number">20</span>;<br>    _nmp2_2::A obb = oba;<span class="hljs-comment">// 拷贝构造</span><br>    obb = oba; <span class="hljs-comment">// 拷贝赋值运算符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类和类之间的关系一般就是继承关系，或者是组合关系。</li><li>委托关系：一个类中包含指向另一个类的指针。</li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol><li>运行时多态：虚函数+动态绑定：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string ISBN;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Book&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComicBook</span> : <span class="hljs-keyword">public</span> Book&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Comic Book&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActionBook</span> : <span class="hljs-keyword">public</span> Book&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Action Book&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ComicBook cb;<br>    ActionBook ac;<br>    Book* b1 = (Book*) &amp;cb;<br>    Book&amp; b2 = ac;<br>    b1-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// cout Comic Book</span><br>    b2.<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// cout Action Book</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>派生类构造的时候，要先构造基类的东西。</p></li><li><p>派生类析构的时候，先析构自己的东西，再析构基类的东西。</p></li><li><p>vtable：找到子类函数的关键。</p><blockquote><p>静态成员：静态变量和静态成员函数，加static关键字：<br> a. 静态成员变量：<br>    i. 所有对象共享同一份数据<br> ii. 在编译阶段分配内存，不和类对象在同一个存储空间上，只有非静态成员变量才属于类的对象上<br> iii. 类内声明，类外初始化。<br> b. 静态函数：<br> i. 所有对象共享同一个函数。<br> ii. 静态成员函数只能访问静态成员变量。</p></blockquote></li><li><p>纯虚函数不能实例化对象。</p></li><li><p>如何让抽象类不能生成对象？</p></li></ol><ul><li>构造函数和拷贝构造函数都用protected修饰。</li><li></li></ul><ol start="8"><li><strong>protect和private的区别</strong>：子类中不可访问父类中的private的属性和函数，但可以访问protect的。</li><li>C++中struct和类的唯一区别就是权限不同，struct默认public，public继承，class 默认private，private继承。</li><li>基类的析构函数，一般加上virtual，让派生类释放自己的，基类释放自己的，每个类做好自己的事情，派生类不要管基类的释放。</li><li>容器中存放类对象：如果vector&lt; Base &gt; vc 中push_back一个派生类，那么派生类相对于基类多出来的部分，会被砍掉。但是如果说把类型换换，vector&lt; Base* &gt; vc2, vc2中插入一个派生类指针，根据多态性，可以访问到多出来的那部分。</li></ol><ul><li><code>如果类中包含静态成员变量，无论这个静态成员变量是否使用，都会给这个静态成员变量分配内存。</code></li><li><code>全局对象的初始化顺序是不固定的</code></li><li>做父类应该有个虚析构函数。</li><li><code>对于不允许进行拷贝构造或者拷贝赋值运算符的函数：用=delete或者定义为private函数。</code></li></ul><h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><ol><li>C++除了面向对象编程思想之外，还有泛型编程思想，主要利用的技术就是模板。</li><li>面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况，不同之处在于，<strong>面向对象编程能够处理在程序运行之前都都未知的情况，而泛型编程，在编译时就能获知类型</strong>。</li><li><strong>模板的声明和定义要都放在.h中</strong>：编译器看到模板不会生成代码，一定要实例化一个模板的一个特定版本的时候，编译器才会生成代码，为了生成一个实例化版本，模板的头文件中要包含模板的定义和声明。</li><li>函数模板：建立一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表。<br><img src="https://pic.imgdb.cn/item/66040ca19f345e8d03ab8231.png" alt="在这里插入图片描述"></li><li>类模板：建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。类模板在初始化的时候一定要显式的表明是什么类型的。<br><img src="https://pic.imgdb.cn/item/66040cba9f345e8d03ac62e8.png" alt="在这里插入图片描述"><br>在类内，声明T之后，就不用再用T再次声明，但是在类外，但凡要用到A类，就要表明T的类型。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    T a;<br>    <br>    <span class="hljs-function">A&amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-function">A&amp; <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>A&lt;T&gt;&amp; A&lt;T&gt;::<span class="hljs-built_in">func2</span>()&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;hello world 2&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于类模板中的静态数据，每个类型共享一个，而不是所有的共享一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> A&lt;T&gt;::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A&lt;<span class="hljs-type">int</span>&gt; a1;<br>    a1.count+=<span class="hljs-number">1</span>;<br>    A&lt;<span class="hljs-type">long</span>&gt; a2;<br>    a2.count+=<span class="hljs-number">10</span>;<br><br>    cout&lt;&lt;A&lt;<span class="hljs-type">int</span>&gt;::count&lt;&lt;endl; <span class="hljs-comment">// 1</span><br>    cout&lt;&lt;A&lt;<span class="hljs-type">long</span>&gt;::count&lt;&lt;endl; <span class="hljs-comment">// 10</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>普通类中包含模板函数 …</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugDelete</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(T*p)</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;delete it&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">10</span>);<br>    DebugDelete d;<br>    <span class="hljs-built_in">d</span>(p);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>一个类型推断的小例子</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> It&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(It begin, It end)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(*begin)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> *begin;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li><strong>虽然不能直接将一个右值引用绑定到到一个左值上，但可以用move获得一个绑定到左值上的右值引用</strong>。std::move不会创建新的对象，仅仅是类型转换，但是std::move会影响到编译器函数重载的匹配。  std::move(a) &#x3D;&#x3D; static_cast&lt; A&amp;&amp;&gt;(a);</li><li>左值常引用相当于万能型：可以用左值或者右值进行初始化。</li><li>改成const &amp;，可以省去参数的拷贝，一定要用const &amp;，多用，好用。</li><li>完美转发 &#x3D; 引用折叠 + 万能引用 + std::forward。</li><li><strong>想保留左值右值属性的时候</strong>，用std::forward。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FUNC, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(FUNC func, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span>&#123;<br>    <span class="hljs-built_in">func</span>(t2,t1); <span class="hljs-comment">// t2 t1 都是左值，并且不能将左值调用到右值的函数里面，所以要用完美转发</span><br>    <span class="hljs-built_in">func</span>(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span>&amp; v2)</span></span>&#123;<br>    cout&lt;&lt;v1 &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;++v2&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// FUNC-&gt;f</span><br>    <span class="hljs-comment">// t1-&gt;int</span><br>    <span class="hljs-comment">// t2-&gt;int</span><br>    <span class="hljs-comment">// 左值传到右值里面相当于一个引用</span><br>    <span class="hljs-built_in">flip</span>(f,i,<span class="hljs-number">42</span>);<br>    cout&lt;&lt;i&lt;&lt;endl; <span class="hljs-comment">//11</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="12"><li>模板重载的时候，会按照匹配度去调用。 非模板匹配的好的，就会调用非函数模板。</li><li>可变参数模板：当参数个数未知，类型未知，一定要用模板，有点类似递归，要有一个最终的出口。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//出口</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; os, <span class="hljs-type">const</span> T&amp; t)</span></span>&#123;<br>    os&lt;&lt;t&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; os, <span class="hljs-type">const</span> T&amp; t, Args... args)</span></span>&#123;<br>    os&lt;&lt;t&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">print</span>(os,args...);<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">print</span>(cout,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">3L</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="14"><li>命名空间：减少命名冲突。</li><li>头文件当中禁止使用using，cpp文件中放到匿名命名空间中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer学习一</title>
    <link href="/2024/03/25/C++%20Primer%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <url>/2024/03/25/C++%20Primer%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer学习一"><a href="#C-Primer学习一" class="headerlink" title="C++ Primer学习一"></a>C++ Primer学习一</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote><p>main函数：程序入口。</p></blockquote><blockquote><p>复合类型 Compound Type：</p></blockquote><ul><li>引用 Reference<ul><li>绑定一个本地变量 bind to a local variable，是一个已经存在值的引用（一个应用：节约传参过程中的拷贝,节省程序运行时间，当对象很大，并且拷贝很多的时候，使用引用的价值就体现出来了）</li><li>不能绑定一个字面常量literal &#x2F; constant</li></ul></li><li>指针 Pointer<ul><li>指向想要改动数据的地址。</li></ul></li></ul><p><code>引用和指针一个很大的区别：引用要做初始化</code></p><blockquote><p>const </p></blockquote><ul><li>和Reference一样，一定要做初始化</li><li>not const -&gt; const 是可以的， 反之不行</li><li>普通指针不能指向常量数据。</li><li>top-level指针和low-level指针：从右往左读const，理解到底是顶层const还是底层const<blockquote><p>含有可变形参的函数 initializer_list<br>注意参数是constant</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// begin/end (initializer_list)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>          <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span>  <span class="hljs-comment">// std::initializer_list</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">print_list</span> <span class="hljs-params">(std::initializer_list&lt;T&gt; il)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> T* it=<span class="hljs-built_in">begin</span>(il); it!=<span class="hljs-built_in">end</span>(il); ++it) <br>    std::cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; *it;<br>  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">print_list</span> (&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>assert 断言调试用的，可以用#define NDEBUG屏蔽掉。</p></blockquote><blockquote><p>初始化列表提升性能，初始化列表和委托构造函数的结合，表明初始化列表的速度较快</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SalesData</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a_;<br><span class="hljs-type">bool</span> b_;<br><span class="hljs-type">long</span> c_;<br><br><span class="hljs-comment">// constructor</span><br><span class="hljs-built_in">SalesData</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">bool</span> b, <span class="hljs-type">long</span> c) : <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(b), <span class="hljs-built_in">c_</span>(c) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;normal constructor&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 委托构造函数</span><br><span class="hljs-built_in">SalesData</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">bool</span> b) : <span class="hljs-built_in">SalesData</span>(a,b,<span class="hljs-number">100</span>)&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;delegate constructor&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br><span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br><span class="hljs-function">SalesData <span class="hljs-title">sales_data</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-comment">// normal constructor</span><br><span class="hljs-comment">// delegate constructor</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态成员变量，只能类内定义，类外进行初始化，因为静态成员变量不属于任何一个对象。</p></blockquote><p><code>连续容器</code></p><ul><li>vector和Array，99%的情况用vector。</li><li>list：双向链表</li><li>forward_list：单链表</li><li>deque 双端队列，头尾插入很快，支持快速访问。</li><li>string 字符串<blockquote><p>emplace_back()比push_back()少了一步拷贝，直接进行构造，插入速度稍微快一些。</p></blockquote></li></ul><p><code>迭代器是左闭右开区间，end()指向最后一个元素的下一位</code></p><p><code>容器操作可能会使迭代器失效</code></p><blockquote><p>添加元素，删除元素，扩容的时候可能会变化。<br>当我们使用迭代器的时候，尽可能减少迭代器使用范围。<br>多使用vec.begin()和vec.end()，及时的获取迭代器的开始和结束值，不要给他们赋值后使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it= vec.<span class="hljs-built_in">begin</span>();it!=vec.<span class="hljs-built_in">end</span>();it++)&#123;<br>        <span class="hljs-keyword">if</span>((*it) == <span class="hljs-number">2</span>)&#123;<br>            vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">100</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:vec)&#123;<br>        cout&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <br>    &#125;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> 为什么有两个<span class="hljs-number">100</span>？打印一些东西去看输出<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-string">&quot;at the beginning capacity &quot;</span>&lt;&lt;vec.<span class="hljs-built_in">capacity</span>() &lt;&lt;endl;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it= vec.<span class="hljs-built_in">begin</span>();it!=vec.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;============&quot;</span>&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;vec capacity&quot;</span>&lt;&lt;vec.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;<br>        cout&lt;&lt;*it&lt;&lt;endl;<br>        <span class="hljs-keyword">if</span>((*it) == <span class="hljs-number">2</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;push is happenning!&quot;</span>&lt;&lt;endl;<br>            vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">100</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:vec)&#123;<br>        cout&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <br>    &#125;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/b9cb633ca9d8407fad4d55b2fbb7afc0.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/a46709b516aa44e586029b7718c20faa.png" alt="在这里插入图片描述"><br><code>从上面的输出结果，和vector的扩容方式，以及迭代器指针失效的原因分析输出最后是两个100的情况：</code></p><blockquote><p>vector中容量增长的方式，2^n方式去扩容，虽然是n倍，但是移动n个元素，平摊到每个元素上，时间复杂度依然是O(1)。<br>*如果是vector&lt; int &gt; vec, 那么容器容量是0,1,2,4,8,16..增长<br>*如果是vector&lt; int &gt; vec &#x3D; { 1,2,3,4,5 }，那么容器增长的步骤是5,10,20..按照初始大小两倍增长<br>*fun()中的代码: 在插入之前，vec的大小为5，push的时候，会先找到新的地址去扩容到10，然后push100，出现的情况就是，申请到了新的地址，但是用的老的迭代器，迭代器会不断地往后走，走到最新的地址空间去，会再次从1开始遍历，遍历到2的时候，会再push一个100，这就是为什么出现两个100的原因。</p></blockquote><h2 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h2><ol><li>自己定义算法的比较器，注意比较的过程中怎么返回才能达到自己的效果：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WannaBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; i1, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; i2)</span></span>&#123;<br>    <span class="hljs-comment">// return true if you want i1 go first before i2</span><br>    <span class="hljs-keyword">return</span> i1 &gt; i2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-comment">// iterator optional-&gt;comparator</span><br>    <span class="hljs-comment">// std::sort(vec.begin(),vec.end(),std::less&lt;int&gt;());</span><br>    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),WannaBigger);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:vec)&#123;<br>        cout&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <br>    &#125;<br>    cout&lt;&lt;endl;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>lambda表达式：<blockquote><p>C++可以调用的四种方法：</p><ol><li>function 函数 ： void func();</li><li>function pointer：bool (*pfunc) (int a); pfunc(1);</li><li>class operator：类重载函数调用符</li><li>lambda表达式</li></ol></blockquote></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">lambda表达式的基本语法组成：<br>[OuterVar] 捕获变量，捕获外围变量,可以访问，甚至修改函数外部的变量，如果有引用符号，则可以按引用捕获，修改外部的值<br>如果写成了[&amp;]则代表封闭范围内的值，都按引用捕获，[=]代表都按值捕获<br>(var) 参数列表<br>-&gt; var 返回类型，返回类型是可以省略的 <br>&#123;&#125; 函数主体<br>[OuterVar](<span class="hljs-type">int</span> x ,<span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> OuterVar+x+y;<br>&#125;<br>和<br>[OuterVar](<span class="hljs-type">int</span> x ,<span class="hljs-type">int</span> y)&#123;<br><span class="hljs-keyword">return</span> OuterVar+x+y;<br>&#125;<br>是一样的<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sz = <span class="hljs-number">10</span>;<br>   <span class="hljs-keyword">auto</span> my_func = [&amp;]()&#123;<span class="hljs-keyword">return</span> sz;&#125;;<br>   cout &lt;&lt; <span class="hljs-built_in">my_func</span>() &lt;&lt;endl;<br></code></pre></td></tr></table></figure><ol start="3"><li>关联容器：<blockquote><p>map set mulitiset multimap 有序，底层是红黑树，带Multi的可以有重复键值<br> unordered_set unordered_map 无序  底层为哈希表<br> 注意map的用法 map[i]或者迭代器的 it-&gt;first 和 it-&gt;second<br> pair&lt;int ,int&gt; 很类似map中的节点<br> 如果是自定义类的map，要告诉map怎么进行比较排序。<br> 如果是自定义类的unordered_map，需要告诉unordered_map怎么hash</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a_;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a):<span class="hljs-built_in">a_</span>(a)&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WannaBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a1, <span class="hljs-type">const</span> A&amp; a2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a1.a_ &gt; a2.a_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">map&lt;A,<span class="hljs-type">int</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(WannaBigger)</span>*&gt; <span class="hljs-title">may_map</span><span class="hljs-params">(WannaBigger)</span></span>;<br>    may_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>),<span class="hljs-number">1</span>&#125;);<br>    may_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>),<span class="hljs-number">2</span>&#125;);<br>    may_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>),<span class="hljs-number">3</span>&#125;);<br>    may_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>),<span class="hljs-number">4</span>&#125;);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it= may_map.<span class="hljs-built_in">begin</span>();it!=may_map.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;it-&gt;second&lt;&lt;endl; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><ol><li>传统的new和delete申请释放内存的方法，如果new之后的内存没有delete释放，就会造成内存泄漏。</li><li>delete掉之后，一般也会将指针置空，这个指针，也就变成了悬空指针。c++11之后，用nullptr，相比于NULL，nullptr是类型安全的，因为在某些情况下，编译器会把NULL和int搞混。</li><li>智能指针：shared_ptr，unique_ptr，weak_ptr。 </li><li>shared_ptr：共享指针，一般用make_shared&lt; type &gt;去初始化一个shared_ptr。shared_ptr的动态管理内存方式，当指向某个物体的shared_ptr个数降为0的时候，这个物体就会自动销毁，智能指针通过这种方式去管理内存，以避免内存泄漏，shared_ptr的具体方法叫引用计数，数一数有多少个指针指向某个物体。</li><li>unique_ptr：一对一关系。C++14以后，可以用make_unique去新建一个独享指针。unique_ptr销毁的时候，其绑定的资源就会自动释放，不能普通拷贝，不能赋值给新的。只能用move去转移指针，但是没必要做吧。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_func</span><span class="hljs-params">()</span></span>&#123;<br>Object* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>p-&gt;<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 如果这一步出错，下面的p就不会释放，还是会出问题，出现内存泄漏。</span><br><span class="hljs-keyword">delete</span> p; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_func2</span><span class="hljs-params">()</span></span>&#123;<br>unique_ptr&lt;Object&gt; up &#123;<span class="hljs-built_in">make_unique</span>&lt;Object&gt;()&#125;;<br>up-&gt;<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">//即便抛出异常，资源最后也会释放。</span><br>&#125;<br><br></code></pre></td></tr></table></figure><code>在默认情况下，unique_ptr用new和delete去申请和释放内存，但是可以自定义释放函数，值得注意的一点是，unique_ptr在自定义释放函数的，时候需要在模板函数里面，需要说明自定义释放函数的类型，因为unique_ptr的绑定释放函数是在编译期，减少了运行时绑定的损耗，shared_ptr的释放函数在运行时绑定，用户使用起来更简单，引用计数已经有运行时消耗了，再增加一点也无所谓</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">my_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;v&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_dealloc</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span>&#123;<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 自定义申请和释放内存的方式</span><br>    unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(&amp;my_dealloc)&gt; cup&#123;<span class="hljs-built_in">my_alloc</span>(<span class="hljs-number">100</span>),my_dealloc&#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>weak_ptr：没有权利控制对象生命周期，不会影响shared_ptr的计数值。</li></ol>]]></content>
    
    
    <categories>
      
      <category>语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现简单的WebServer服务器</title>
    <link href="/2024/03/25/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2024/03/25/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言实现简单的WebServer服务器"><a href="#C语言实现简单的WebServer服务器" class="headerlink" title="C语言实现简单的WebServer服务器"></a>C语言实现简单的WebServer服务器</h1><hr><h2 id="基于TCP的套接字通信"><a href="#基于TCP的套接字通信" class="headerlink" title="基于TCP的套接字通信"></a>基于TCP的套接字通信</h2><p><img src="https://pic.imgdb.cn/item/66040cf99f345e8d03ae86f7.png" alt="在这里插入图片描述">          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个单线程流程，服务器创建用于监听的套接字，绑定本地的ip和端口，listen函数去监听绑定的端口。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有客户端进行连接，服务器端就可以和发起连接的客户端建立连接，连接建立成功会生成一个用于通信的套接字。<strong>用于监听的套接字和用于通信的套接字是不一样的</strong>。监听的套接字用于建立连接，通信的套接字用于数据交互。用于数据交互的read和write都是阻塞函数，在单线程下面，一个服务器想和多客户端进行通信，肯定是做不到的，因为accept，read，write都是阻塞的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使服务器可以正常的与多个客户端建立连接，并进行数据交互，需要用到多线程，多线程中的主线程负责建立连接（调用accept），子线程负责数据通信。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多线程切换有一定的开销，因此引入<strong>非阻塞 I&#x2F;O</strong>。非阻塞 I&#x2F;O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在一个线程里轮询多个文件描述符是否就绪。但是这种做法缺点是，<strong>每次发起系统调用，只能检查一个文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>IO多路复用</strong>，也就是select，poll，epoll，可以通过一次系统调用，检查多个文件描述符的状态，相比于非阻塞 I&#x2F;O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。在IO多路复用中，阻塞是由内核实现的，自己编写的代码可以少许多不必要的阻塞。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单线程下，只用IO多路复用，没办法同时处理两件事情，为了提高效率，一般采用多线程+IO多路复用的方法。</p><h2 id="单线程服务器流程"><a href="#单线程服务器流程" class="headerlink" title="单线程服务器流程"></a>单线程服务器流程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己编写的代码充当服务器，浏览器作为客户端的角色进行固定地址的访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>在终端输入 启动程序 端口 和 程序主目录。<br><span class="hljs-number">2.</span>启动监听套接字initListenFd(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)：<br>a)创建监听fd，采用IPv4，TCP协议<br>b)设置端口复用：如果程序服务器是主动断开连接的一方，会有一个<span class="hljs-number">2</span>msl的等待时长，为了确认客户端已经收到我断开确认ack<br>c)绑定IP和端口<br>d)设置监听<br>e)返回监听套接字lfd<br><span class="hljs-number">3.</span>启动服务器程序epollRun(<span class="hljs-type">int</span> lfd)：<br>a)创建epoll 树的根节点<br>b)lfd上树：上树用的是epoll_ctl函数<br>c)<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>不停地检测是否有事件到来，根据epoll_wait返回的数组中的fd文件描述符，判断事件是连接请求，还是数据通信请求：<br>i.如果是连接请求，调用acceptClient(lfd, epfd)，建立新的连接。<br>ii.如果是数据通信请求，调用recvHttpRequest(cfd, epfd)，以http协议的方式传递消息。<br><br>acceptClient(lfd, epfd)：<br><span class="hljs-number">1.</span>建立连接，调用accept函数。<br><span class="hljs-number">2.</span>设置非阻塞模式，非阻塞说的是文件描述符，默认得到的cfd是阻塞的，用fcntl修改文件描述符的属性。<br><span class="hljs-number">3.</span>cfd添加到epoll中，设置边沿触发方式。<br><br><br>recvHttpRequest(cfd, epfd)：<br><span class="hljs-number">1.</span>读取客户端发送过来的http请求头：<br><span class="hljs-number">2.</span>判断数据是否被接收完毕：<br>a)<span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span> &amp;&amp; errno == EAGAIN)：证明有数据<br>解析请求行：parseRequestLine(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* line, <span class="hljs-type">int</span> cfd)：<br>i.<span class="hljs-built_in">sscanf</span>拆分字符串，得到请求方法和请求路径，仅处理get请求：<br>ii.对请求路径中的中文进行处理，否则会乱码<br>iii. 判断文件路径是指向目录，还是文件，或者文件不存在：<br><span class="hljs-number">1.</span>若文件路径不存在，发送<span class="hljs-number">404.</span>html<br><span class="hljs-number">2.</span>若文件路径是目录，则发送html的头部，然后发送格式化的目录列表，也是符合html格式。<br><span class="hljs-number">3.</span>若文件路径指向具体文件，则分析文件类型，然后发送具体文件。<br>由于通信的文件描述符是非阻塞的，用sendfile发送文件的时候要处理返回值，<br>不断根据偏移量去发送文件，直到文件发送完毕，否则大文件的传输会出现问题。<br>cfd去读取发送数据内存的时候，是非阻塞的，读数据块速度很快，读到文件末尾偏移量之后，再进行<span class="hljs-keyword">while</span>循环读取的时候<br>ret返回值为<span class="hljs-number">-1</span>，errno == EAGAIN代表没有数据，可以再次进行尝试。<br><br><span class="hljs-type">off_t</span> offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br>lseek(fd, <span class="hljs-number">0</span>, SEEK_SET);<br><span class="hljs-keyword">while</span> (offset &lt; size) <span class="hljs-comment">// 如果偏移量小于size，则表示文件没有发送完，继续发送</span><br>&#123;<br><span class="hljs-comment">// 通信的文件描述符是非阻塞的</span><br><span class="hljs-type">int</span> ret = sendfile(cfd, fd, &amp;offset, size - offset);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret value: %d\n&quot;</span>, ret);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span> &amp;&amp; errno == EAGAIN) <span class="hljs-comment">// EAGAIN的意思是没有数据，可以再次进行尝试</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没数据...\n&quot;</span>); <br>&#125;<br>&#125;<br>close(fd);<br>b)否则说明客户端断开了连接，要及时的将cfd下树,并且关闭对应文件描述符<br><br></code></pre></td></tr></table></figure><h2 id="多线程服务流程"><a href="#多线程服务流程" class="headerlink" title="多线程服务流程"></a>多线程服务流程</h2><blockquote><p>单线程的服务器模型中，主程序会不断阻塞的进行连接和数据通信两项工作，两项工作和主线程不独立，当连接请求比较多的时候，效率相对较低。<br>多线程的处理方法：在建立连接 acceptClient(lfd, epfd) 和 数据通信模块 recvHttpRequest(cfd, epfd)两部分，都开辟新的线程去做，让子线程去处理动作。<br>注意要在项目的输入，库依赖项中输入pthread，否则linux链接的时候找不到。</p></blockquote><p>main.c代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Server.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;./a.out port path\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = atoi(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 切换服务器的工作目录</span><br>    chdir(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-comment">// 初始化监听的套接字</span><br>    <span class="hljs-type">int</span> lfd = initListenFd(port);<br><br>    <span class="hljs-comment">// 启动服务器程序</span><br>    epollRun(lfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Server.h代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-comment">// 初始化监听的文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">initListenFd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span>;<br><br><span class="hljs-comment">// 启动epoll</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epollRun</span><span class="hljs-params">(<span class="hljs-type">int</span> lfd)</span>;<br><br><span class="hljs-comment">// 和客户端建立连接</span><br><span class="hljs-comment">// int acceptClient(int lfd, int epfd);</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">acceptClient</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>;<br><br><span class="hljs-comment">// 接收http请求</span><br><span class="hljs-comment">// int recvHttpRequest(int cfd, int epfd);</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">recvHttpRequest</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>;<br><br><span class="hljs-comment">// 解析请求行</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">parseRequestLine</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* line, <span class="hljs-type">int</span> cfd)</span>;<br><br><span class="hljs-comment">// 发送文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sendFile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, <span class="hljs-type">int</span> cfd)</span>;<br><br><span class="hljs-comment">// 发送响应头(状态行和响应头)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* cfd 通信文件描述符</span><br><span class="hljs-comment">* status 状态码</span><br><span class="hljs-comment">* descr 状态描述</span><br><span class="hljs-comment">* type 描述数据格式</span><br><span class="hljs-comment">* length 数据库长度 若为-1，则告诉浏览器去计算长度</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sendHeadMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> cfd, <span class="hljs-type">int</span> status, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* descr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* type, <span class="hljs-type">int</span> length)</span>;<br><br><span class="hljs-comment">// 获取文件类型，已经有，不用再写</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">getFileType</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span>;<br><br><span class="hljs-comment">// 发送目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sendDir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dirName, <span class="hljs-type">int</span> cfd)</span>;<br><br><span class="hljs-comment">// 将数字从十六进制转换成十进制</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hexToDec</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>;<br><br><span class="hljs-comment">// 解码，解决中文乱码问题，from传入参数，to传出参数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">decodeMsg</span><span class="hljs-params">(<span class="hljs-type">char</span>* to, <span class="hljs-type">char</span>* from)</span>;<br></code></pre></td></tr></table></figure><p>Server.c代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Server.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sendfile.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FdInfo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">int</span> epfd;<br><span class="hljs-type">pthread_t</span> tid;<br>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">initListenFd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port )</span><br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 1. 创建监听的fd</span><br><span class="hljs-comment">* AF_INET：基于IPv4协议</span><br><span class="hljs-comment">* SOCK_STREAM：采用流式协议，即tcp协议</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> lfd = socket(AF_INET, SOCK_STREAM,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (lfd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;socket&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. 设置端口复用：如果程序服务器是主动断开连接的一方，会有一个2msl的等待时长，为了确认客户端已经收到我断开确认ack，</span><br><span class="hljs-comment">// 2msl之后才能释放端口</span><br><span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> ret = setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="hljs-keyword">sizeof</span> (opt));<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;setsockopt&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 3. 绑定</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span><br>addr.sin_family = AF_INET; <span class="hljs-comment">// 地址协议ipv4</span><br>addr.sin_port = htons(port); <span class="hljs-comment">// 指定端口，指定的网络字节序为大端，需要进行转换</span><br>addr.sin_addr.s_addr = INADDR_ANY; <br>ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-keyword">sizeof</span>(addr));<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;bind&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 4. 设置监听 </span><br><span class="hljs-comment">// 128代表在监听过程中一次性能监听多少个连接请求</span><br>ret = listen(lfd,<span class="hljs-number">128</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;listen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 5. 返回fd</span><br><span class="hljs-keyword">return</span> lfd;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epollRun</span><span class="hljs-params">(<span class="hljs-type">int</span> lfd)</span><br>&#123;<br><span class="hljs-comment">// 1. 创建epoll 树的根节点</span><br><span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (epfd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;epoll_create&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. lfd上树：上树用的是epoll_ctl函数，epoll_ctl函数功能强大，第二个参数是表示当前对epoll树做什么操作</span><br><span class="hljs-comment">// 上树的时候，第二个参数是add</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>ev.data.fd = lfd; <br>ev.events = EPOLLIN; <span class="hljs-comment">//检测读事件</span><br><br><span class="hljs-type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;epoll_ctl&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 3. 检测</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">evs</span>[1024];</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 若有事件连接，会存到evs中，并返回有多少个值为num。</span><br><span class="hljs-type">int</span> size = <span class="hljs-keyword">sizeof</span>(evs) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event);<br><span class="hljs-type">int</span> num = epoll_wait(epfd, evs, size,  <span class="hljs-number">-1</span>);  <span class="hljs-comment">//最后一个参数为-1，没有连接就一直阻塞</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FdInfo</span>* <span class="hljs-title">info</span> =</span> (<span class="hljs-keyword">struct</span> FdInfo*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> FdInfo));<br><span class="hljs-type">int</span> fd = evs[i].data.fd;<br>info-&gt;epfd = epfd;<br>info-&gt;fd = fd;<br><br><span class="hljs-keyword">if</span> (fd == lfd) &#123;<br><span class="hljs-comment">// 建立新连接，将新连接添加到epoll树上，添加之后，epoll_wait再检测的节点就变多了。</span><br><span class="hljs-comment">//acceptClient(lfd, epfd);</span><br>pthread_create(&amp;info-&gt;tid, <span class="hljs-literal">NULL</span>, acceptClient, info);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 数据通信，主要接收对端的数据，格式为http协议格式</span><br><span class="hljs-comment">//recvHttpRequest(fd, epfd);</span><br>pthread_create(&amp;info-&gt;tid, <span class="hljs-literal">NULL</span>, recvHttpRequest, info);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// int acceptClient(int lfd, int epfd);</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">acceptClient</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FdInfo</span>* <span class="hljs-title">info</span> =</span> (<span class="hljs-keyword">struct</span> FdInfo*)arg;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 1. 建立连接，调用accept函数</span><br><span class="hljs-comment">* accept 三个参数：</span><br><span class="hljs-comment">* 第一个参数：需要监听的文件描述符</span><br><span class="hljs-comment">* 第二个参数：传出参数，用来保存客户端的ip和端口信息，这里不需要保存</span><br><span class="hljs-comment">* 第三个参数：计算第二个参数的大小</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> cfd = accept(info-&gt;fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (cfd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;accept&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. 设置边沿非阻塞模式，非阻塞说的是文件描述符，默认得到的cfd是阻塞的，用fcntl修改文件描述符的属性</span><br><span class="hljs-type">int</span> flag = fcntl(cfd, F_GETFL);<br>flag |= O_NONBLOCK;<br>fcntl(cfd, F_SETFL, flag);<br><br><span class="hljs-comment">// 3. cfd添加到epoll中：</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>ev.data.fd = cfd;<br>ev.events = EPOLLIN | EPOLLET; <span class="hljs-comment">//检测读事件，EPOLLET设置为边沿触发</span><br><br><span class="hljs-type">int</span> ret = epoll_ctl(info-&gt;epfd, EPOLL_CTL_ADD, cfd, &amp;ev);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;epoll_ctl&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// int recvHttpRequest(int cfd, int epfd);</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">recvHttpRequest</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FdInfo</span>* <span class="hljs-title">info</span> =</span> (<span class="hljs-keyword">struct</span> FdInfo*)arg;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> tmp[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;; <br><span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">//用来存储客户端发过来的整个数据，不够长也没事，只要读出来请求头其实就可以了。</span><br><span class="hljs-keyword">while</span> ((len = recv(info-&gt;fd, tmp ,<span class="hljs-keyword">sizeof</span> tmp, <span class="hljs-number">0</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (total + len &lt; <span class="hljs-keyword">sizeof</span> buf) &#123;<br><span class="hljs-built_in">memcpy</span>(buf+total, tmp, len);<br>&#125;<br>total += len;<br>&#125;<br><br><span class="hljs-comment">// 判断数据是否被接收完毕</span><br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span> &amp;&amp; errno == EAGAIN) &#123;<br><span class="hljs-comment">//解析请求行，另写一个函数，这里只解析请求头</span><br><span class="hljs-type">char</span>* pt = <span class="hljs-built_in">strstr</span>(buf, <span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-type">int</span> reqLen = pt - buf;<br>buf[reqLen] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>parseRequestLine(buf, info-&gt;fd);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 客户端断开了连接</span><br>epoll_ctl(info-&gt;epfd, EPOLL_CTL_DEL, info-&gt;fd, <span class="hljs-literal">NULL</span>);<br>close(info-&gt;fd);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>perror(<span class="hljs-string">&quot;recv&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">parseRequestLine</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* line, <span class="hljs-type">int</span> cfd)</span><br>&#123;<br><span class="hljs-comment">// 解析请求行</span><br><span class="hljs-comment">// sscanf拆分字符串</span><br><span class="hljs-type">char</span> method[<span class="hljs-number">12</span>]; <span class="hljs-comment">// get or post</span><br><span class="hljs-type">char</span> path[<span class="hljs-number">1024</span>]; <br><span class="hljs-built_in">sscanf</span>(line, <span class="hljs-string">&quot;%[^ ] %[^ ]&quot;</span>, method, path);<br><span class="hljs-comment">// 只处理get请求</span><br><span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;get&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>decodeMsg(path, path); <span class="hljs-comment">//处理中</span><br><span class="hljs-comment">// 处理静态资源(目录或文件)</span><br><span class="hljs-type">char</span>* file = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>file = <span class="hljs-string">&quot;./&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>file = path + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 获取文件属性，判断是目录还是文件</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-type">int</span> ret = stat(file, &amp;st);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-comment">// 文件不存在， 404</span><br>sendHeadMsg(cfd, <span class="hljs-number">404</span>, <span class="hljs-string">&quot;Not Found&quot;</span>, getFileType(<span class="hljs-string">&quot;.html&quot;</span>), <span class="hljs-number">-1</span>);<br>sendFile(<span class="hljs-string">&quot;404.html&quot;</span>, cfd); <span class="hljs-comment">//在当前目录下</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(S_ISDIR(st.st_mode)) &#123;<br><span class="hljs-comment">// 是目录</span><br>sendHeadMsg(cfd, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;OK&quot;</span>, getFileType(<span class="hljs-string">&quot;.html&quot;</span>), <span class="hljs-number">-1</span>);<br>sendDir(file, cfd);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 请求的是文件，发送文件</span><br>sendHeadMsg(cfd, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;OK&quot;</span>, getFileType(file), st.st_size);<br>sendFile(file, cfd);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sendFile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, <span class="hljs-type">int</span> cfd)</span><br>&#123;<br><span class="hljs-comment">// 1.打开文件</span><br><span class="hljs-type">int</span> fd = open(fileName, O_RDONLY);<br>assert(fd &gt; <span class="hljs-number">0</span>);<br><span class="hljs-comment">//while (1) &#123;</span><br><span class="hljs-comment">//char buf[1024];</span><br><span class="hljs-comment">//int len = read(fd, buf, sizeof buf);</span><br><span class="hljs-comment">//if (len &gt; 0) &#123;</span><br><span class="hljs-comment">//send(cfd, buf, len, 0);</span><br><span class="hljs-comment">//usleep(10); //不要发送太快，给对端一个喘口气的时间</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//else if (len == 0) &#123;</span><br><span class="hljs-comment">//break;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//else &#123;</span><br><span class="hljs-comment">//prror(&quot;read&quot;);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-type">off_t</span> offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br>lseek(fd, <span class="hljs-number">0</span>, SEEK_SET);<br><span class="hljs-keyword">while</span> (offset &lt; size) <span class="hljs-comment">// 如果偏移量小于size，则表示文件没有发送完，继续发送</span><br>&#123;<br><span class="hljs-comment">// 通信的文件描述符是非阻塞的</span><br><span class="hljs-type">int</span> ret = sendfile(cfd, fd, &amp;offset, size - offset);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret value: %d\n&quot;</span>, ret);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span> &amp;&amp; errno == EAGAIN) <span class="hljs-comment">// EAGAIN的意思是没有数据，可以再次进行尝试</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没数据...\n&quot;</span>); <br>&#125;<br>&#125;<br>close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sendHeadMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> cfd, <span class="hljs-type">int</span> status, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* descr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* type, <span class="hljs-type">int</span> length)</span><br>&#123;<br><span class="hljs-comment">// 状态行</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;http/1.1 %d %s\r\n&quot;</span>, status, descr); <span class="hljs-comment">//版本 状态码 描述语言</span><br><span class="hljs-comment">// 响应头</span><br><span class="hljs-built_in">sprintf</span>(buf + <span class="hljs-built_in">strlen</span>(buf), <span class="hljs-string">&quot;content-type: %s\r\n&quot;</span>, type); <br><span class="hljs-built_in">sprintf</span>(buf + <span class="hljs-built_in">strlen</span>(buf), <span class="hljs-string">&quot;content-length: %d\r\n\r\n&quot;</span>, length);<br><br>send(cfd, buf, <span class="hljs-built_in">strlen</span>(buf), <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">getFileType</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span><br>&#123;<br><span class="hljs-comment">// a.jpg a.mp4 a.html</span><br><span class="hljs-comment">// 自右向左查找‘.’字符, 如不存在返回NULL</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dot = <span class="hljs-built_in">strrchr</span>(name, <span class="hljs-string">&#x27;.&#x27;</span>);<br><span class="hljs-keyword">if</span> (dot == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span>;<span class="hljs-comment">// 纯文本</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.html&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.htm&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.jpg&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.jpeg&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;image/jpeg&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.gif&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;image/gif&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.png&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;image/png&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.css&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;text/css&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.au&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;audio/basic&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.wav&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;audio/wav&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.avi&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;video/x-msvideo&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.mov&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.qt&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;video/quicktime&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.mpeg&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.mpe&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;video/mpeg&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.vrml&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.wrl&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;model/vrml&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.midi&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.mid&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;audio/midi&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.mp3&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;audio/mpeg&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.ogg&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;application/ogg&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(dot, <span class="hljs-string">&quot;.pac&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sendDir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dirName, <span class="hljs-type">int</span> cfd)</span><br>&#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;</span>, dirName);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span>** <span class="hljs-title">namelist</span>;</span><br><span class="hljs-type">int</span> num = scandir(dirName, &amp;namelist, <span class="hljs-literal">NULL</span>, alphasort); <span class="hljs-comment">//修改vs设置c语言的标准为GUN11</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i)<br>&#123;<br><span class="hljs-comment">// 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]</span><br><span class="hljs-type">char</span>* name = namelist[i]-&gt;d_name;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-type">char</span> subPath[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">sprintf</span>(subPath, <span class="hljs-string">&quot;%s/%s&quot;</span>, dirName, name); <span class="hljs-comment">//拼接字符串</span><br>stat(subPath, &amp;st);<br><span class="hljs-keyword">if</span> (S_ISDIR(st.st_mode))<br>&#123;<br><span class="hljs-comment">// a标签 &lt;a href=&quot;&quot;&gt;name&lt;/a&gt;</span><br><span class="hljs-built_in">sprintf</span>(buf + <span class="hljs-built_in">strlen</span>(buf),<br><span class="hljs-string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>,<br>name, name, st.st_size);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">sprintf</span>(buf + <span class="hljs-built_in">strlen</span>(buf),<br><span class="hljs-string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>,<br>name, name, st.st_size);<br>&#125;<br>send(cfd, buf, <span class="hljs-built_in">strlen</span>(buf), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">free</span>(namelist[i]); <span class="hljs-comment">//释放内存</span><br>&#125;<br><span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>send(cfd, buf, <span class="hljs-built_in">strlen</span>(buf), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">free</span>(namelist);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 将数字从十六进制转换成十进制</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hexToDec</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span><br>&#123;<br><span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br><span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;F&#x27;</span>)<br><span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">decodeMsg</span><span class="hljs-params">(<span class="hljs-type">char</span>* to, <span class="hljs-type">char</span>* from)</span><br>&#123;<br><span class="hljs-keyword">for</span> (; *from != <span class="hljs-string">&#x27;\0&#x27;</span>; ++to, ++from)<br>&#123;<br><span class="hljs-comment">// isxdigit -&gt; 判断字符是不是16进制格式, 取值在 0-f</span><br><span class="hljs-keyword">if</span> (from[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;%&#x27;</span> &amp;&amp; <span class="hljs-built_in">isxdigit</span>(from[<span class="hljs-number">1</span>]) &amp;&amp; <span class="hljs-built_in">isxdigit</span>(from[<span class="hljs-number">2</span>]))<br>&#123;<br><span class="hljs-comment">// 将16进制的数 -&gt; 十进制 将这个数值赋值给了字符 int -&gt; char</span><br><span class="hljs-comment">// B2 == 178</span><br><span class="hljs-comment">// 将3个字符, 变成了一个字符, 这个字符就是原始数据</span><br>*to = hexToDec(from[<span class="hljs-number">1</span>]) * <span class="hljs-number">16</span> + hexToDec(from[<span class="hljs-number">2</span>]);<br><br><span class="hljs-comment">// 跳过 from[1] 和 from[2] 因此在当前循环中已经处理过了</span><br>from += <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// 字符拷贝, 赋值</span><br>*to = *from;<br>&#125;<br><br>&#125;<br>*to = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YOLO5Face学习</title>
    <link href="/2024/03/25/YOLO5Face/"/>
    <url>/2024/03/25/YOLO5Face/</url>
    
    <content type="html"><![CDATA[<h1 id="YOLO5Face模型分析"><a href="#YOLO5Face模型分析" class="headerlink" title="YOLO5Face模型分析"></a>YOLO5Face模型分析</h1><p>研究生时候写的一篇小白文。</p><h2 id="论文及源码下载"><a href="#论文及源码下载" class="headerlink" title="论文及源码下载"></a>论文及源码下载</h2><p>论文地址：<a href="https://arxiv.org/abs/2105.12931">https://arxiv.org/abs/2105.12931</a>论文我们中国人写的，读起来还是挺顺的。<br>源码地址：<a href="https://github.com/deepcam-cn/yolov5-face">https://github.com/deepcam-cn/yolov5-face</a><br>WiderFace地址：<a href="http://shuoyang1213.me/WIDERFACE/WiderFace_Results.html">WIdeFace</a><br>Yolo5Face是深圳神目科技&amp;LinkSprite Technologies（美国）在Yolov5模型基础上进行更新得到的人脸检测模型，在WiderFace上取得了SOTA。</p><h2 id="论文创新点"><a href="#论文创新点" class="headerlink" title="论文创新点"></a>论文创新点</h2><p>正如论文名字的后半部分Why Reinventing a Face Detector？论文将人脸检测视为一般的目标检测任务，所以作者以现在比较热门的YOLOv5模型为基础，辅助以人脸特性，得到一个新的人脸检测器。<br>论文创新点：</p><ol><li><p><strong>在YOLOv5网络中添加五个人脸关键点回归，回归的损失函数用的是Wing loss</strong>。（类比MTCNN、RetinaFace）<br> MTCNN中使用L2损失作为5个人脸关键点的回归损失，但是L2对小的误差并不敏感，为了克服这个问题，Wing-Loss出现了。<br> <img src="https://pic.imgdb.cn/item/660410649f345e8d03ce5ff3.png" alt="wing loss"><br><img src="https://pic.imgdb.cn/item/660410709f345e8d03cedd4b.png" alt="wing loss 图像"><br>可以看到Wing-loss是一个分段的复合损失函数，在训练初期误差较大时用L1损失，在训练后期误差相对小，用一个具有偏移量的对数函数。wing-loss的优点我也不能很好的论述清楚，感兴趣的可以去看这篇博客。<a href="https://blog.csdn.net/john_bh/article/details/106302026">https://blog.csdn.net/john_bh&#x2F;article&#x2F;details&#x2F;106302026</a><br>作者将五个人脸关键点回归损失加入到总的损失函数中去后，作者将这部分损失函数称为LossL并给这部分损失加上权重，加上YOLOv5本身的损失函数LossO，总的损失函数为Loss(s)。<br><img src="https://img-blog.csdnimg.cn/c35a419445504fab9a7d4c0dae956a93.png" alt="在这里插入图片描述"><br>作者在配置文件里面写的：<strong>landmark: 0.005</strong> # landmark loss gain，那应该这个权重就是0.005，具体的代码我还没有看到，看到以后如果不对再改。</p></li><li><p><strong>用Stem模块替代网络中原有的Focus模块</strong>，提高了网络的泛化能力，降低了计算复杂度，同时性能也没有下降。<br>Focus模块出来的时候，就有人说Focus模块比较鸡肋。可能是作者想改掉这部分又不想大改v5的整体模型，所以设计出一个相对更好的模块。<br>Stem模块的图示中虽然都是用的CBS，但是看代码可以看出来第2个和第4个CBS是1x1卷积，第1个和第3个CBS是3x3，stride&#x3D;2的卷积。配合yaml文件可以看到stem以后图像大小由604x640变成了160x160。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StemBlock</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, c1, c2, k=<span class="hljs-number">3</span>, s=<span class="hljs-number">2</span>, p=<span class="hljs-literal">None</span>, g=<span class="hljs-number">1</span>, act=<span class="hljs-literal">True</span></span>):<br>        <span class="hljs-built_in">super</span>(StemBlock, self).__init__()<br>        self.stem_1 = Conv(c1, c2, k, s, p, g, act) <span class="hljs-comment"># 已经下采样一次了</span><br>        self.stem_2a = Conv(c2, c2 // <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>        self.stem_2b = Conv(c2 // <span class="hljs-number">2</span>, c2, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>        self.stem_2p = nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stem_3 = Conv(c2 * <span class="hljs-number">2</span>, c2, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        stem_1_out  = self.stem_1(x)<br>        stem_2a_out = self.stem_2a(stem_1_out)<br>        stem_2b_out = self.stem_2b(stem_2a_out)<br>        stem_2p_out = self.stem_2p(stem_1_out)<br>        out = self.stem_3(torch.cat((stem_2b_out,stem_2p_out),<span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/660410819f345e8d03cf9209.png" alt="stem模块"></p></li><li><p><strong>对SPP模块进行更新，使用更小的kernel</strong>，使yolov5更适用于人脸检测并提高了检测精度。YOLOv5用的SPPkernel(5,9,13)，YOLO5Face用的kernel(3,5,7)。<br><img src="https://pic.imgdb.cn/item/6604108c9f345e8d03d00897.png" alt="SPP模块"></p></li><li><p><strong>添加一个stride &#x3D; 64的P6输出块，P6可以提高对大人脸的检测性能</strong>。（之前的人脸检测模型大多关注提高小人脸的检测性能，这里作者关注了大人脸的检测效果，提高大人脸的检测性能来提升模型整体的检测性能）。P6的特征图大小为10x10。</p></li><li><p><strong>发现一些目标检测的数据增广方法并不适合用在人脸检测中，包括上下翻转和Mosaic数据增广</strong>。删除上下翻转可以提高模型性能。对小人脸进行Mosaic数据增广反而会降低模型性能，但是对中尺度和大尺度人脸进行Mosaic可以提高性能。随机裁剪有助于提高性能。<br>这里主要还是COCO数据集和WiderFace数据集尺度有差异，WiderFace数据集小尺度数据相对较多。</p></li><li><p><strong>基于ShuffleNetv2设计了两个轻量级模型</strong>，backbone和CSP网络不同，模型非常小，可以在嵌入式设备和移动设备达到SOTA。</p></li></ol><p>依托YOLOv5可以调整网络宽度和深度的特点，作者可以方便的设计不同深度和宽度的网络模型，还用ShuffleNetv2设计了轻量级模型，也就是说从复杂到简单，从服务器到嵌入式或者移动设备，都有可以选择的模型。 </p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://pic.imgdb.cn/item/6604109d9f345e8d03d0abac.png" alt="消融实验"><br>可以看到作者用的各种模块基本上都能提升map，忽略小人脸进行Mosaic数据增广Easy和Medium的map提升，但是hard的map下降了一些，模型整体的map提升。<br><img src="https://pic.imgdb.cn/item/660410aa9f345e8d03d130f6.png" alt="对比实验"><br>对比实验主要还是和SCRFD进行对比，可以看到SCRFD的模型整体性能也很好，并且参数和计算量相对比YOLOv5l6小一些，但是YOLOv5l6的map稍微更高一些。<br>实验最后的一些图显示YOLO5Face的召回率相比还有一些提升空间，但是评估中没有TTA方法。（我觉得可以看看看图里面比YOLO5Face召回率高的论文，分析一下为什么别的论文里面召回率更高一些，大神分析出来了请告诉我好吗）。<img src="https://pic.imgdb.cn/item/660410bf9f345e8d03d201c4.png" alt="YOLO5Face召回率比较"></p><h2 id="下载代码跑起来"><a href="#下载代码跑起来" class="headerlink" title="下载代码跑起来"></a>下载代码跑起来</h2><p>下载代码的地址就是上面的github地址，如果没有配环境就慢慢配环境，不过我觉得更好的方法是把yolov5的代码下载下来，主要里面有个requirements.txt，在pycharm里面直接就能自动下载了，太爽了，没有什么就下载什么，很快就能把环境配好，然后打开yolo5face的代码，用v5自动配好的环境，如果有不匹配的再改。</p><h2 id="调整数据集"><a href="#调整数据集" class="headerlink" title="调整数据集"></a>调整数据集</h2><p>现在我用的数据集目录结构：widerface和widerfaceyolo都用到了。<br><img src="https://pic.imgdb.cn/item/660410cc9f345e8d03d2823e.png" alt="目录结构"><br>调整数据集其实需要分两步，我是把两步的数据集都放到项目里面了：</p><ol><li>将官网训练集标签替换成带人脸关键点的标签，并将验证所需要的wider_val.txt放到路径下面，将数据集放在项目下命名为widerface，用于验证模型检测精度。</li><li>将数据集调整成YOLO5face所需要的的目录格式，命名为widerfaceyolo，用于训练。</li></ol><p><strong>这两步生成的数据集我都上传到腾讯微云了</strong>，如果不想看具体怎么操作的，可以直接<a href="https://share.weiyun.com/YGaR6OYB">点击链接获取已经调整好的数据集</a>，下载下来放到自己的文件夹就行了。</p><ol><li>WiderFace官网下载数据集链接已经放到最上面了。下载的地方是这样的：<br><img src="https://pic.imgdb.cn/item/660410db9f345e8d03d31802.png" alt="WiderFace数据集下载">官网的数据集分三部分，Training和Validation是带标签的，test没有标签，可以暂时不下载。</li><li>下载人脸关键点的标签：因为官网的训练集中人脸是不带关键点，yolo5face需要用到人脸关键点，需要下载带人脸关键点的注释。官网上给的下载地址是<a href="https://drive.google.com/file/d/1tU_IjyOwGQfGNUvZGwWWM4SwxKp2PUQ8/view?usp=sharing">goole drive</a>的地址。更换标签就完成了初步转换，要把这个初步转换的数据集放到项目里面去，然后在网上找到wider_val.txt也放到下面。<strong>因为后面要做检测精度的验证</strong>，目录结构和我上面的图里面的结构保持一致。</li><li>调整目录结构：<br> 运行两个.py文件，就是官网上说的train2yolo.py和val2yolo.py。看名字也能看明白，这两个代码就是把数据集转成YOLO训练用的格式。<br> 先改<strong>train2yolo.py</strong><img src="https://pic.imgdb.cn/item/660410f368eb935713907030.png" alt="train2yolo.py"><br> 看名字应该看的懂的，save_path是转换之后的图片存到哪里，我是直接存到data下面了，注意文件夹一定要事先建好，不然会出错！第二行就是label.txt的位置，要根据label.txt找图片的位置，这就是为什么要调整好图片和labels.txt。<br>再改<strong>val2yolo.py</strong>, root改到widerface层<br><img src="https://pic.imgdb.cn/item/6604110968eb935713907cfa.png" alt="root"><br>修改img和txt的输出路径，具体将图片和标签放不放在一起，看自己写的代码。<br><img src="https://pic.imgdb.cn/item/6604111d9f345e8d03d556f8.png" alt="val"><br>调整完成的widerfaceyolo目录结构：<br><img src="https://pic.imgdb.cn/item/6604113d68eb935713908cc8.png" alt="在这里插入图片描述"><br>和上面的总体结构一起看就能明白。</li><li>修改widerface.yaml文件，改为自己的数据集路径，记得把下载voc的代码注释掉，然后改成类似的格式就可以了。<br><img src="https://pic.imgdb.cn/item/6604114a9f345e8d03d78015.png" alt="在这里插入图片描述"></li></ol><h2 id="训练完成之后检验结果"><a href="#训练完成之后检验结果" class="headerlink" title="训练完成之后检验结果"></a>训练完成之后检验结果</h2><p>runs文件夹下面有对应的训练输出结果，可以看到召回率，检测精度，map。</p><ol><li>验证检测准确度<br> 修改test_widerface.py文件，写入自己的训练好的权重路径<br><img src="https://pic.imgdb.cn/item/6604115868eb935713909701.png" alt="在这里插入图片描述"><br>修改验证集图片路径，指出wider_val.txt的路径，我这里就是用的widerface的路径，不是widerfaceyolo的路径，相应的改成自己的路径即可。<br><img src="https://pic.imgdb.cn/item/660411689f345e8d03d87439.png" alt="在这里插入图片描述"><br>这些步骤完成以后，运行test_widerface.py文件，运行完成以后，进入到widerface_evaluate文件夹下，点击widerface_txt可以看到生成的txt文件夹，和里面的txt文件，运行evalution.py即可得到检测准确度，跑不起来就先把对应的包先装好。</li><li>未完待续</li></ol><h2 id="一点点代码简析"><a href="#一点点代码简析" class="headerlink" title="一点点代码简析"></a>一点点代码简析</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul><li>data</li><li>models</li><li>runs</li><li>torch2tensorrt    # 没看懂，也没用过，懂的教教我</li><li>utils</li><li>weights # 下载预训练权重的脚本</li><li>widerface_evaluate # 验证检测精度的文件夹</li><li>detect_face.py # 只能检测一张图片</li><li>hubconf.py   #PyTorch Hub相关代码，没啥大用</li><li>LICENSE  # 版权文件</li><li>README.md # README markdown文件</li><li>result.jpg # 检测人脸的输出结果</li><li>test.py # 不是用的这个</li><li>test_widerface.py # 用的是这个</li><li>train.py # 模型训练脚本</li></ul><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul><li>images，一些检测用得到的图片。</li><li>scripts，下载其他数据集的一些脚本文件，基本没用。</li><li>widerface，初步转换数据集，用来生成widerfaceyolo数据集和验证训练模型的检测精度。</li><li>widerfaceyolo，训练用的数据集。</li><li>argoverse_hd.yaml&#x2F;coco.yaml&#x2F;coco.yaml&#x2F;voc.yaml，下载自动驾驶&#x2F;COCO&#x2F;VOC训练数据集，配置一下类别数，没啥用。</li><li>hyp.finetune.yaml，yolov5根据voc数据集设置的超参</li><li>hyp.finetune.yaml，真正用到的超参文件！</li><li>retinaface2yolo.yaml，没用过，不太懂</li><li>train2yolo.py，生成训练用的train数据集</li><li>val2yolo.py，生成训练用的val数据集</li><li>widerface.yaml，训练用到的配置文件！</li></ul><h3 id="models"><a href="#models" class="headerlink" title="models"></a>models</h3><ul><li>common.py 模型组件的相关代码</li><li>experimental.py 实验性质的代码，作者的一些想法，没有加到模型里去</li><li>export.py 导出网络模型的结构，会很长很长</li><li>yolo.py Detect以及Model构建代码，写出网络模型的整体构建过程</li><li>….yaml 大大小小的模型配置文件，突出一个灵活。</li></ul><h4 id="common-py"><a href="#common-py" class="headerlink" title="common.py"></a>common.py</h4><ul><li>def autopad：为same卷积或same池化自动零填充，具体填充多少就是用这个函数计算的，保证卷积和池化后的特征图大小不变。</li><li>def channel_shuffle：通道打乱，ShuffleV2Block的前置模块。</li><li>def DWConv：深度可分离卷积，没用到。</li><li>class Conv：Conv2d+BN+SiLU，也可以不进行BN操作。</li><li>class StemBlock：替代Focus的模块，注意每个卷积核的大小和输出尺度。</li><li>class Bottleneck：两次卷积+一次残差连接</li><li>class BottleneckCSP：有多少个n就会有多少个Bottleneck，外层用的激活函数是Leaky_ReLU(0.1)。<br>  一个分支做一次CBS(1x1)，再做n次Bottleneck，再进行一次Conv2d(1x1)；<br>  另一个分支做一次Conv2d(1x1)；<br>  两个分支concat+BN+leakyRelu+CBS(1x1)。</li><li>class C3：论文里面的C3的图是错误的，图里面的浅绿色方块是做一次Conv2d，实际上C3没有进行Conv2d，而是全部用的CBS，也可能是我没看到更深层的代码。<br>一个分支做CBS，做n次Bottleneck；<br>另一个分支做CBS；<br>两个分支concat以后做一次CBS。</li><li>class ShuffleV2Block：轻量化网络结构模块ShuffleV2Block，我没有对这个部分深入理解，后续用到再更新。</li><li>class SPP：SPP模块。</li><li>class Focus：Focus模块。</li><li>class Contract：收缩模块：调整张量的大小，将宽高收缩到通道中。</li><li>class Expand：扩张模块，将特征图像素变大，例如：x(1,64,80,80) to x(1,16,160,160)。</li><li>class Concat：自定义concat模块，dimension就是维度值，说明沿着哪一个维度进行拼接。</li><li>class NMS ：非极大值抑制模块。</li><li>class autoShape：自动调整shape值：因为输入图像可能来自不同的地方和格式，例如filename，URI，numpy等，autoShape模块就是将这些数据进行预处理和调整。</li><li>class Detections：看名字是做检测，但是好像没用到这个模块。</li><li>class Classify：二级分类模块，人脸检测没用到。</li></ul><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><ul><li>aws&#x2F;goolge_app_engine&#x2F;wandb_logging&#x2F;google_utils.py 谷歌云和自动驾驶相关的东西，没啥用</li><li>activation.py 激活函数代码</li><li>autoanchor.py 自动计算先验框代码</li><li>datasets.py  yolov5用来生成训练用数据的代码，yolo5face没用这个</li><li>face_datasets.py dataset和dataloader定义代码，只能读图片</li><li>general.py 设置一些通用的代码，如日志文件，随机数，获取最后一个权重文件等等</li><li>loss.py 损失函数相关代码</li><li>metrics.py 模型验证度量，计算ap,p,r等</li><li>plotting utils.py 画图工具</li><li>torch_utils pytorch工具，初始化随机数种子，git描述等</li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ol><li>有问题可以先去github官网源码那里看看，想在CSDN找答案实在是太难了。</li><li>官网的yolo5-face.pt预训练权重加入到模型中进行训练是会报错的，用yolov5官方的5.0的权重作为预训练权重就可以了。</li><li>验证检测精度的wider_val.txt文件链接：<a href="https://share.weiyun.com/fwV3TUDh">wider_val.txt</a></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/375966269"> https://zhuanlan.zhihu.com/p/375966269</a><br><a href="https://blog.csdn.net/john_bh/article/details/106302026">https://blog.csdn.net/john_bh&#x2F;article&#x2F;details&#x2F;106302026</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络服务器</title>
    <link href="/2024/03/25/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2024/03/25/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="如果要让服务器服务于多个客户端"><a href="#如果要让服务器服务于多个客户端" class="headerlink" title="如果要让服务器服务于多个客户端"></a>如果要让服务器服务于多个客户端</h1><ul><li><a href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%8D%E5%8A%A1%E4%BA%8E%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF">如果要让服务器服务于多个客户端</a><ul><li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8">多线程服务器</a></li><li><a href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">IO多路复用</a><ul><li><a href="#select-poll-epoll%E6%98%AF%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6%E7%9A%84">select poll epoll是如何获取网络事件的？</a></li></ul></li><li><a href="#reactor%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F">Reactor反应堆模式</a><ul><li><a href="#%E5%8D%95reactor%E5%8D%95%E7%BA%BF%E7%A8%8B">单Reactor单线程</a></li><li><a href="#%E5%8D%95reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B">单Reactor多线程</a></li><li><a href="#%E5%A4%9Areactor%E5%A4%9A%E7%BA%BF%E7%A8%8B">多Reactor多线程</a></li></ul></li><li><a href="#proactor%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F">Proactor反应堆模式</a><ul><li><a href="#%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5io">阻塞、非阻塞、同步、异步IO</a></li></ul></li></ul></li></ul><h2 id="多线程服务器"><a href="#多线程服务器" class="headerlink" title="多线程服务器"></a>多线程服务器</h2><ul><li>最简单的想法就是<code>多线程</code>：为每一个连接创建线程。<ul><li>创建进程也可以，但是线程更加轻量级。</li><li>现在也可以用<code>协程</code>实现服务器。</li></ul></li><li>进一步：多线程变成<code>线程池, 减少线程不停创建销毁的开销，资源复用</code>。<ul><li>问题出现？ 一个线程需要处理多个连接的业务。怎么才能让线程高效的处理多个连接的业务？<ul><li>多线程时：线程一般采用read -&gt; 业务处理 -&gt; send的处理流程。如果当前没有数据可读，线程会阻塞在read上，这种阻塞不会影响其他线程。</li><li>当线程池存在时：线程read，如果没有数据，不能阻塞，如果这个时候阻塞，线程就没办法处理其他连接的业务了。</li><li>解决这个问题的方案：<ul><li>最简单的方式:socket设置为非阻塞，线程不断地轮询调用 read 操作来判断是否有数据。缺点是比较粗暴，轮询非常消耗cpu，随着线程处理连接的变多，轮询的效率就会变低。<code>线程并不知道当前连接是否有数据可读，需要每次通过read去试探</code>。</li><li><strong>IO多路复用</strong>：<code>IO多路复用则只有当连接上有数据的时候，线程才会发起请求</code>。</li></ul></li></ul></li></ul></li></ul><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用技术：用一个系统调用函数来监听我们关心的连接，也就说可以在一个监控线程里面监控很多的连接。<code>select/poll/epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件。</code></p><h3 id="select-poll-epoll是如何获取网络事件的？"><a href="#select-poll-epoll是如何获取网络事件的？" class="headerlink" title="select poll epoll是如何获取网络事件的？"></a>select poll epoll是如何获取网络事件的？</h3><p>获取事件时，把关心的连接传给内核，再由内核检测：</p><ul><li>如果没有事件发生，线程只需阻塞在这个系统调用，而无需像前面的线程池方案那样轮训调用 read 操作来判断是否有数据。</li><li>如果有事件发生，内核会返回产生了事件的连接，线程就会从阻塞状态返回，然后在用户态中再处理这些连接对应的业务即可。</li></ul><p>IO多路复用就是高性能网络的基础，单纯的使用IO多路复用API，实际上使用的面向过程的方法去写代码。</p><p>IO多路复用下，内核不断地去巡检事件，然后通知处理，比较理想的方式是以一种<code>回调</code>的方式去处理事件，事件做完以后通知主线程。<code>Reactor和Proactor本质都是回调，区别是回调的方式是异步还是同步的。</code></p><h2 id="Reactor反应堆模式"><a href="#Reactor反应堆模式" class="headerlink" title="Reactor反应堆模式"></a>Reactor反应堆模式</h2><p>Reactor：IO多路复用监听事件，收到事件后，根据事件类型分配给某个进程&#x2F;线程。来了一个事件，Reactor 就有相对应的反应&#x2F;响应。是<code>同步IO</code>的处理方式。</p><p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成:</p><ul><li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li><li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li></ul><p>Reactor和业务处理都可以是多个，也就有了多种处理方案：</p><ul><li>单 Reactor 单进程 &#x2F; 线程；</li><li>单 Reactor 多进程 &#x2F; 线程；</li><li>多 Reactor 单进程 &#x2F; 线程；不常用，相比于单Reactor单线程，复杂且没有性能优势。</li><li>多 Reactor 多进程 &#x2F; 线程；</li></ul><h3 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a>单Reactor单线程</h3><p><img src="https://pic.imgdb.cn/item/660180009f345e8d03d2ebc8.webp" alt="单Reactor单线程"></p><ul><li>Reactor 对象的作用是监听和分发事件，通过<code>IO多路复用接口监听事件</code>，dispatch是分发事件操作。具体分发给Acceptor对象还是Handler对象，还要看收到的事件类型。</li><li>Acceptor对象的作用是获取连接,Acceptor对象会通过<code>accept方法获取连接，并创建一个Handler对象来处理后续的响应事件</code>。回调方法。</li><li>Handler 对象的作用是处理业务，完成完整的业务流程。</li></ul><p>缺点：</p><ul><li>无法利用CPU多核优势。</li><li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟。</li></ul><p><code>单 Reactor 单进程的方案不适用计算机密集型的场景，只适用于业务处理非常快速的场景。</code></p><p><strong>Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</strong></p><h3 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h3><p><img src="https://pic.imgdb.cn/item/6601800a9f345e8d03d33998.webp" alt="单Reactor多线程"></p><ul><li>Reactor 对象的作用是监听和分发事件，通过<code>IO多路复用接口监听事件</code>，dispatch是分发事件操作。具体分发给Acceptor对象还是Handler对象，还要看收到的事件类型。</li><li>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</li><li>如果不是连接建立事件， 则交由当前连接对应的Handler对象来进行响应；只不过，Handler对象不再处理具体业务，而是开辟新的线程去处理业务逻辑。</li></ul><p><strong>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</strong></p><h3 id="多Reactor多线程"><a href="#多Reactor多线程" class="headerlink" title="多Reactor多线程"></a>多Reactor多线程</h3><p><img src="https://pic.imgdb.cn/item/6601808d9f345e8d03d70f74.png" alt="alt text"></p><ul><li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；</li><li>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入select继续进行监听，并创建一个Handler用于处理连接的响应事件。</li><li>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。</li></ul><h2 id="Proactor反应堆模式"><a href="#Proactor反应堆模式" class="headerlink" title="Proactor反应堆模式"></a>Proactor反应堆模式</h2><p><code>Proactor是异步网络模式。</code></p><h3 id="阻塞、非阻塞、同步、异步IO"><a href="#阻塞、非阻塞、同步、异步IO" class="headerlink" title="阻塞、非阻塞、同步、异步IO"></a>阻塞、非阻塞、同步、异步IO</h3><ul><li>阻塞：程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。需要等待<code>内核数据准备好</code>和<code>数据从内核态拷贝到用户态</code>两个过程。</li><li>非阻塞：<code>read 请求在数据未准备好的情况下立即返回</code>，可以继续往下执行，此时<code>应用程序不断轮询内核</code>，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。所以说非阻塞等待的是<code>数据从内核态拷贝到用户态</code>。</li><li>同步 I&#x2F;O：无论阻塞还是非阻塞都是同步调用，Reactor模式就是同步非阻塞IO方式。</li><li>异步 I&#x2F;O：<code>内核数据准备好</code>和<code>数据从内核态拷贝到用户态</code>两个过程都不等待。内核自动将数据从内核空间拷贝到用户空间，这个拷贝过程同样是异步的，<code>内核自动完成的。</code></li></ul><p>你去打印店，打印东西，一个个排队打印，是同步阻塞。<br>同步非阻塞是什么时候有时间，店家给你打电话。<br>异步操作：店家打印好给你打电话去取。<br><code>同步非阻塞是半托管，异步非阻塞是全托管。</code></p><p>看起来Proactor这种方式比Reactor这种模式更好。</p><ul><li>在 Linux下的异步I&#x2F;O是不完善的， aio系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的socket是不支持的，这也使得<code>基于Linux的高性能网络程序都是使用Reactor方案。</code></li><li>Windows 里实现了一套完整的支持socket的异步编程接口，这套接口就是<code>IOCP，是由操作系统级别实现的异步I/O，真正意义上异步I/O，因此在Windows里实现高性能网络程序可以使用效率更高的Proactor方案</code>。</li></ul><p><strong>从技术上看：IOCP比EPOLL更智能，全包了。但是Epoll的效率高于IOCP？IOCP确实看上去更智能，啥事都干完了，但同异步情况来看，并不见得就比Epoll要好。无非就是收包这步系统做了。linux内核的协议栈实现要优于windows，因为linux本身就是服务器的架构。</strong></p><p>现阶段网络上比较流行的网络库中：libevent和boost.asio，相对轻量级一点。</p><ul><li>libevent基于Reactor。libevent是一个C语言写的网络库，官方主要支持的是类linux操作系统，最新的版本添加了对windows的IOCP的支持。在跨平台方面主要通过select模型来进行支持。</li><li>Boost.asio基于Proactor。Boost.Asio类库，其就是以Proactor这种设计模式来实现，是C++的库，用起来更爽。</li></ul><p>参考链接</p><p><a href="https://zhuanlan.zhihu.com/p/368089289">https://zhuanlan.zhihu.com/p/368089289</a></p><p><a href="https://blog.csdn.net/yand789/article/details/10906329">https://blog.csdn.net/yand789/article/details/10906329</a></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio实现http服务器</title>
    <link href="/2024/03/25/asio%E5%AE%9E%E7%8E%B0http%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2024/03/25/asio%E5%AE%9E%E7%8E%B0http%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="asio实现简易的http服务器"><a href="#asio实现简易的http服务器" class="headerlink" title="asio实现简易的http服务器"></a>asio实现简易的http服务器</h1><ul><li><a href="#asio%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8">asio实现简易的http服务器</a><ul><li><a href="#client">client</a></li><li><a href="#server">Server</a></li><li><a href="#beast-%E5%AE%9E%E7%8E%B0http-server">Beast 实现http server</a></li></ul></li></ul><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">1. 发送肯定要用到io_context上下文</span><br><span class="hljs-comment">2. server：服务器地址</span><br><span class="hljs-comment">3. path：要请求的路径</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    tcp::resolver resolver_; // 解析域名</span><br><span class="hljs-comment">    tcp::socket socket_; // socket连接</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">client</span>(boost::asio::io_context&amp; io_context,<span class="hljs-type">const</span> std::string&amp; server, <span class="hljs-type">const</span> std::string&amp; path)<br>    : <span class="hljs-built_in">resolver_</span>(io_context),<span class="hljs-built_in">socket_</span>(io_context)<br></code></pre></td></tr></table></figure><p>初始化的客户端：发送消息，先发送头部。</p><ul><li>异步解析ip和端口：封装请求头，调用async_resolve，回调handle_resolve解析ip和端口。</li><li>handle_resolve：如果解析失败报错，解析成功则调用异步连接async_connect，回调handle_connect。</li><li>handle_connect：失败打印，成功调用异步写函数async_write，发送请求头，回调handle_write_request。</li><li>handle_write_request：看请求头发送成功还是失败。成功的话调用async_read_until，异步读，直到读取到”\r\n”，证明读取到了服务器发送回的响应头，回调handle_read_status_line。</li><li>handle_read_status_line 请求头中的状态码如果是200，则说明响应成功，接下来把所有的头部信息都读出来handle_read_headers。</li><li>handle_read_headers：代码逐行读出头部信息，然后读出响应的内容handle_read_content。</li><li>handle_read_content：继续监听读事件读取相应的内容，直到接收到EOF信息，也就是对方关闭，继续监听读事件是因为有可能是长连接的方式，当然如果是短链接，则服务器关闭连接后，客户端也是通过异步函数读取EOF进而结束请求。</li></ul><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><ul><li>http::server::server s(“127.0.0.1”, “8080”, path.string()); 初始化服务器相关信息。包括地址和端口，以及初始化的文件路径。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/** </span><br><span class="hljs-comment">    signals_ 是优雅退出的时候绑定的信号。</span><br><span class="hljs-comment">    acceptor_ 用来监听的对端的连接。</span><br><span class="hljs-comment">    connection_manager_ 接收到对端的连接后，放到connection_manager_中进行处理，读写都交给manager处理。</span><br><span class="hljs-comment">    socket_：为每个连接到来分配一个socket</span><br><span class="hljs-comment">    request_handler_:处理请求。</span><br><span class="hljs-comment">*/</span><br>server::<span class="hljs-built_in">server</span>(<span class="hljs-type">const</span> std::string&amp; address, <span class="hljs-type">const</span> std::string&amp; port, <span class="hljs-type">const</span> std::string&amp; doc_root): <span class="hljs-built_in">io_service_</span>(),<span class="hljs-built_in">signals_</span>(io_service_),<span class="hljs-built_in">acceptor_</span>(io_service_),<span class="hljs-built_in">connection_manager_</span>(),<span class="hljs-built_in">socket_</span>(io_service_),<span class="hljs-built_in">request_handler_</span>(doc_root)&#123;<br>            &#125;<br></code></pre></td></tr></table></figure><ul><li>do_await_stop: 里面调用signals_.async_wait，异步等待退出信号，优雅退出 。会将acceptor_.close();并且connection_manager_.stop_all();都关闭之后再进行退出。</li><li>boost::asio::ip::tcp::resolver resolver(io_service_); 初始化一个解析器，绑定到io_service_里，会返回一个端点endpoint。</li><li>根据endpoint，打开设置，设置端口复用，设置bind,listen,do_accept();</li><li>do_accept():异步监听连接：acceptor_.async_accept。连接请求成功后把连接加到connection_manager_里面。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">connection_manager_.<span class="hljs-built_in">start</span>(std::<span class="hljs-built_in">make_shared</span>&lt;connection&gt;(std::<span class="hljs-built_in">move</span>(socket_),connection_manager_, request_handler_));<br></code></pre></td></tr></table></figure><ul><li>connection_manager_.start开始一个连接管理类，make_shared智能指针的方式创建一个新的连接connection对象，用std::move(socket_)，把socket_move到connection的构造函数里，以及manager自身和处理器request_handler_。</li><li>start函数就会do_read();do_read()会调用异步读请求async_read_some。</li><li>async_read_some：构造buffer去读，bytes_transferred是读到了多少数据，ec是成功还是失败。如果成功了，就要继续进行解析：调用request_parser::result_type result的方法。</li><li>std::tie把返回值绑定为一个元组。返回值有三种类型request_parser::good、request_parser::bad、还有继续接收数据。中间需要继续解析各种类型的数据。</li><li>do_write：调用的还是异步发送操作。</li><li>处理请求的时候，调用handle_request，需要将结果异步返回给对端。</li><li>handle_request：首先进行路径解码，<ul><li>判断路径是否为空或者路径格式不正确，如果不正确，直接返回bad_request，异常</li><li>判断发送一个斜杠，返回index.html,返回的时候，还是要先把头添上，然后再返回给对端。</li><li>如果是正常的目录或者文件，读取后发送。用substr，截取文件后缀名，然后发送文件。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connection::do_read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">self</span><span class="hljs-params">(shared_from_this())</span></span>;<br>socket_.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(buffer_),<br>[<span class="hljs-keyword">this</span>, self](boost::system::error_code ec, std::<span class="hljs-type">size_t</span> bytes_transferred)<br>&#123;<br><span class="hljs-keyword">if</span> (!ec)<br>&#123;<br>request_parser::result_type result;<br>std::<span class="hljs-built_in">tie</span>(result, std::ignore) = request_parser_.<span class="hljs-built_in">parse</span>(<br>request_, buffer_.<span class="hljs-built_in">data</span>(), buffer_.<span class="hljs-built_in">data</span>() + bytes_transferred);<br><br><span class="hljs-keyword">if</span> (result == request_parser::good)<br>&#123;<br>request_handler_.<span class="hljs-built_in">handle_request</span>(request_, reply_);<br><span class="hljs-built_in">do_write</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result == request_parser::bad)<br>&#123;<br>reply_ = reply::<span class="hljs-built_in">stock_reply</span>(reply::bad_request);<br><span class="hljs-built_in">do_write</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">do_read</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ec != boost::asio::error::operation_aborted)<br>&#123;<br>connection_manager_.<span class="hljs-built_in">stop</span>(<span class="hljs-built_in">shared_from_this</span>());<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Beast-实现http-server"><a href="#Beast-实现http-server" class="headerlink" title="Beast 实现http server"></a>Beast 实现http server</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// BeastHttp.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/beast/core.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/beast/http.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/beast/version.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span> <span class="hljs-comment">//时钟相关</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;json/json.h&gt;</span> <span class="hljs-comment">// post请求的时候，post一个json数据的时候，处理数据</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;json/value.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;json/reader.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Json;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> beast = boost::beast; <span class="hljs-comment">//空间命名</span><br><span class="hljs-keyword">namespace</span> http = beast::http;<br><span class="hljs-keyword">namespace</span> net = boost::asio;<br><span class="hljs-keyword">using</span> tcp = boost::asio::ip::tcp;<br><br><span class="hljs-keyword">namespace</span> my_program_state &#123;<br>    <span class="hljs-comment">// 获取别人连接我们服务器了多少次</span><br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">request_count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> std::<span class="hljs-type">size_t</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> count++;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前时间戳</span><br>    <span class="hljs-function">std::<span class="hljs-type">time_t</span> <span class="hljs-title">now</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// http的连接类，为了能以智能指针的方式使用，并且能够在内部分享出自己的智能指针，</span><br><span class="hljs-comment">// 继承public std::enable_shared_from_this&lt;http_connection&gt;，允许分享智能指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">http_connection</span> :<span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;http_connection&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        socket_(socket) ：这种构造方式是不行的，socket是不允许做拷贝赋值的</span><br><span class="hljs-comment">        拷贝赋值会调用拷贝构造，socket不实现拷贝构造，那这里就会报错</span><br><span class="hljs-comment">        要么传一个引用，要么用移动赋值，move语义来做。</span><br><span class="hljs-comment">        1. 如果传入引用，那么管理类中的socket就不能独立的管理这个socket</span><br><span class="hljs-comment">        2. 用move语义，移动构造来做，就可以实现独立管理功能，这也是C++11的妙处</span><br><span class="hljs-comment">        移动构造，就把类的使用时间，都交给了类的成员来管理，可用有效性就失效了</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">http_connection</span>(tcp::socket socket):<span class="hljs-built_in">socket_</span>(std::<span class="hljs-built_in">move</span>(socket)) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">read_request</span>();<br>        <span class="hljs-built_in">check_deadline</span>(); <span class="hljs-comment">// 超时检测：tcp是一个长连接，http是一个短连接，时间长了以后，就把这个Http断掉，保证连接处理不要太超时</span><br><br><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    tcp::socket socket_;<br>    beast::flat_buffer buffer_&#123; <span class="hljs-number">8192</span> &#125;; <span class="hljs-comment">// beast的buffer类型</span><br>    http::request&lt;http::dynamic_body&gt; request_;  <span class="hljs-comment">// dynamic_body动态包体，可以接收各种请求</span><br>    http::response&lt;http::dynamic_body&gt; response_;<br><br>    <span class="hljs-comment">// asio设计的定时器，设置时间超过1分钟，就认为是超时了。</span><br>    net::steady_timer deadline_&#123;socket_.<span class="hljs-built_in">get_executor</span>(),std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">60</span>) &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_request</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> self = <span class="hljs-built_in">shared_from_this</span>();<br>        <span class="hljs-comment">// 异步去读</span><br>        http::<span class="hljs-built_in">async_read</span>(socket_, buffer_, request_, [self](beast::error_code ec,std::<span class="hljs-type">size_t</span> bytes_transferred) &#123;<br>            boost::<span class="hljs-built_in">ignore_unused</span>(bytes_transferred);<br>            <span class="hljs-keyword">if</span> (!ec) &#123;<br>                self-&gt;<span class="hljs-built_in">progress_request</span>();<br>            &#125;<br>            &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查超时</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_deadline</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> self = <span class="hljs-built_in">shared_from_this</span>();<br><br>        <span class="hljs-comment">// async_wait 异步表达式，接收一个异步的回调函数，或者一个lambda表达式</span><br>        <span class="hljs-comment">// 捕获一个this，参数传递一个错误码，这里会有一个异常，这个函数只会在超时之后调用，60s的时间里，http_connection可能都已经回收了</span><br>        <span class="hljs-comment">// 变成捕获self</span><br>        deadline_.<span class="hljs-built_in">async_wait</span>([self] (boost::system::error_code ec) &#123;<br>            <span class="hljs-keyword">if</span> (!ec) &#123;<br>                self-&gt;socket_.<span class="hljs-built_in">close</span>();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">progress_request</span><span class="hljs-params">()</span> </span>&#123;<br>        response_.<span class="hljs-built_in">version</span>(request_.<span class="hljs-built_in">version</span>());<br>        response_.<span class="hljs-built_in">keep_alive</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 短连接</span><br>        <span class="hljs-keyword">switch</span> (request_.<span class="hljs-built_in">method</span>())<br>        &#123;<br>        <span class="hljs-keyword">case</span> http::verb::get:<br>            response_.<span class="hljs-built_in">result</span>(http::status::ok);<br>            response_.<span class="hljs-built_in">set</span>(http::field::server, <span class="hljs-string">&quot;Beast&quot;</span>);<br>            <span class="hljs-built_in">create_response</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> http::verb::post:<br><span class="hljs-built_in">create_post_response</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            response_.<span class="hljs-built_in">result</span>(http::status::bad_request);<br>            response_.<span class="hljs-built_in">set</span>(http::field::content_type, <span class="hljs-string">&quot;text/plain&quot;</span>); <span class="hljs-comment">// 设置回应头</span><br>            <span class="hljs-comment">//beast::ostream，回应对象里面写数据了</span><br>            beast::<span class="hljs-built_in">ostream</span>(response_.<span class="hljs-built_in">body</span>()) &lt;&lt; <span class="hljs-string">&quot;Invalid request-method &#x27; &quot;</span> &lt;&lt; std::<span class="hljs-built_in">string</span>(request_.<span class="hljs-built_in">method_string</span>()) &lt;&lt; <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br><span class="hljs-comment">// 将数据发送回去</span><br><span class="hljs-built_in">write_response</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_response</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (request_.<span class="hljs-built_in">target</span>() == <span class="hljs-string">&quot;/count&quot;</span>) &#123;<br><span class="hljs-comment">// 回复一个html</span><br>            response_.<span class="hljs-built_in">set</span>(http::field::content_type,<span class="hljs-string">&quot;text/html&quot;</span>);<br>            beast::<span class="hljs-built_in">ostream</span>(response_.<span class="hljs-built_in">body</span>()) &lt;&lt; <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;Request count&lt;/title&gt;&lt;/head&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;h1&gt;Request count&lt;/h1&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;p&gt;There have been &quot;</span><br>&lt;&lt; my_program_state::<span class="hljs-built_in">request_count</span>() <span class="hljs-comment">//返回count</span><br>&lt;&lt; <span class="hljs-string">&quot; requests so far.&lt;/p&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;/html&gt;\n&quot;</span>;<br>        &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request_.<span class="hljs-built_in">target</span>() == <span class="hljs-string">&quot;/time&quot;</span>)<br>&#123;<br>response_.<span class="hljs-built_in">set</span>(http::field::content_type, <span class="hljs-string">&quot;text/html&quot;</span>);<br>beast::<span class="hljs-built_in">ostream</span>(response_.<span class="hljs-built_in">body</span>())<br>&lt;&lt; <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;p&gt;The current time is &quot;</span><br>&lt;&lt; my_program_state::<span class="hljs-built_in">now</span>()<br>&lt;&lt; <span class="hljs-string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;&lt;/html&gt;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>response_.<span class="hljs-built_in">result</span>(http::status::not_found);<br>response_.<span class="hljs-built_in">set</span>(http::field::content_type, <span class="hljs-string">&quot;text/plain&quot;</span>);<br>beast::<span class="hljs-built_in">ostream</span>(response_.<span class="hljs-built_in">body</span>()) &lt;&lt; <span class="hljs-string">&quot;File not found\r\n&quot;</span>;<br>&#125;<br><br><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_post_response</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (request_.<span class="hljs-built_in">target</span>() == <span class="hljs-string">&quot;/email&quot;</span>)<br>&#123;<br><span class="hljs-keyword">auto</span>&amp; body = <span class="hljs-keyword">this</span>-&gt;request_.<span class="hljs-built_in">body</span>();<br><span class="hljs-keyword">auto</span> body_str = boost::beast::<span class="hljs-built_in">buffers_to_string</span>(body.<span class="hljs-built_in">data</span>());<br>std::cout &lt;&lt; <span class="hljs-string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;<br><span class="hljs-keyword">this</span>-&gt;response_.<span class="hljs-built_in">set</span>(http::field::content_type, <span class="hljs-string">&quot;text/json&quot;</span>);<br>Json::Value root;<br>Json::Reader reader;<br>Json::Value src_root;<br><span class="hljs-type">bool</span> parse_success = reader.<span class="hljs-built_in">parse</span>(body_str, src_root);<br><span class="hljs-keyword">if</span> (!parse_success) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std::endl;<br>root[<span class="hljs-string">&quot;error&quot;</span>] = <span class="hljs-number">1001</span>;<br>std::string jsonstr = root.<span class="hljs-built_in">toStyledString</span>();<br>beast::<span class="hljs-built_in">ostream</span>(<span class="hljs-keyword">this</span>-&gt;response_.<span class="hljs-built_in">body</span>()) &lt;&lt; jsonstr;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">auto</span> email = src_root[<span class="hljs-string">&quot;email&quot;</span>].<span class="hljs-built_in">asString</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;<br><br>root[<span class="hljs-string">&quot;error&quot;</span>] = <span class="hljs-number">0</span>;<br>root[<span class="hljs-string">&quot;email&quot;</span>] = src_root[<span class="hljs-string">&quot;email&quot;</span>];<br>root[<span class="hljs-string">&quot;msg&quot;</span>] = <span class="hljs-string">&quot;recevie email post success&quot;</span>;<br>std::string jsonstr = root.<span class="hljs-built_in">toStyledString</span>();<br>beast::<span class="hljs-built_in">ostream</span>(<span class="hljs-keyword">this</span>-&gt;response_.<span class="hljs-built_in">body</span>()) &lt;&lt; jsonstr;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>response_.<span class="hljs-built_in">result</span>(http::status::not_found);<br>response_.<span class="hljs-built_in">set</span>(http::field::content_type, <span class="hljs-string">&quot;text/plain&quot;</span>);<br>beast::<span class="hljs-built_in">ostream</span>(response_.<span class="hljs-built_in">body</span>()) &lt;&lt; <span class="hljs-string">&quot;File not found\r\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 异步的将数据写回去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_response</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">auto</span> self = <span class="hljs-built_in">shared_from_this</span>();<br><br>response_.<span class="hljs-built_in">content_length</span>(response_.<span class="hljs-built_in">body</span>().<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 写回数据的长度</span><br><br>http::<span class="hljs-built_in">async_write</span>(<br>socket_,<br>response_,<br>[self](beast::error_code ec, std::<span class="hljs-type">size_t</span>)<br>&#123;<br><span class="hljs-comment">// 发送完之后，服务器主动去关闭发送端，shutdown短连接</span><br>self-&gt;socket_.<span class="hljs-built_in">shutdown</span>(tcp::socket::shutdown_send, ec);<br>self-&gt;deadline_.<span class="hljs-built_in">cancel</span>(); <span class="hljs-comment">//定时器关闭 </span><br>&#125;);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_server</span><span class="hljs-params">(tcp::acceptor&amp; acceptor, tcp::socket&amp; socket)</span></span><br><span class="hljs-function"></span>&#123;<br>acceptor.<span class="hljs-built_in">async_accept</span>(socket,[&amp;](beast::error_code ec)&#123;<br><span class="hljs-keyword">if</span> (!ec)<br>std::<span class="hljs-built_in">make_shared</span>&lt;http_connection&gt;(std::<span class="hljs-built_in">move</span>(socket))-&gt;<span class="hljs-built_in">start</span>();<br><span class="hljs-built_in">http_server</span>(acceptor, socket);<span class="hljs-comment">// 继续监听请求</span><br>&#125;);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-comment">// Check command line arguments.</span><br><span class="hljs-comment">/*if (argc != 3)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;address&gt; &lt;port&gt;\n&quot;;</span><br><span class="hljs-comment">std::cerr &lt;&lt; &quot;  For IPv4, try:\n&quot;;</span><br><span class="hljs-comment">std::cerr &lt;&lt; &quot;    receiver 0.0.0.0 80\n&quot;;</span><br><span class="hljs-comment">std::cerr &lt;&lt; &quot;  For IPv6, try:\n&quot;;</span><br><span class="hljs-comment">std::cerr &lt;&lt; &quot;    receiver 0::0 80\n&quot;;</span><br><span class="hljs-comment">return EXIT_FAILURE;</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> address = net::ip::<span class="hljs-built_in">make_address</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>&gt;(<span class="hljs-number">8080</span>); <span class="hljs-comment">//静态转换类型</span><br><br>net::io_context ioc&#123; <span class="hljs-number">1</span> &#125;;<br><br>tcp::acceptor acceptor&#123; ioc, &#123;address, port&#125; &#125;;<br>tcp::socket socket&#123; ioc &#125;;<br><span class="hljs-built_in">http_server</span>(acceptor, socket);<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;server&quot;</span> &lt;&lt; endl;<br><br>ioc.<span class="hljs-built_in">run</span>();<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception <span class="hljs-type">const</span>&amp; e)<br>&#123;<br>std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="/2024/03/07/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/03/07/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo搭建博客"><a href="#hexo搭建博客" class="headerlink" title="hexo搭建博客"></a>hexo搭建博客</h2><ul><li>安装完成node.js，安装后验证：node -v </li><li>安装cnpm: npm install -g cnpm –registry&#x3D;&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a>  装后验证：cnpm -v </li><li>安装hexo：cnpm install -g hexo-cli 安装后验证：hexo  -v </li><li>打开git或者gitee，托管项目到github上。</li></ul><p>博客更新流程：</p><ul><li>hexo clean</li><li>hexo g 生成</li><li>hexo d 上传到github ： 就可以通过github的页面进行访问了。如果不需要上传到github，可以不用执行这一步。</li><li>hexo s 启动本地服务，localhost:4000就可以访问了。</li></ul><p>hexo的文件启动相关的命令，自己查询一下简单命令。</p><h3 id="生成静态网站"><a href="#生成静态网站" class="headerlink" title="生成静态网站"></a>生成静态网站</h3><p>生成之前先清理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><h3 id="代码上传到远端"><a href="#代码上传到远端" class="headerlink" title="代码上传到远端"></a>代码上传到远端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><h3 id="配图"><a href="#配图" class="headerlink" title="配图"></a>配图</h3><p>markdown配图，保存到图床上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">聚合图床：https://www.superbed.cn<br>小贱贱图床：https://pic.xiaojianjian.net<br>遇见图床：https://www.hualigs.cn<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
